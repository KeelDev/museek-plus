#! /usr/bin/python
#-*- coding: utf-8 -*-

# Mucous - a curses client for museek 
# Based on Museekchat
# Config-parsing code modified from Nicotine's config.py
##-*- coding: iso-8859-1 -*-
# Copyright (C) 2003-2004 Hyriand <hyriand@thegraveyard.org>
#
# Majority of code by daelstorm (C) 2005-2006
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

import sys
try:
	import mucipher
except:
	print "WARNING: The Mucipher Module for Python wasn't found. This is absolutely necessary to allow Mucous to connect to the Museek Daemon.\nDownload it here: http://thegraveyard.org/files/pymucipher-0.0.1.tar.gz\nExtract the tarball, and as Root or sudo, run:\npython setup.py install\nYou'll need GCC, Python and SWIG."
	sys.exit()
try:
	import messages, driver
except:
	try:
		from museek import messages, driver
	except:
		print "WARNING: The Museek Message-Parsing modules, messages.py and/or driver.py  were not found. Please install them into your '/usr/lib/python2.X/site-packages/museek' directory, or place them in a 'museek' subdirectory of the directory that contains the mucous python scipt."
		sys.exit()
	
import signal, time, pwd, os, commands,  getopt,  threading, codecs, locale, select, string, re, ConfigParser
import curses.wrapper, curses.ascii

from time import sleep

from UserDict import UserDict

subprocess_fail=0
geoip_fail=0

try:
	import subprocess
except ImportError:
	subprocess_fail=1
try:
	import GeoIP
	gi = GeoIP.new(GeoIP.GEOIP_MEMORY_CACHE)
except ImportError:
	geoip_fail=1

config_dir = str(os.path.expanduser("~/.mucous/"))
log_dir = str(os.path.expanduser("~/.mucous/logs/"))
config_file = config_dir+"config"
from pymucous.utils import Version

def usage():
	print ("""Mucous is a client for Museek, the P2P Soulseek Daemon
Author: Daelstorm
Credit: Hyriand
Version: %s
	Default options: none
	-c,	--config <file>	Use a different config file
	-l,	--log <dir>	Use a different logging directory
	-v,	--version	Display version and quit

	-h,	--help		Display this help and exit
	""" %Version)
	sys.exit(2)
	
try:
	opts, args = getopt.getopt(sys.argv[1:], "hc:vl:", ["help", "config=", "version", "log="])
except getopt.GetoptError:
	usage()
	sys.exit(2)
for opts, args in opts:
	if opts in ("-h", "--help"):
		usage()
		sys.exit()
	if opts in ("-c", "--config"):
		config_file=str(os.path.expanduser(args))
	if opts in ("-l", "--log"):
		log_dir=str(os.path.expanduser(args))
	if opts in ("-v", "--version"):
		print "Mucous version: %s" % Version
		sys.exit(2)
		
parser = ConfigParser.ConfigParser()
# default config
mucous_config = {"connection":{"interface":'localhost:2240', "passw":None}, \
	"mucous":{"autobuddy": "no", "roomlistminsize": 5, "rooms_sort": "size", \
	"roombox": "big", "log_dir": "~/.mucous/logs/", "now-playing": "default", \
	"now-playing-prefix": None, "browse_display_mode": "filesystem", \
	"url reader": "firefox", "url custom prefix": "", "url custom suffix": "", \
	"transbox" : "split", "language": "iso-8859-1", "beep": "True",\
	"Auto-Retry": "True", "Auto-Clear": "False", "logging": "True", "extra_requests": "Yes"}, \
	"tickers":{'tickers_enabled': 'yes', "ticker_cycle": "yes", "rooms":{} }, \
	"aliases": {"mucous":"Mucous is a Curses client for the Museek Soulseek Daemon. Website: http://thegraveyard.org/daelstorm/mucous.php", "museek":"Museek is a Soulseek Daemon/Client. The website is http://museek.thegraveyard.org/"},\
	"rooms": {"default_room":"museek"}\
	}
		

	
class SortedDict(UserDict):
	def __init__(self):
		self.__keys__ = []
		self.__sorted__ = True
		UserDict.__init__(self)
	def __setitem__(self, key, value):
		if not self.__dict__.has_key(key):
			self.__keys__.append(key) 
			self.__sorted__ = False   
		UserDict.__setitem__(self, key, value)
	def __delitem__(self, key):
		self.__keys__.remove(key)
		UserDict.__delitem__(self, key)
	def keys(self):
		if not self.__sorted__:
			self.__keys__.sort()
			self.__sorted__ = True
		return self.__keys__
	def items(self):
		if not self.__sorted__:
			self.__keys__.sort()     
			self.__sorted__ = True
		for key in self.__keys__:
			yield key, self[key]		
alpha_list  = SortedDict()

def create_config():

	parser.read([config_file])

	mucous_config_file = file(config_file, 'w')
	
	for i in mucous_config.keys():
		if not parser.has_section(i):
			parser.add_section(i)
		for j in mucous_config[i].keys():
			if j not in ["nonexisting", "hated", "options"]:
				parser.set(i,j, mucous_config[i][j])
			else:
				parser.remove_option(i,j)
	parser.write(mucous_config_file)
	mucous_config_file.close()	


def read_config():
	
	parser.read([config_file])
	for i in parser.sections():
		for j in parser.options(i):
			val = parser.get(i,j, raw = 1)

			if j in ['login','passw','interface', 'roombox', 'tickers_enabled', "ticker_cycle", 'default_room', "autobuddy", "now-playing", "log_dir", "aliases" "now-playing-prefix", "browse_display_mode", "url reader", "url custom prefix", "url custom suffix", "transbox"] :
				mucous_config[i][j] = val
			elif i == 'aliases':
				mucous_config[i][j] = val
			else:
				try:
					mucous_config[i][j] = eval(val, {})
				except:
					mucous_config[i][j] = None

def update_config():
	mucous_config_file = file(config_file, 'w')
	for i in mucous_config.keys():
		if not parser.has_section(i):
			parser.add_section(i)
		for j in mucous_config[i].keys():
			if j not in ["sharedfiles","sharedfilesstreams","wordindex","fileindex","sharedmtimes"]:
				parser.set(i,j, mucous_config[i][j])
			else:
				parser.remove_option(i,j)
	parser.write(mucous_config_file)
	mucous_config_file.close()
	
def check_path():
	if os.path.exists(config_dir):
		if os.path.exists(config_file) and os.stat(config_file)[6] > 0:
			read_config()
		else:
			create_config()
			
	else:
		os.mkdir(config_dir, 0700)
		create_config()
check_path()



# This is the input line/bar
class editor(threading.Thread):
	def __init__(self, win, mucous):
		threading.Thread.__init__(self)
		self.win = win
		self.mucous = mucous
		self.key_mouse_funks = mucous.key_mouse_funks
		self.tabbing = mucous.tabbing
		self.history = mucous.history
		self.history_count = mucous.history_count
		self.h, self.w = win.getmaxyx()
		self.scroll = 0
		self.textwin = mucous.textwin
		self.line = mucous.line
		self.x = len(self.line)
		self.fixpos()
		self.escape = False
		self.y = None
		self.word = None
		self.listline = mucous.listline
		self.firsttab = 0
		

	def process(self, c):
		pos = self.x + self.scroll
		
		# debugging: display keypress
		#self.mucous.Hlog("debug", c )
		
		# Toggle online ONLY if inactivity timeout was met
		if self.mucous.timedout == True:
			self.mucous.toggle_away()
			self.mucous.timedout = False
		if self.mucous.status == 0:
			# Restart inactivity timeout for every key or mousepress if not away, currently
			self.mucous.timeout_timer.cancel()
			self.mucous.timeout_timer = threading.Timer(self.mucous.timeout_time, self.mucous.timeout)
			self.mucous.timeout_timer.start()
		else:
			self.mucous.timeout_timer.cancel()
		try:
	
			if c != chr(9) and c !="KEY_MOUSE":  # Clear self.word if tab wasn't pressed
				self.word = None
				self.firsttab = 0
				self.listline = []
			elif c not in ("KEY_UP", "KEY_DOWN"):
				self.history_count = -1

			if c == "KEY_MOUSE":
				error = 'mouse'
				if not self.escape:
					line = self.key_mouse_funks(c, self.line)
					if line != None:
						self.line = line
						self.x = len(self.line)
			elif c == "KEY_LEFT" or c == chr(2):
				error = 'left'
				if self.escape:
					self.key_mouse_funks(c, self.line)
				else:
					self.x -= 1
			elif c == chr(93) or c == chr(91)  or c == chr(34) or c == chr(35):
				error = 'right'
				if self.escape:
					self.key_mouse_funks(c, self.line)
				else:
					self.line = self.line[:pos] + c + self.line[pos:]
					self.x += 1
			elif c == "KEY_RIGHT" or c == chr(6):
				error = 'right'
				if self.escape:
					self.key_mouse_funks(c, self.line)
				else:
					self.x += 1
			elif c in ("KEY_F(1)", "KEY_F(2)", "KEY_F(3)", "KEY_F(4)", "KEY_F(5)", "KEY_F(6)", "KEY_F(7)", "KEY_F(8)", "KEY_F(9)", "KEY_F(10)"):
				if not self.escape:
					self.key_mouse_funks(c, self.line)
				
			elif c in ("KEY_UP", "KEY_DOWN"):
				# Scrolling
				if not self.escape:
					line = self.key_mouse_funks(c, self.line)
					if line != None:
						self.line = line
						self.x = len(self.line)
					
				elif self.escape:
					line, self.history_count = self.history(c, self.line, self.history_count)
					if line is not None:
						self.line = line
						self.x = len(self.line)
			elif c in ("KEY_SELECT", "KEY_FIND", "KEY_PPAGE", "KEY_NPAGE", "KEY_HOME", "KEY_END"): 
				# Scrolling
				if c == "KEY_SELECT":
					c = "KEY_NPAGE"
				elif c == "KEY_FIND":
					c = "KEY_PPAGE"
				if not self.escape:
					line = self.key_mouse_funks(c, self.line)
					if line != None:
						self.line = line
						self.x = len(self.line)
					
			elif c == "KEY_IC": # Insert
				self.key_mouse_funks(c, self.line)
			elif c == "KEY_DC" or c == chr(4):
				self.line = self.line[:pos] + self.line[pos+1:]
			elif c == chr(5):
				self.x = len(self.line)
			elif c == chr(1): # Ctrl - a
				self.x = self.scroll = 0
			elif c == chr(10) or c == "KEY_ENTER":
				if self.mucous.showmenu == True:
					self.mucous.menu_enter()
				else:
					self.escape = False
					self.key_mouse_funks(c, self.line)
					return True
			elif c == chr(27):
				if self.mucous.showmenu == True:
					self.mucous.menu_clear()
				else:
					self.escape = True
					return False		
			elif c in ("t", "T", "p", "P"):
				if self.escape:
					if c in ("t", "T"):
						self.key_mouse_funks("switch", self.line)
					if c in ("p", "P"):
						self.key_mouse_funks("popup", self.line)
				else:
					self.line = self.line[:pos] + c + self.line[pos:]
					self.x += 1
			elif c == chr(9): # Tab
				if self.word == None:
					w = self.line.split(' ')
					self.word = w[-1]
				#print "word is"+self.word
				if self.firsttab == None:
					self.firsttab = 0
				
				self.listline, self.firsttab= self.tabbing(self.line, self.word, self.firsttab, self.listline)
				
				#self.textwin.addstr(str(self.listline))
				if self.listline != []:
					self.line = ''
					for r in self.listline:
						if r is not self.listline[-1]:
							self.line +=r +' '
						elif r is self.listline[-1]:
							self.line +=r
				
				self.x = len(self.line)
				#return False
			elif c == chr(11):
				self.line = self.line[:pos]
				self.x = len(self.line)
				self.scroll = 0
			elif c == chr(23): # Ctrl-W
				z = self.line.split(' ')
	
				if len(z) >1:
					if z[-1] != ' ' and z[-1] != '':
						self.line = ''
						for s in z:
							if s is not z[-1]:
								self.line = self.line + s +" "
							elif s is z[-1]:
								self.line = self.line
								break
					else:
						self.line = ''
						for s in z:
							if s not in (z[-1], z[-2]):
								self.line = self.line + s +" "
							elif s is z[-2]:
								self.line = self.line
								break
				else:
					self.line = ''
				self.x = len(self.line)
	
			elif c == chr(127) or c == "KEY_BACKSPACE" or c == chr(8):
				if pos > 0:
					self.line = self.line[:pos-1] + self.line[pos:]
					self.x -= 1
	
			elif len(c) == 1 and ord(c[0]) >= 32 and ord(c[0]) <127:
				# normal letters 
				self.line = self.line[:pos] + c + self.line[pos:]
				self.x += 1
			elif len(c) == 1 and ord(c[0]) >= 127 and ord(c[0]) <327:
	
				self.line = self.line[:pos] + c + self.line[pos:]
				self.x += 1
			self.fixpos()
			self.mucous.line = self.line
			self.escape = False
			return False
		except Exception, e:
			self.mucous.Hlog("debug", "editor process: \""+str(self.line)+"\" "+ str(e))

	def fixpos(self):
		self.x1 = self.x
		if self.x1 <= 0:
			self.x1 = 0	
		while self.scroll + self.x > len(self.line):
			self.x -= 1
			
		while self.x >= self.w:
			self.scroll += 1
			
			self.x -= 1
		if self.x < 0:
			self.scroll += self.x
			
			self.x = 0

		if self.scroll < 0:
			self.scroll = 0

		self.win.erase()

		try:
			self.win.addstr(self.line[self.scroll:self.scroll+self.w-1])
		except Exception, e:
			self.mucous.Hlog("debug", "Editwin: "+ str(e))
			#pass
		self.win.refresh()

	def reset(self):
		self.x = self.scroll = 0
		self.mucous.line = self.line = ""

		self.win.erase()
		self.win.refresh()
		

class mucous(driver.Driver):

	def __init__(self):
		
		driver.Driver.__init__(self)
		
		self.rooms = {}
		self.current = None # Global edit title 
		self.selected = None
		self.username = None #  Your username
		self.manual_user = None # Manual Download Username
		self.pm_user = None # Last Private Messaged user
		self.privuser = None
		self.info_user = None
		self.connected = 0
		self.info_users = []
		self.current_room = None # Current Chatroom
		self.upload_user = None # User to send uploads to
		self.user_status = {}
		self.user_stats = {}
		
		# Encodings
		# Recommended: ISO-8859-1
		# UTF-16 AND ISO-8859-12 crash Mucous
		# UTF-8 is bad, since it's usually the original encoding being converted from
		self.encodings  = ['iso-8859-1', 'iso-8859-2', 'iso-8859-3', 'iso-8859-4', 'iso-8859-5', 'iso-8859-6', 'iso-8859-7', 'iso-8859-8', 'iso-8859-9', 'iso-8859-10', 'iso-8859-11', 'iso-8859-13', 'iso-8859-14', 'iso-8859-15', 'utf-8', 'utf-7',  'ascii']
		if "language" in mucous_config["mucous"]:
			if mucous_config["mucous"]["language"] not in self.encodings:
				mucous_config["mucous"]["language"] = "iso-8859-1"
		else:
			mucous_config["mucous"]["language"] = "iso-8859-1"
		self.states = {0: "Finished", 1: "Xferring", 2: "Negotiating", 3:"Waiting", 4: "Establishing", 5: "Initiating", 6: "Connecting",  7: "Queued", 8:"Address", 9:  "Status", 10: "Offline",11: "Closed",12: "Can't Connect", 13: "Aborted",14: "Not Shared"}
		self.alert = { "CHAT": {}, "PRIVATE": [], "TRANSFERS" : [],  "SEARCH": [], "INFO": [], "BROWSE": [],  "HELP": [] }
		
		# Temporary Logs
		self.log = [""] * 4
		self.onlinestatuslog ="Offline "
		self.usernamelog = [""] 
		self.uploadlog = "Up: 0"
		self.downloadlog ="Down: 0"
		self.searchwinlog = "Results: ", 0
		self.buddylog = [] 
		self.banlog = []
		self.ignorelog = []
		self.interestslog = []
		
		self.recommendations_list = {}
		self.similar_users = {}
		
		self.uptransferlog = [""]
		self.downtransferlog = [""]
		
		self.historylog=[]
		self.history_count = 0
		
		self.alertwinlog = ""
		self.privatelog = {}
		self.userinfolog = {}
		self.pminfolog = ["Global Private Messaging commands:",\
"To start a Private Message:",\
"1) Type in the username you wish to PM below",\
"2) Press <Enter>",\
"3) Type your messages",
"Use the commands below:",\
"/pm      <user>        (Start PM or switch to user)",\
"/close   <user>        (Close user's PM) ",\
"/close                 (Close current PM)",\
"/ip                    (Get the IP of current user)",\
"/msg <message>         (Send message to previous chosen user)"]

		self.searchlog={}
		self.searchlog["default__"] = ["Search commands:",\
"/searchfor   <query>   (Global Search)",\
"/searchbuddy <query>   (Buddy Search)",\
"/searchroom  <query>   (Room Search)",\
"/download <number>     (Download File with number)",\
"/downdir  <number>     (Download directory of File)",\
"/close                 (Close current search)",\
"/filter <string>       (limit displayed results)",\
"Mouse: Right-Click     (popup menu)",\
"Press Insert to toggle between searches.",\
"Press Alt-T to toggle Global/Buddy/Room searches",\

"Or, type in the query, below."]
		self.searchlist_displayed = []
		self.chosen_search="default__"
		self.browselog={}
		self.browselog["default__"] = ["----<Browse Commands>----",\
"/browse        (Switch to Browse Mode)",\
"/buser    <user>       (Browse User)",\
"/bsearch  <query>      (Search thru Shares)",\
"/download <number>     (Download file with this number)",\
"/close                 (close current shares)",\
"Press Insert to toggle between shares.",\
"--File System browsing commands--",\
"cd (change dir) get, getdir (download)",\
"First, type in the user you wish to browse, below.",\
"Right-click on directories or files to display the popup menu."]


		self.infolog = ["Global User Information commands:",\
"/userinfo <user>",\
"/stat     <user>",\
"/ip       <user>",\
"Or type the user name that you wish get recieve userinfo from, below.",\
 "--"]
		
		
		
		# Logging to file disabled by default
		if "logging" in mucous_config["mucous"]:
			pass
		else:
			mucous_config["mucous"]["logging"] = "True"
			
		
		self.url = None
		self.DisplayMode = "chat" # default mode
		self.display_which_list  = "buddies"
		self.chatroomscroll = "roomchat"
		self.roomboxlist ={}
		if "roombox" in mucous_config["mucous"].keys():
			self.chatdisplaymode = mucous_config["mucous"]["roombox"]
		else:
			self.chatdisplaymode = "big"
		if "roomlistminsize" in mucous_config["mucous"].keys():
			pass
		else:
			mucous_config["mucous"]["roomlistminsize"] = 1
		self.display_which_pm = None
		
		self.ip_requested = None
		self.info_requested = []
		self.stat_requested = None
		
		self.browse_requested = []
		self.browsed=[]
		self.browse_scroll = "directories"
		self.bfilter = None
		self.dsup = 0
		self.usershares = {}
		

		
		self.browse_list_results = {}
		self.browse_current_dir = ''
		self.browse_current = "default__"
		
		self.users_status={}
		self.status = None
		self.timedout = False
		self.startup = 1
		self.size = None
		self.roomlogs = {}
		self.statuslogs = {}
		
		if "rooms_sort" in mucous_config["mucous"]:
			if mucous_config["mucous"]["rooms_sort"] in ("", None):
				mucous_config["mucous"]["rooms_sort"] = "size"
			else:
				pass
		else:
			mucous_config["mucous"]["rooms_sort"] = "size"

		if "beep" in mucous_config["mucous"]:
			if mucous_config["mucous"]["beep"] not in ("True", "False"):
				mucous_config["mucous"]["beep"] = "True"
		else:
			mucous_config["mucous"]["beep"] = "True"
			
			
		if "log_dir" in mucous_config["mucous"]:
			if mucous_config["mucous"]["log_dir"] in ("", None, "None"):
				if log_dir in ("", None):
					mucous_config["mucous"]["log_dir"] = str(os.path.expanduser("~/.mucous/logs/"))
				else:
					mucous_config["mucous"]["log_dir"] = str(os.path.expanduser(log_dir))
				
		else:
			if log_dir in ("", None, "None"):
				mucous_config["mucous"]["log_dir"] = str(os.path.expanduser("~/.mucous/logs/"))
			else:
				mucous_config["mucous"]["log_dir"] = str(os.path.expanduser(log_dir))
			
							
		#mucous_config["mucous"]["log_dir"] = log_dir = str(os.path.expanduser(mucous_config["mucous"]["log_dir"]))
		
		self.tab_complete_list=[]
		self.tab_positions= {}
		self.listline = []
		self.Sup = 0
		self.Sup_last = 0
		self.end = 0
		self.start = 0
		
		self.last_transferscroll = None
			
		self.s_start =0
		self.s_end = -1
		
		self.requested_room_list = False
		
		self.all_roomlist = {}
		
		# searches
		self.search_visible = 1
		self.s_tickets = []
		self.s_query = {}
		self.sfilter= None
		self.search_results = {}
		self.search_number = 0
		self.search_type = "globally"
		self.search_format = "num"
		self.search_reverse = False
		self.sorted_search = []
		# transfers
		self.browse_results = {}
		self.browse_number = {}
		self.upload_number = 0
		self.upload_results = {}
		self.download_number = 0
		self.download_results = {}
		self.transfers = {}
		self.transfers["downloads"] = {}
		self.transfers["uploads"] = {}
		self.sorted_transfer_list = {}
		self.transfer_display_mode = 'all'
		self.transferscroll="download"
		if "transbox" in mucous_config["mucous"]:
			if mucous_config["mucous"]["transbox"] not in ("split", "tabbed"):
				mucous_config["mucous"]["transbox"] = "split"
		else:
			mucous_config["mucous"]["transbox"] = "split"
		self.down_transfer_numbers = {}
		self.up_transfer_numbers = {}
		self.trans_speed_display = True
		
		self.window_dimensions = {}
		self.menus = {}
		self.currentmenu = None
		self.showmenu = False
		
		# config
		self.config = {}
		self.invalidpass = 0
		self.stats = []
		self.setup_input_mode = "default"
		self.setup_display_mode = "mucous"
		self.unhide = "false" # show password?

		if "Auto-Retry" in mucous_config["mucous"]:
			if mucous_config["mucous"]["Auto-Retry"] not in ("True", "False"):
				mucous_config["mucous"]["Auto-Retry"] = "True"
		else:
			mucous_config["mucous"]["Auto-Retry"] = "True"
			
		if "Auto-Clear" in mucous_config["mucous"]:
			if mucous_config["mucous"]["Auto-Clear"] not in ("True", "False"):
				mucous_config["mucous"]["Auto-Clear"] = "False"
		else:
			mucous_config["mucous"]["Auto-Clear"] = "False"
			
		self.retry_timer = threading.Timer(30.0, self.retry_display)
		self.clear_timer = threading.Timer(30.0, self.clear_display)
		self.get_shares_timer = threading.Timer(0.5, self.get_shares)
		self.timer = threading.Timer(10.0, self.nickcheck)
		self.muscan_timer = threading.Timer(1.0, self.muscan_display)
		self.timeout_time =  900 * 1.0
		self.timeout_timer = threading.Timer(self.timeout_time, self.timeout)
		# tickers
		self.ticker_room = None
		self.master_ticklist = {}
		
		
		self.ticker_timer = threading.Timer(3.0, self.ticker_display)
		if "ticker_cycle" in mucous_config["tickers"].keys():
			pass
		else:
			mucous_config["tickers"]["ticker_cycle"] = "yes"
		# Help lists
		self.commandlist =  ["/me", "/j", "/join", "/p", "/part", "/l", "/leave", "/talk", "/say", "/alias", "/list", "/users", \
"/cd",  "/get", "/getdir", "/nick", "/privs", "/privileges", "/giveprivs ",\
"/help", "/info",  "/autojoin", "/roombox", "/transbox", "/roomlist", "/roomlistrefresh", \
"/inrooms", "/pm",  "/msg", "/np", "/npset", "/npcheck",\
"/npprefix", "/tickroom", "/tickcycle",  "/listtick", "/tickers", "/interface", "/password",\
"/save", "/connect", "/disconnect", "/autobuddy", "/privbuddy", "/onlybuddy",\
"/slots","/buddy", "/unbuddy",  "/ban", "/banlist", "/unban", "/nuke ", "/unnuke ",\
"/ignore", "/unignore",  "/unhide",  "/userinfo", "/ip ", "/stat ", "/away", "/abortup", "/percent", \
"/abortdown",  "/removeup", "/removedown", "/retry", "/retryall", "/clearup", "/cleardown", "/clearroom", "/clearsearchs", "/url", "/urlreader", "/urlcustom",\
"/search", "/searchfor", "/searchbuddy", "/searchroom", "/download", "/downdir", "/browse",\
"/browseuser", "/browsesearch", "/browsedown",  "/downuser",\
"/downpath", "/downpathdir",  "/chat", "/ignorelist", "/banlist", "/transfer", "/transfers", "/private",\
"/buddylist", "/setup", "/quit",  "/share-mode", "/logging", "/reloadshares", "/rescanshares", "/version", "/extra", \
"/logout", "/login", "/like ", "/donotlike ", "/donothate ", "/hate ", "/similar", "/globalrex", "/recommendations", "/rex", "/itemsimilar ", "/itemrex ", "/uploadto ", "/upload ", "/ctcpversion ", "/defaulttick ", "/settemptick ", "/settick "]

 		for alias in mucous_config["aliases"].keys():
			self.commandlist.append("/"+alias)
		
		self.help_chat = ["----[Chat Commands]----", \
"/join <room>   /part <room>  /leave <room>",\
"/j <room>      /talk <room>  /say <room> <message>",\
"/users <room>          (lists of users in room)",\
"/autojoin <room>       (Toggle Autojoining room)",\
"/roomlistrefresh       (redownload roomlist from server)",\
"/inrooms               (list of joined rooms)",\
"/clearroom <room>      (clear <room>, or current room)",\
"/pm <user>             (Private Message user)",\
"/msg <message>         (send message to last user)",\
"/url          /urlcustom (command$command)    (Requires X11)",\
"/urlreader (lynx|links|elinks|firefox|custom) (Requires X11)",\
"/np                    (XMMS/BMP Now playing script)",\
"/npcheck               (display Now playing script command)",\
"/npset <command>       (Set Now playing script to command)",\
"/npprefix <text>       (set to np: or /me is now playing:)",\
"/alias <alias> <text>  /unalias <alias>"]

		
		self.help_ticker = ["----<Ticker Commands>---- ",\
"/listtick <room>       (Lists tickers in room)",\
"/settick <message>     (set ticker for last room)",\
"/tickcycle             (Toggle cycling tickers in Chat Rooms)",\
"/tickers               (Toggle tickers)",\
"/defaulttick <message> (Set & save default ticker)",\
"/tickroom <room>       (Choose room for setting tickers)",\
"/settick <message>     (Set ticker to message, and save it)",\
"/settemptick <message> (Set ticker only for this session)",\
]

		self.help_connect = ["Connection Configuration",\
"/interface </tmp/museekd.[username]> or <host:port>",\
"/password <interface password>",\
"/connect               (Attempts to connect to Museekd)",\
"/disconnect            (Disconnects from Museekd)",\
"/save                  (Writes settings to config)"]

		self.help_setup = ["Setup",\
"/autobuddy             (Auto-buddy users you download from)",\
"/privbuddy             (Toggle Privileging buddies)",\
"/onlybuddy             (Toggle Only sharing to buddies)",\
"/slots <num>           (Set upload slots)",\
"/unhide                (Toggle show password)",\
"/logging               (Toggle Logging)"]

		self.help_user = ["----[User Commands]---- ",\
"/buddy    <user>    /unbuddy   <user>",\
"/ban      <user>    /unban     <user> (Cannot access your files)",\
"/ignore   <user>    /unignore  <user> (No messages in chat)",\
"/nuke     <user>    /unnuke    <user> (Ban+Ignore)",\
"/trust    <user>    /distrust  <user> (Can Upload to you)",\
"/stat     <user>    /ip        <user>",\
"/userinfo <user>    /giveprivs <user> (Input days next)",\
"/away (Toggle your Online/Away Status)"]

		self.help_transfer = ["----[Transfer Commands]---- ",\
"/abortu  <num> /abortup    <num> (Abort Upload)",\
"/abortd  <num> /abortdown  <num> (Abort Download)",\
"/removeu <num> /removeup   <num> (Remove Upload)",\
"/removed <num> /removedown <num> (Remove Download)",\
"/retry   <num>                   (Retry Download)",\
"/retryall                        (Retry all Downloads)",\
"/clearup                         (Clear failed/finished Uploads)",\
"/cleardown                       (Clear finished Download)",\
"/percent                         (Toggle Percent/Speed",\
"/transbox                        (Toggle Split/Tabbed Mode))"]
		self.help_mode_text = ["----[Mode Commands]---- ",\
"/chat          (Chat Mode)",\
"/transfer      (Transfer Mode)",\
"/info          (Info Mode)",\
"/browse        (Browse Mode)",\
"/private       (Private Message Mode)",\
"/search        (Search Mode)",\
"/buddylist     (Buddylist Mode)",\
"/banlist       (Banlist Mode)",\
"/ignorelist    (Ignorelist Mode)",\
"/roomlist      (Roomlist Mode)",\
"/setup         (Setup Mode)",\
"/help /debug   (Help & Debug Mode)"]

		self.help_help = ["----<Help Commands>---- ",\
"/help          (This Message)",\
"/help connect  (Connection Commands)",\
"/help setup    (Setup Commands)",\
"/help mode     (Mode Commands)",\
"/help chat     (Chatroom Commands)",\
"/help ticker   (Ticker Commands)",\
"/help user     (User Commands)",\
"/help transfer (Transfer Commands)",\
"/help browse   (Browse Commands)",\
"/help search   (Search Commands)",\
"/help download (Download Commands)",\
"/help keys     (Special Keys)",\
"/quit          (Close Mucous)"]
		
		self.help_search = ["----<Search Commands>----",\
"/search        (Switch to Search Mode)",\
"/searchfor   <query>",\
"/searchbuddy <query>",\
"/searchroom  <query>",\
"/download <search number>",\
"/downdir  <search number>",\
"/close         (Close Current Search)",\
"/clearsearchs  (Removes all searches)",\
"/filter (Turn OFF Filter) /filter <query> (Set Filter)"]

		self.help_browse = ["----<Browse Commands>----",\
"/browse        (Switch to Browse Mode)",\
"/buser    <user>       (Browse User)",\
"/bsearch  <query>      (Search thru Shares)",\
"/download <number>     (Download file with this number)",\
"/close                 (close current shares)",\
"Press Insert to toggle between shares.",\
"--File System browsing commands--",\
"cd (change dir) get, getdir (download)",\
"First, type in the user you wish to browse, below."]
		
		self.help_download = ["----<Manual Download Commands>----",\
"/downuser <user>    (Set download user)",\
"/downpath <path>    (Download file from user)",\
"/downpathdir <path> (Download dir from user)"]

		self.help_keys =["------<Keys>------ ",\
"ESC or Alt + [, ], <-, ->  (Change Room / Transfer display mode)",\
"Insert                     (Same as above)",\
"Tab                        (Completes nicks)",\
"Home/End                   (switches Upload & Download scrolling)",\
"Up, PageUp                 (Scroll Up a line, a page)",\
"Down, PageDown             (Scroll Down a line, a page)",\
"F1->Chat                 F6->Browse",\
"F2->Private Messages     F7->User Lists",\
"F3->Transfers            F8->Rooms List",\
"F4->Search               F9->Setup",\
"F5->Info                 F10->Help"]
		self.helpdebuglog = []
		self.helplog =["----<Help Commands>---- ",\
"/help          (This Message)",\
"/help connect  (Connection Commands)",\
"/help setup    (Setup Commands)",\
"/help mode     (Mode Commands)",\
"/help chat     (Chatroom Commands)",\
"/help ticker   (Ticker Commands)",\
"/help user     (User Commands)",\
"/help transfer (Transfer Commands)",\
"/help browse   (Browse Commands)",\
"/help search   (Search Commands)",\
"/help download (Download Commands)",\
"/help keys     (Special Keys)",\
"/quit"]	
		self.line = ""
	
	
		# Startup Size Check
		
		self.stdscr = curses.initscr()
		#curses.flushinp()
		#curses.setupterm()
		#self.helplog.append(str(curses.termattrs() ) )
		#self.helplog.append(str(curses.termname() ))
		curses.meta(1)
		h, w = self.stdscr.getmaxyx()
		#h,w = struct.unpack("HHHH", fcntl.ioctl(sys.stdout.fileno(),termios.TIOCGWINSZ, struct.pack("HHHH", 0, 0, 0, 0)))[:2]
		if  h <=5 or w <=37:
			self.stdscr.keypad(1)
			curses.echo()
			curses.endwin()
			print "Console kinda small, resize it, please"
			sys.exit()
		#---------------
		
		curses.start_color()
		curses.mousemask(curses.ALL_MOUSE_EVENTS)
		curses.mouseinterval(110)
		self.colors = {}
		if curses.has_colors() == True:
			try:
				curses.use_default_colors()
				curses.can_change_color()
				curses.init_pair(1, curses.COLOR_RED, -1)
				curses.init_pair(2, curses.COLOR_YELLOW, -1)
				curses.init_pair(3, curses.COLOR_CYAN, -1)
				curses.init_pair(4, curses.COLOR_BLUE, -1)
				curses.init_pair(5, curses.COLOR_GREEN, -1)
				curses.init_pair(6, curses.COLOR_BLACK, -1)
				curses.init_pair(7, curses.COLOR_WHITE, -1)
				curses.init_pair(8, curses.COLOR_MAGENTA, -1)
				curses.init_pair(9, 0, curses.COLOR_CYAN)
				curses.init_pair(10, curses.COLOR_GREEN, curses.COLOR_BLACK )
				curses.init_pair(11, curses.COLOR_YELLOW, curses.COLOR_BLUE)
				curses.init_pair(12, curses.COLOR_BLACK, curses.COLOR_WHITE)
				self.colors["red"] = curses.color_pair(1)
				self.colors["yellow"] = curses.color_pair(2)
				self.colors["cyan"] =  curses.color_pair(3)
				self.colors["blue"] = curses.color_pair(4)
				self.colors["green"] =  curses.color_pair(5)
				self.colors["black"] = curses.color_pair(6)
				self.colors["white"] = curses.color_pair(7)
				self.colors["magenta"] = curses.color_pair(8)
				self.colors["cybg"] = curses.color_pair(9)
				self.colors["greenbg"] = curses.color_pair(10)
				self.colors["hotkey"] = curses.color_pair(11)
				self.colors["blafgcyabg"] = curses.color_pair(12)
				
			except AttributeError:
				curses.init_pair(1, curses.COLOR_RED, 0)
				curses.init_pair(2, curses.COLOR_YELLOW, 0)
				curses.init_pair(3, curses.COLOR_CYAN, 0)
				curses.init_pair(4, curses.COLOR_BLUE, 0)
				curses.init_pair(5, curses.COLOR_GREEN, 0)
				curses.init_pair(6, curses.COLOR_BLACK, curses.COLOR_WHITE)
				curses.init_pair(7, curses.COLOR_WHITE, 0)
				curses.init_pair(8, curses.COLOR_MAGENTA, 0)
				curses.init_pair(9, 0, curses.COLOR_CYAN)
				curses.init_pair(10, curses.COLOR_GREEN, curses.COLOR_BLACK )
				curses.init_pair(11, curses.COLOR_YELLOW, curses.COLOR_BLUE)
				curses.init_pair(12, curses.COLOR_BLACK, curses.COLOR_WHITE)
				self.colors["red"] = curses.color_pair(1)
				self.colors["yellow"] = curses.color_pair(2)
				self.colors["cyan"] =  curses.color_pair(3)
				self.colors["blue"] = curses.color_pair(4)
				self.colors["green"] =  curses.color_pair(5)
				self.colors["black"] = curses.color_pair(6)
				self.colors["white"] = curses.color_pair(7)
				self.colors["magenta"] = curses.color_pair(8)
				self.colors["cybg"] = curses.color_pair(9)
				self.colors["greenbg"] = curses.color_pair(10)
				self.colors["hotkey"] = curses.color_pair(11)
				self.colors["blafgcyabg"] = curses.color_pair(12)
		else:
			self.colors["blafgcyabg"]  = self.colors["hotkey"] = self.colors["greenbg"] = self.colors["cybg"] = self.colors["magenta"] = self.colors["white"] =self.colors["black"]  = self.colors["cyan"] =  self.colors["yellow"] =self.colors["blue"]  =self.colors["green"] = self.colors["red"] =  curses.color_pair(0)
			#Disable cursor (bad idea)
# 			curses.curs_set(0)
		
		while 1:
			try:
				curses.noecho()
			except:
				pass
			try:
				curses.cbreak()
			except:
				pass
			self.stdscr.keypad(1)
			try:
				 self.line = self.build()
			except Exception, e:
				self.Hlog("debug", str(e) )
			if self.socket is None:
				self.connect()
			try:
				self.process()
			except select.error, e:
				self.line = self.build()
				# Terminal resized

				pass
			except Exception, e:
				self.shutdown()

	
	
	def build(self):
# 		h, w = struct.unpack("HHHH", fcntl.ioctl(sys.stdout.fileno(),termios.TIOCGWINSZ, struct.pack("HHHH", 0, 0, 0, 0)))[:2]
# 		os.environ["LINES"] = str(h)
# 		os.environ["COLUMNS"] =str(w)
		self.stdscr = curses.initscr()
		self.stdscr.erase()
		self.stdscr.refresh()
		self.h, self.w = self.stdscr.getmaxyx()
		
		try:
			
			self.inputwin = curses.newwin(3,self.w,self.h-4,0)
			self.inputwin.attron(self.colors["blue"])
			self.inputwin.border()
			self.inputwin.refresh()
			
			self.editwin = curses.newwin(1, self.w-2, self.h-3, 1)
			self.topbar_mode()

			self.showmenu = False
		except Exception, e:
			self.Hlog("debug", "Build: " + str(e))
		try:
			if self.DisplayMode == "chat":
				self.chat_mode()

			elif self.DisplayMode == "private":
				self.private_mode()

			elif self.DisplayMode == "browse":
				self.browse_mode()

			elif self.DisplayMode == "transfer":
				self.transfer_mode()

			elif self.DisplayMode == "info":
				self.info_mode()
				
			elif self.DisplayMode == "search":
				self.search_mode()
				
			elif self.DisplayMode == "lists":
				self.list_mode()
				
			elif self.DisplayMode == "rooms":
				self.rooms_mode()
				
			elif self.DisplayMode == "setup":
				self.setup_mode()
				
			elif self.DisplayMode in ("debug", "help"):
				self.help_mode()
				


		except Exception, e:
			self.Hlog("debug", "Build: " + str(e))
		try:
			self.edit = editor(self.editwin, self)

			self.stdscr.nodelay(1)	
		except:
			self.Hlog("debug", "Build: " + str(e))
		return self.line
		
	# THREADS THREADING vv
	
	def nickcheck(self):
		try:
			if self.username == None:
				self.DisplayMode = "debug"
				self.help_mode()
				self.Hlog("status", "Connection is taking a while to start, maybe you are trying to connect to a FTP daemon?")
				self.Hlog("status", "Killing connection..")
				self.Hlog("status", "Try using /interface to connect to a different port.")
				for line in self.help_connect:
					self.Hlog("status", line)
				driver.Driver.close(self)
		except Exception,e:
			self.Hlog("debug", "NickCheck: " + str(e))
			
	def retry_display(self):

		if mucous_config["mucous"]["Auto-Retry"] != "True":
			self.retry_timer.cancel()
		else:
			for user_path, transfer  in self.transfers["downloads"].items():
				if int(transfer[3]) in (10, 11, 12, 13, 14):
					self.send(messages.DownloadFile(transfer[1], transfer[2]))
			self.retry_timer.cancel()
			self.retry_timer = threading.Timer(30.0, self.retry_display)
			self.retry_timer.start()
			
	def timeout(self):
		try:
			self.timeout_timer.cancel()
			if self.status == 0:
				self.timedout = True
				self.toggle_away()

		except Exception,e:
			self.Hlog("debug", "timeout: " + str(e))
	
	def clear_display(self):
		if mucous_config["mucous"]["Auto-Clear"] != "True":
			self.clear_timer.cancel()
		else:
			for userpath, values in self.transfers["uploads"].items():
				if values[3] in (0, 10, 11, 12, 13, 14):
					self.send(messages.TransferRemove(1, values[1], values[2]))
						
			for userpath, values in self.transfers["downloads"].items():
				if values[3] == 0:
					self.send(messages.TransferRemove(0, values[1], values[2]))
			self.clear_timer.cancel()
			
			self.clear_timer = threading.Timer(30.0, self.clear_display)
			self.clear_timer.start()
					
	def muscan_display(self):
		
		self.muscan_timer.cancel()
		if subprocess_fail == 0:
			if mucous_config["connection"]["interface"][:9] in ("localhost", "/tmp/muse") and self.muscan_command != [] :
				p = "/usr/bin/muscan"
				if os.path.exists(p):
				
					z = subprocess.Popen( self.muscan_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
					#, close_fds = True)
					stdout_text, stderr_text = z.communicate()
					z.wait()
					
					stdout_text = stdout_text.split('\n')
					stderr_text = stderr_text.split('\n')
					#self.Hlog("debug", str(stdout_text))
					for line in stdout_text:
						if line.isspace() or line=='':
							pass
						else:
							self.Hlog("debug", line)
					for line in stderr_text:
						if line.isspace() or line=='':
							pass
						else:
							self.Hlog("status", line)
					self.Hlog("status", "Finished with shares.")
			else:
				self.Hlog("status", "Your Museekd is either running remotely or already running a command, cancelling.")
		else:
			self.Hlog("status", "This feature requires Python 2.4")
		self.muscan_command=[]
		
	def ticker_display(self):
		if self.DisplayMode == "chat":
			s = self.window_dimensions["chat"]
			for rooms8, ticks in self.master_ticklist.items():
				if rooms8 == self.current_room:
					ttickers =[]
					ttickers = ticks.keys()
					if ttickers != []:
						ttickers.sort()
						for names in ttickers:
							if self.ticker_z >= len(ttickers):
								self.ticker_z = 0
							if names == ttickers[self.ticker_z]:
								n= len(names)
								
								try:
									if self.showmenu == True: raise  Exception,  "Noticker"
									if self.chatdisplaymode not in ("nostatuslog", "chat-only"):
										if self.chatdisplaymode == "noroombox":
											ticker = "< ["+names+"] "+str(ticks[names][:self.w-2-9-n])
										else:
											ticker = "< ["+names+"] "+str(ticks[names][:self.w-15-2-9-n])
										self.borderlogwin.addstr(5, 3, self.decode_language( ticker ))
										t = len(ticker)
										fill = ""
										while len(fill) < s["width"]-4-t:
											fill += " "
										fill += ">"
										self.borderlogwin.addstr(fill)
										self.borderlogwin.refresh()
									elif self.chatdisplaymode in ("nostatuslog", "chat-only"):
										ticker = "< ["+names+"] "+str(ticks[names][:s["width"]-15-9-n])
										self.Mwin.addstr(0, 19, self.decode_language( ticker ))
										t = len(ticker)
										fill = ""
										while len(fill) < s["width"]-4-15-t:
											fill += " "
										fill += ">"
										self.Mwin.addstr(fill)
										self.Mwin.refresh()
								except:
									pass
								

								self.ticker_z += 1
								if self.ticker_z >= len(ttickers):
									self.ticker_z = 0
								self.ticker_timer.cancel()
								self.ticker_timer = threading.Timer(3.0, self.ticker_display)
								self.ticker_timer.start()
								break
					else:
						self.ticker_timer.cancel()
						try:
							self.display_status_log_border()
							self.display_status_log()
							curses.doupdate()
						except:
							pass
						
		# THREADS THREADING THRU TIME ^^
		
	def disconnect(self):
		driver.Driver.close(self)
		
	def connect(self):
		try:
			keys = []
			
			while 1:
				
				self.host = mucous_config["connection"]["interface"]
				self.password = mucous_config["connection"]["passw"]
				
				try:
					if self.invalidpass == 0:
						if self.password != None:
							
							self.timer.cancel()
							self.timer = threading.Timer(10.0, self.nickcheck)
							self.timer.start()
							driver.Driver.connect(self, mucous_config["connection"]["interface"],  mucous_config["connection"]["passw"], messages.EM_CHAT |  messages.EM_USERINFO| messages.EM_PRIVATE| messages.EM_TRANSFERS  | messages.EM_USERSHARES | messages.EM_CONFIG |  messages.EM_INTERESTS) 
							
							break
						else:
							raise Exception,  "IdASS"
					else:
						raise Exception,  "INVPASS"
						
	
				except Exception, e:
					self.DisplayMode = "debug"
					self.help_mode()
					#self.Hlog("debug", str(e))
					if self.timer != None:
						self.timer.cancel()
					if e == "INVPASS":
						self.Hlog("status", "Incorrect Password, try another.")
					elif e == [111, "Connection refused"]:
						self.Hlog("status", e[1] +", make sure the daemon is running, or change the interface.")
					self.Hlog("debug", "Connection failed, try changing your interface or password")
					for lines in self.help_connect:
						self.Hlog("status", lines)
					q = "42"
					while q == "42":
						sleep(0.01)
						try:
							c = self.stdscr.getkey(self.h-3, self.edit.x+1)
							keys.append(c)
						except:
							pass
						if not keys:
							d = 1000
						else:
							d = 0
						while keys:
							c, keys = keys[0], keys[1:]
							
							try:
								if self.edit.process(c):
									line = self.edit.line
									yes = self.commands(line)
									
									if yes == 0:
										break
									elif yes == 2:
										return
									else:
										self.edit.reset()
							except:
								pass
		except Exception, e:
			self.Hlog("debug", str( e) )

	def process(self):
#		c = None
		keys = []
		
		while 1:
			try:
				c = self.stdscr.getkey(self.h-3, self.edit.x+1)
				keys.append(c)
			except:
				pass

			if not keys:
				d = 1000
			else:
				d = 0
			if self.socket != None:
			
				r, w, x = select.select([self.socket, sys.stdin], [], [self.socket], d)
				
			else:
				sleep(0.01)
			if self.socket in r:
				driver.Driver.process(self)

			if sys.stdin in r:
				try:
					c = self.stdscr.getkey(self.h-3, self.edit.x+1)
					keys.append(c)
					
				except Exception, e:
					pass
			while keys:
				
				c, keys = keys[0], keys[1:]
				try:
					
					if self.edit.process(c):
						self.line = self.edit.line
						yes = self.commands(self.line)
						
						if yes == 0:
							break
						elif yes == 2:
							return
						else:
							self.edit.reset()
							
				except Exception, e:
					self.Hlog("debug", "Processing... " + str(e))
					
	def commands(self, line):
		if line[:1] == "/" and line[:4] != "/me " and line[:2] != '//':
		
			if line == "/quit" or line == "/exit":
				self.shutdown()
				return 2
			elif line[:11] == "/disconnect":
				self.disconnect()
			elif line == "/debug":
				self.DisplayMode = "debug"
				self.help_mode()
			elif line[:5] == "/help":
				self.DisplayMode = "help"
				self.help_mode()
				if line[5:] == " chat":
					for line in self.help_chat:
						self.Hlog("help", line)
				elif line[5:] == " mode":
					for line in self.help_mode_text:
						self.Hlog("help", line)
				elif line[5:] == " user":
					for line in self.help_user:
						self.Hlog("help", line)
				elif line[5:] == " search":
					for line in self.help_search:
						self.Hlog("help", line)
				elif line[5:] == " browse":
					for line in self.help_browse:
						self.Hlog("help", line)
				elif line[5:] == " transfer":
					for line in self.help_transfer:
						self.Hlog("help", line)
				elif line[5:] == " ticker":
					for line in self.help_ticker:
						self.Hlog("help", line)
				elif line[5:] == " download":
					for line in self.help_download:
						self.Hlog("help", line)
				elif line[5:] == "":
					for line in self.help_help:
						self.Hlog("help", line)
				elif line[5:] == " keys":
					for line in self.help_keys:
						self.Hlog("help", line)
				elif line[5:] == " connect":
					for line in self.help_connect:
						self.Hlog("help", line)
				elif line[5:] == " setup":
					for line in self.help_setup:
						self.Hlog("help", line)
				try:
					self.edit.reset()
				except:
					pass
				'''
				Chatrooms
				'''
			elif line[:6] == "/talk ": 
				self.set_room(line[6:])
				
			elif line[:6] == "/join ":
				self.send(messages.JoinRoom( self.decode_language( line[6:] ) ))
			elif line[:3] == "/j ":
				self.send(messages.JoinRoom( self.decode_language( line[3:] ) ))
				
			elif line in ("/part", "/p", "/l", "/leave")  and self.current_room:
				self.send(messages.LeaveRoom(self.current_room))
				
			elif line[:6] == "/part ":
				for room in self.rooms.keys():
					if self.decode_language( line[6:] ) == room:
						self.send(messages.LeaveRoom(room))
						
			elif line[:7] == "/leave ":
				for room in self.rooms.keys():
					if self.decode_language( line[7:] ) == room:
						self.send(messages.LeaveRoom(room))
				
			elif line[:10] == "/autojoin " and line[10:] != '':
				if line[10:] in self.rooms.keys():
					room = line[10:]
					self.mod_config("autojoin", room, '')
				else:
					self.Hlog("status", "You aren't in room: %s" % line[5:])
					
			elif line == "/autojoin":
				if self.current_room != None:
					room = self.current_room
					self.mod_config("autojoin", room, '')
					
			elif line == "/extra":
				
				if mucous_config["mucous"]["extra_requests"] == "Yes":
					mucous_config["mucous"]["extra_requests"] = "No"
				elif mucous_config["mucous"]["extra_requests"] == "No":
					mucous_config["mucous"]["extra_requests"] = "Yes"
				if mucous_config["mucous"]["extra_requests"] not in ("Yes", "No"):
					mucous_config["mucous"]["extra_requests"] = "No"
				self.Hlog("status", "Extra, CTCP-like, requests are responded to? %s"  % mucous_config["mucous"]["extra_requests"] )
				
			elif line[:4] == "/ut ":
				try:
					try:
						num = int(line[4:])
						for username, path in self.down_transfer_numbers[num].items():
							self.send(messages.TransferUpdate(username, path) )
					except:
						return
					
				except Exception, e:
					self.Hlog("debug", str(e) )
					
			elif line[:6] == "/close":
				user = None
				if line[6:7] == " " and line[7:] != '':
					user == line[7:]
					
				if self.DisplayMode == 'private':
					if user != None: this_user = user
					else: this_user = self.pm_user
					if this_user != None:
						self.close_private_chat(this_user)
						
				elif self.DisplayMode == 'chat':
					if user != None: room = user
					else: room = self.current_room
					if room in self.rooms.keys():
						self.send(messages.LeaveRoom(room))
						
				elif self.DisplayMode == 'info':
					if user != None: this_user = user
					else: this_user = self.info_user
					if this_user != None:
						self.close_userinfo(this_user)
						
				elif self.DisplayMode == 'browse':
					if user != None: this_user = user
					else: this_user = self.browse_current
					if this_user != "default__":
						self.close_browse(this_user)
						
				elif self.DisplayMode =='search':
					if self.chosen_search != "default__":
						self.close_search(self.chosen_search)

			elif line[:4] == "/pm " and line[4:] != '':
				self.pm_user = line[4:]
				self.start_pm(self.pm_user)
				if self.DisplayMode == 'private':
					self.private_mode()

					
			elif line[:5] == "/msg " and line[5:] != '':
				if self.pm_user != None:
					message = line[5:]
					
					self.send_private_message(self.pm_user, message)
				else:
					self.DisplayMode = "debug"
					self.help_mode()
					self.Hlog("status", "Set a user to message with /pm!")
			elif line[:5] == "/away":
				self.toggle_away()
					
			elif line[:5] == "/say " and line[5:] !='':
				# /say <room> /me is hungry
				sine = line[5:]
				splited = sine.split(' ')
				if len(splited) > 1:
					
					if splited[0] in self.rooms.keys():
						room = splited[0]
						if splited[1].isspace():
							pass
						else:
							message = string.join(map(str, splited[1:]))
							self.say_in_chat("chat", room, message)
					else:
						if len(splited) > 2:
							s = ''
							n = 0
							
							#self.Hlog("debug", str(splited))
							for i in range(len(splited)):
								if i == 0:
									s =splited[i]
								else:
									s += ' ' +splited[i]
								n += 1
								if s in self.rooms.keys():
									break
		
							if s not in self.rooms.keys():
								self.Hlog("debug", s)
								pass
							else:
								room = s
								message = string.join(map(str, splited[n:]))
								if message.isspace():
									pass
								else:
									self.say_in_chat("chat", room, message)
							
		
			elif line[:4] == "/url" and line[4:] == '':
				self.url = None
				logfile = None
				if self.DisplayMode == "chat" and self.current_room != None:
					logfile = self.roomlogs[self.current_room]
				elif self.DisplayMode == "private" and self.pm_user != None:
					logfile = self.privatelog[self.pm_user]
				if logfile != None:
					lene = len(logfile)
					if lene > self.h-7:
						x = 3
					else:
						x = lene
					if x != 0:
						if self.DisplayMode == "chat":
							for line in logfile:
								if "://" in line[3]:
									urline = line[3].split(" ")
									for x in urline:
										if "://" in x: self.url = x
						elif self.DisplayMode == "private":
							for line in logfile:
								if "://" in line:
									urline = line.split(" ")
									for x in urline:
										if "://" in x: self.url = x
						
		
				if self.url != None:
					urlr = mucous_config["mucous"]["url reader"]
					if  urlr == "links":
						if os.path.expandvars("$TERM") != "linux" and os.path.exists("/usr/bin/links"):
							os.system("xterm -e 'TERM=xterm-color links "+self.url +"' &")
					elif urlr == "elinks":
						if os.path.expandvars("$TERM") != "linux" and os.path.exists("/usr/bin/elinks"):
							os.system("xterm -e 'TERM=xterm-color elinks "+self.url +"' &")
					elif urlr == "lynx":
						if os.path.expandvars("$TERM") != "linux" and os.path.exists("/usr/bin/lynx"):
							os.system("xterm -e 'TERM=xterm-color lynx "+self.url +"' &")	
					elif urlr == "firefox":
						os.system("mozilla -a firefox -remote 'openURL("+self.url +",new-tab)' &")
					elif urlr == "custom":
						os.system(mucous_config["mucous"]["url custom prefix"]+self.url+mucous_config["mucous"]["url custom suffix"]+" &")
						
			elif line[:11] == "/urlreader " and line[11:] != '':
				mucous_config["mucous"]["url reader"] = line[11:]
			elif line[:11] == "/urlcustom " and line[11:] != '':
				if "$" in line[11:]:
					custom = line[11:].split("$")
					if len(custom) > 1 and len(custom) < 3:
						mucous_config["mucous"]["url custom prefix"] = custom[0]
						mucous_config["mucous"]["url custom suffix"] = custom[1]
					elif len(custom) == 1:
						mucous_config["mucous"]["url custom prefix"] = custom[0]
						mucous_config["mucous"]["url custom suffix"] = ''
			elif line[:3] == "/np" and line[3:] == '':
				self.now_playing()
				
			elif line[:3] == "/w " and line[3:] != '' or line[:8] == "/window " and line[8:] != "":	
				if line[:3] == "/w ":
					num = line[3:]
				elif line[:8] == "/window ":
					num = line[8:]
				
				if num.isdigit() == 0:
					return
				
				if num == "1":
					self.chat_mode()
				elif num == "2":
					self.private_mode()
				elif num == "3":
					self.transfer_mode()
				elif num == "4":
					self.search_mode()
				elif num == "5":
					self.info_mode()
				elif num == "6":
					self.browse_mode()
				elif num == "7":
					self.list_mode()
				elif num == "8":
					self.rooms_mode()
				elif num == "9":
					self.setup_mode()
				elif num == "10":
					self.help_mode()
						
			elif line[:7] == "/npset " and line[7:] != '':
				mucous_config["mucous"]["now-playing"] =line[7:]
				
			elif line[:8] == "/npcheck" and line[8:] == '':
				if "now-playing" in mucous_config["mucous"].keys():
					self.Hlog("status", "Now playing command is: "+ str(mucous_config["mucous"]["now-playing"]))
				
			elif line[:10] == "/npprefix " and line[10:] != '':
				mucous_config["mucous"]["now-playing-prefix"] = line[10:]
				
			elif line == "/npprefix":
				if "now-playing-prefix" in mucous_config["mucous"]:
					mucous_config["mucous"]["now-playing-prefix"] = None
			elif line in ("/rescan", "/rescanshares"):
				self.muscan_command = ["muscan", "-v"]
				self.muscan_timer.cancel()
				self.muscan_timer = threading.Timer(1.0, self.muscan_display)
				self.muscan_timer.start()
				self.Hlog("status", "Updating shares with muscan, don't forget to Reload them.")
				
			elif line in ("/reload", "/reloadshares"):
				self.send(messages.ReloadShares() )
						
			elif line == "/redraw":
				self.line = self.build()
				
			elif line[:8] == "/logging":
				self.logging_toggle()
				
				if self.DisplayMode=="setup":
					self.setup_mode()
				'''
				User Information
				'''
			elif line[:10] == "/userinfo " and line[10:] != '':
				user = self.decode_language( line[10:] ) 
				self.info_requested.append(user)
				self.send(messages.UserInfo(user) )
					
			elif line[:3] == "/tc":
				self.completion_list()
			elif line[:10] == "/language ":
				mucous_config["mucous"]["language"] = line[10:]
				
			elif line[:4] == "/ip " and line[4:] != '':
				try:
					self.ip_requested = self.decode_language( str(line[4:]) )

					self.send(messages.PeerAddress(self.ip_requested))
				except Exception, e:
					self.Hlog("debug", e)
					
			elif line == "/ip":
				try:
					if self.DisplayMode == "private" and self.pm_user != None:
						self.ip_requested = self.pm_user
					self.send(messages.PeerAddress(self.ip_requested))
				except Exception, e:
					self.Hlog("debug", e)
					
			elif line[:6] == "/stat " and line[6:] != '':
				self.stat_requested = self.decode_language( str(line[6:]) )
				self.send(messages.PeerStats(self.stat_requested))
				'''
				MODE SELECTIONS
				'''
			
			elif line == "/chat" :
				self.chat_mode()
		
			elif line == "/private"  or line == "/privatechat":
				self.private_mode()
		
			elif line[:7] == "/search"  and line[7:] == '':
				self.search_mode()
		
			elif line == "/transfer"  or line == "/transfers":
				self.transfer_mode()
		
			elif line == "/info":
				self.info_mode()
				
			elif line == "/browse":
				self.browse_mode()
					
			elif line == "/buddylist" :
				self.display_which_list = "buddies"
				self.list_mode()
				
			elif line == "/banlist" :
				self.display_which_list = "banned"
				self.list_mode()
				
			elif line == "/ignorelist" :
				self.display_which_list = "ignored"
				self.list_mode()
				
			elif line == "/interests" :
				self.display_which_list = "interests"
				self.list_mode()
				
			elif line[:6] == "/setup"   and line[6:] == '':
				self.setup_mode()
				
				'''
				CONFIG
				'''
			elif line[:5] == "/save" and line[5:] == '':
				update_config()
				self.DisplayMode = "debug"
				self.help_mode()
				self.Hlog("status", "Config Saved")
			elif line[:11] == "/interface " and line[11:] != "":
				mucous_config["connection"]["interface"] = line[11:]
				self.Hlog("status", "Museekd interface set to: " + line[11:])
		
			elif line[:10] == "/password " and line[10:] != "":
				mucous_config["connection"]["passw"] = line[10:]
				self.Hlog("status", "New password set")
			elif line[:13] == "/ctcpversion ":
				user = line[13:]
				if user != "" and user.isspace() == False:
					self.send_private_message(user, curses.ascii.ctrl("A")+"VERSION"+curses.ascii.ctrl("A"))
			elif line == "/version":
				self.DisplayMode = "debug"
				self.help_mode()
				self.Hlog("status", "Mucous version: %s" % Version)
			elif line[:8] == "/connect":
				self.connect()
			
				'''
				Tickers
				'''
			elif line[:9] == "/tickroom":
				if line[9:] == '':
					self.ticker_room =  self.current_room
				elif line[9:10] == " " and line[10:] != '':
					self.ticker_room = line[10:]
					
			elif line[:7] == "/ticker" and line[7:] == '':
				if mucous_config["tickers"]["tickers_enabled"] == 'no':
					mucous_config["tickers"]["tickers_enabled"] = 'yes'
					
				elif mucous_config["tickers"]["tickers_enabled"] == 'yes':
					mucous_config["tickers"]["tickers_enabled"] = 'no'
					
			elif line[:10] == "/tickcycle" and line[10:] == '':
				if mucous_config["tickers"]["ticker_cycle"] == 'no':
					mucous_config["tickers"]["ticker_cycle"] = 'yes'
					
				elif mucous_config["tickers"]["ticker_cycle"] == 'yes':
					mucous_config["tickers"]["ticker_cycle"] = 'no'
					
					try:
						self.ticker_timer.cancel()
						if self.DisplayMode=="chat":
							self.display_status_log_border()
							self.display_status_log()
							curses.doupdate()
					except Exception, e:
						self.Hlog("status", e)
			elif line[:13] == "/defaulttick " and line[13:] != '':
				message = line[13:]
				self.send(messages.ConfigSet("default-ticker", "ticker", message))
				
			elif line[:13] == "/settemptick " and line[13:] != '':
				if self.ticker_room != None:
					message = line[13:]
					self.send(messages.RoomTickerSet(self.ticker_room, message))
				else:
					self.Hlog("status", "Choose a room with /tickroom, first.") 		
			elif line[:9] == "/settick " and line[9:] != '':
				if self.ticker_room != None:
					message = line[9:]
					self.send(messages.ConfigSet("tickers", self.ticker_room, message))
					self.send(messages.RoomTickerSet(self.ticker_room, message))
				else:
					self.Hlog("status", "Choose a room with /tickroom, first.") 
				'''
				List tickers in current room or selected rooms
				'''
			
			elif line[:9] == "/listtick":
				if line [9:] == '':
					woom = self.current_room
				else:
					woom = line[10:]
					
				alpha_list  = SortedDict()
				for rooms12 in self.master_ticklist:
					alpha_list[rooms12] = self.master_ticklist[rooms12]
				if mucous_config["tickers"]["tickers_enabled"] == 'yes':
					for rooms13, ticks in alpha_list.items():
						if rooms13 == woom:
							ttickers =[]
							ttickers = ticks.keys()
							if ttickers != []:
								self.info_log("Tickers in room: "+str(rooms13))
							ttickers.sort()
							for names in ttickers:
								self.info_log(" ["+str(names)+'] '+str(ticks[names]))
		
		
				'''
				User Management
				'''
			elif line[:5] == "/ban " and line[5:] != '':
				username = line[5:]
				self.mod_config("ban", username, '')
				
				
			elif line[:7] == "/unban " and line[7:] != '':
				username = line[7:]
				self.mod_config("unban", username, '')
				
					
			elif line[:8] == "/ignore " and line[8:] != '':
				username = line[8:]
				self.mod_config("ignore", username, '')
				
			elif line[:10] == "/unignore " and line[10:] != '':
				username = str(line[10:])
				self.mod_config("unignore", username, '')
						
			elif line[:7] == "/buddy " and line[7:] != '':
				username = str(line[7:])
				self.mod_config("buddy", username, '')
				
			elif line[:9] == "/unbuddy " and line[9:] != '':
				username = str(line[9:])
				self.mod_config("unbuddy", username, '')
				
			elif line[:6] == "/nuke " and line[6:] != '':
				username = str(line[6:])
				self.mod_config("ban", username, '')
				self.mod_config("ignore", username, '')
				
				self.Hlog("status", "Nuked: %s" % username)
				
			elif line[:8] == "/unnuke " and line[8:] != '':
				username = str(line[8:])
				if username in self.config["ignored"].keys():
					self.mod_config("unignore", username, '')
				if username in self.config["banned"].keys():
					self.mod_config("unban", username, '')
					
				self.Hlog("status", "Irradiated: %s" % username)
				
			elif line[:7] == "/trust ":
				username = line[7:]
				self.mod_config("trust", username, '')
			elif line[:10] == "/distrust ":	
				username = line[10:]
				self.mod_config("distrust", username, '')
				
			elif line[:11] == "/share-mode":
				if self.config["transfers"]["only_buddies"] == "true":
					self.send(messages.ConfigSet("transfers", "only_buddies", "false"))
					
				elif self.config["transfers"]["only_buddies"] == "false":
					self.send(messages.ConfigSet("transfers", "only_buddies", "true"))
		
				
			elif line[:11] == "/autobuddy":
				if mucous_config["mucous"]["autobuddy"]  == "yes":
					mucous_config["mucous"]["autobuddy"] = "no"
					self.Hlog("status", "AutoBuddy Disabled")
				elif mucous_config["mucous"]["autobuddy"]  == "no":
					mucous_config["mucous"]["autobuddy"] = "yes"
					self.Hlog("status", "AutoBuddy Enabled")
					
		
				'''
				List Users in room
				'''
			elif line[:5] == "/list":
				self.startup = 0
				if line [5:6] == ' ':
					woom = line[6:]
				else:
					woom = self.current_room
				if woom != None:
					self.show_nick_list(woom)
					
			elif line[:6] == "/users":
				self.startup = 0
				if line [6:7] == ' ':
					woom = line[7:]
				else:
					woom = self.current_room
				if woom != None:
					self.show_nick_list(woom)
					
			elif line == "/roombox":
				self.chat_room_cycle()
				
			elif line == "/login":
				self.send(messages.ConnectServer())
				
			elif line == "/logout":
				self.send(messages.DisconnectServer())
				
			elif line == "/globalrex":
				self.send(messages.GetGlobalRecommendations())

				
			elif line in ("/rex", "/recommendations"):
				self.send(messages.GetRecommendations())
			elif line[:10] == "/uploadto ":
				user = line[10:]
				if user.isspace() == 0 and user != "":
					self.upload_user = user
					
			elif line[:8] == "/upload":
				path = line[8:]
				if path.isspace() == 0 and path != "":
					self.send(messages.UploadFile(self.upload_user, path))	
					
			elif line in ("/similar", "/similarusers"):
				self.send(messages.GetSimilarUsers())
				
			elif line[:9] == "/itemrex ":
				if line[9:] != "" and line[9:].isspace() == 0:
					item = line[9:]
					self.send(messages.GetItemRecommendations(item))
					
			elif line[:13] == "/itemsimilar ":
				if line[13:] != "" and line[13:].isspace() == 0:
					item = line[13:]
					self.send(messages.GetItemSimilarUsers(item))
					
			elif line[:6] == "/like ":
				if line[6:] != "" and line[6:].isspace() == 0:
					interest = line[6:]
					self.send(messages.AddInterest(interest))
					
			elif line[:6] == "/hate ":
				if line[6:] != "" and line[6:].isspace() == 0:
					interest = line[6:]
					self.send(messages.AddHatedInterest(interest))
					
			elif line[:11] == "/donotlike ":
				if line[11:] != "" and line[11:].isspace() == 0:
					interest = line[11:]
					if interest in self.config["interests.like"]:
						self.send(messages.RemoveInterest(interest))
					
			elif line[:11] == "/donothate ":
				if line[11:] != "" and line[11:].isspace() == 0:
					interest = line[11:]
					if interest in self.config["interests.hate"]:
						self.send(messages.RemoveHatedInterest(interest))
					
			elif line == "/transbox":
				if mucous_config["mucous"]["transbox"]=="split":
					mucous_config["mucous"]["transbox"]="tabbed"
				elif mucous_config["mucous"]["transbox"]=="tabbed":
					mucous_config["mucous"]["transbox"]="split"
				self.transfer_mode()
				'''
				List Rooms whose number of users is greater than the number you input
				'''
			elif line[:9] == "/roomlist":
				
				if line[9:] == '':
					self.rooms_mode()
				elif line[9:] == 'refresh':
					self.requested_room_list = True
					self.send(messages.RoomList())
					
			elif line in ("/privs", "/privileges"):
				self.send(messages.CheckPrivileges())
				
			elif line[:11] == "/giveprivs " :
				try:
					self.privuser  = str(line[11:])
					self.set_edit_title( "% Give Privileges to " + self.privuser)
				except Exception, e:
					self.Hlog("debug", str(e))
				#self.send(messages.GivePrivileges("daelstorm", 20))
				
			elif line[:8] == "/inrooms" and line[8:] == '':
				w = ''
				for room in self.rooms.keys():
					w += room + ', '
					
				self.Hlog("status", "You are in: %s" %w[:-2])
				
				'''
				Manual Download
				'''	
			elif line[:10] == "/downuser " and  line[10:] != '':
				self.transfer_mode()
				self.manual_user = line[10:]
				self.set_edit_title("% % User: "+line[10:] + " (input download path) % %")
					
			elif line[:10] == "/downpath " and line[10:] != '':
				path = line[10:]
				if self.manual_user != None and self.manual_user != '':
					user = self.manual_user
					self.send(messages.DownloadFile(user, path))
					self.Hlog("status", "Trying to Download: " + path+" from "+ user)
			elif line[:13] == "/downpathdir " and line[13:] != '':
				directory = line[13:]
				if self.manual_user != None and self.manual_user != '':
					user = self.manual_user
					self.send(messages.GetFolderContents(user, directory))
					self.Hlog("status", "Try to Download directory: %s from %s" % (directory, user))
		
				'''
				Search Globally for files & Download them
				'''
			elif line[:11] == "/searchfor " and line[11:] != '':
				query = line[11:]
				if query not in ('mp3', ' ') and len(query) > 2:
					self.send(messages.Search(0, query))
					
				else:
					self.search_log("sstatus", "Query \""+ query+"\" was ignored", "default__", 0)
					
			elif line[:13] == "/searchbuddy " and line[13:] != '':
				query = line[13:]
				self.send(messages.Search(1, query))
			elif line[:12] == "/searchroom " and line[12:] != '':
				query = line[12:]
				self.send(messages.Search(2, query))
					
			elif line[:10] == "/download " or line[:9] == "/downdir ":
				linput = None
				if line[:10] == "/download " and line[10:] != '':
					dtype = "file"
					linput = line[10:]
				elif line[:9] == "/downdir "  and line[9:] != '':
					dtype = "dir"
					linput = line[9:]
				if linput != None:
					if linput.isdigit():
						self.download_path_file(dtype, linput)
					else:
						self.Hlog("status", "Enter an Integer")
						
			elif line[:8] == "/filter " and line[8:] != '':
				
				self.sfilter=line[8:]
				if self.DisplayMode=='search':
					self.search_mode()
			elif line == "/filter":
				self.sfilter=None
				if self.DisplayMode=='search':
					self.search_mode()
				'''
				Browse Shares & Download from them
				'''
			elif line[:4] == "/cd " and line[4:] != '':
				self.user_shares_cd(line[4:])
				
	
				
			elif line[:4] == "/get" and line[4:] != '':
				linput = None
				if line[:5] == "/get " and line[5:] != '':
					dtype = "file"
					linput = line[5:]
				elif line[:8] == "/getdir "  and line[8:] != '':
					dtype = "dir"
					linput = line[8:]
				if linput != None:
					if linput.isdigit():
						self.download_path_file(dtype, linput)
					else:
						self.Hlog("status", "Enter an Integer")
						
				
			elif line[:12] == "/browseuser " or line[:7] == "/buser ":
				user = None
				if line[:12] == "/browseuser " and line[12:] != '':
					user = line[12:]
				elif line[:7] == "/buser " and line[7:] != '':
					user = line[7:]
				if user != None:
					self.start_browse(user)
					
					
			elif line[:14] == "/browsesearch " or line[:9] == "/bsearch ":
				l_input = None
				if line[:14] == "/browsesearch " and line[14:] != '':
					l_input = line[14:]
				elif line[:9] == "/bsearch " and line[9:] != '':
					l_input = line[9:]
				if l_input != None:
					self.bfilter = re.compile('.*' +str(l_input) + '.*', re.DOTALL | re.I)
					self.browse_display()
					curses.doupdate()
			elif line == "/browsesearch" or line == "/bsearch":
				self.bfilter = None
				self.browse_display()
				curses.doupdate()
			elif line[:11] == "/hidesearch":
				self.search_visible = 0
				self.Hlog("status", "Searches hidden")
				
			elif line[:11] == "/showsearch":
				self.search_visible = 1
				self.Hlog("status", "Searches made visible")
				'''
				Manage Transfers
				'''
			elif line[:8] == "/abortd " or line[:11] == "/abortdown ":
				transfer = None
				if line[:8] == "/abortd " and line[8:] != '':
					if line[8:].isdigit():
						transfer = int(line[8:])
					else:
						self.Hlog("status", "Enter an Integer")
				elif line[:11] == "/abortdown " and line[11:] != '':
					try:
						transfer = int(line[11:])
					except:
						self.Hlog("status", "Enter an Integer")
					
				if transfer != None:
					if transfer in self.down_transfer_numbers.keys():
						for username, path in self.down_transfer_numbers[transfer].items():
							#self.Hlog("debug", username +' '+ path)
							self.Hlog("status", "Aborting download: [%s] %s" % (username, path))
							self.send(messages.TransferAbort(0, username, path))
					else:
						self.Hlog("status", "No such transfer #" + str(transfer))
			elif line[:8] == "/abortu " or line[:9] == "/abortup ":
				transfer = None
				if line[:8] == "/abortu " and line[8:] != '':
					try:
						transfer = int(line[8:])
					except:
						self.Hlog("status", "Enter an Integer")
				elif line[:9] == "/abortup " and line[9:] != '':
					try:
						transfer = int(line[9:])
					except:
						self.Hlog("status", "Enter an Integer")
				if transfer != None:
					if transfer in self.up_transfer_numbers.keys():
						for username, path in self.up_transfer_numbers[transfer].items():
							self.Hlog("status", "Aborting upload: [%s] %s" % (username, path))
							self.send(messages.TransferAbort(1, username, path))
					else:
						self.Hlog("status", "No such transfer #" + str(transfer))
			elif line[:9] == "/removeu " or line[:10] == "/removeup ":
				transfer = None
				if line[:9] == "/removeu " and line[9:] != '':
					try:
						transfer = int(line[9:])
					except:
						self.Hlog("status", "Enter an Integer")
				elif line[:10] == "/removeup " and line[10:] != '':
					try:
						transfer = int(line[10:])
					except:
						self.Hlog("status", "Enter an Integer")
				if transfer != None:
					if transfer in self.up_transfer_numbers.keys():
						for username, path in self.up_transfer_numbers[transfer].items():
							self.Hlog("status", "Removing upload: [%s] %s" % (username, path))
							self.send(messages.TransferRemove(1, username, path))
					else:
						self.Hlog("status", "No such transfer #" + str(transfer))
					
		
			elif line[:9] == "/removed " or line[:12] == "/removedown ":
				transfer = None
				if line[:9] == "/removed " and line[9:] != '':
					try:
						transfer = int(line[9:])
					except:
						self.Hlog("status", "Enter an Integer")
				elif line[:12] == "/removedown " and line[12:] != '':
					try:
						transfer = int(line[12:])
					except:
						self.Hlog("status", "Enter an Integer")
				if transfer != None:
					if transfer in self.down_transfer_numbers.keys():
						for username, path in self.down_transfer_numbers[transfer].items():
							self.Hlog("status", "Removing download: [%s] %s" % (username, path))
							self.send(messages.TransferRemove(0, username, path))
					else:
						self.Hlog("status", "No such transfer #" + str(transfer))
		
						
			elif line[:7] == "/retry " and line[7:] != '':
				transfer = None
				try:
					transfer = int(line[7:])
				except:
					self.Hlog("status", "Enter an Integer")
				if transfer != None:
					
					if transfer in self.down_transfer_numbers.keys():
						for username, path in self.down_transfer_numbers[transfer].items():
							self.Hlog("status", "Retrying download: [%s] %s" % (username, path))
							self.send(messages.DownloadFile(username, path))
					else:
						self.Hlog("status", "No such transfer #" + str(transfer))
						
			elif line[:9] == "/retryall":
				for user_path, transfer  in self.transfers["downloads"].items():
					if int(transfer[3]) in (10, 11, 12, 13, 14):
						self.send(messages.DownloadFile(transfer[1], transfer[2]))
		
			elif line[:7] == "/slots " and line[7:] != "":
				slots = None
				try:
					slots = int(line[7:])
				except:
					self.Hlog("status", "Enter an Integer")
				if slots != None:
					self.send(messages.ConfigSet("transfers", "upload_slots", str(slots)))
		
			elif line[:10] == "/privbuddy":
				if self.config["transfers"]["privilege_buddies"] == "true":
					self.send(messages.ConfigSet("transfers", "privilege_buddies", "false"))
					
				elif self.config["transfers"]["privilege_buddies"] == "false":
					self.send(messages.ConfigSet("transfers", "privilege_buddies", "true"))
					
					
			elif line[:10] == "/onlybuddy":
				if self.config["transfers"]["only_buddies"] == "true":
					self.send(messages.ConfigSet("transfers", "only_buddies", "false"))
				elif self.config["transfers"]["only_buddies"] == "false":
					self.send(messages.ConfigSet("transfers", "only_buddies", "true"))
		
			elif line[:7] == "/unhide":
				if self.unhide == "true":
					self.unhide = "false"
				elif self.unhide == "false":
					self.unhide = "true"
				if self.DisplayMode == "setup":
					self.setup_mode()
			elif line[:10] == "/buddyall":
				self.Hlog("status", "Buddying ALL users currently transferring to or from you.")
				currentusersintransferlist = {}
				for userpath, values in self.transfers["uploads"].items():
					currentusersintransferlist[values[1]] = 0
				for userpath, values in self.transfers["downloads"].items():
					currentusersintransferlist[values[1]] = 0
				for username in currentusersintransferlist.keys():
					if username not in self.config["buddies"].keys():
						self.send(messages.ConfigSet("buddies", username, "Buddied by mucous"))
						
			elif line[:6] == "/nick " and line[6:] != '':
				if self.username != None:
					self.send(messages.ConfigSet("server", "username", line[6:]))
			elif line == "/clearsearchs":
				self.clear_searchs()
			elif line[:8] == "/clearup":
				for userpath, values in self.transfers["uploads"].items():
					if values[3] in (0, 10, 11, 12, 13, 14):
						self.send(messages.TransferRemove(1, values[1], values[2]))
			elif line == "/percent":
				if self.trans_speed_display == True:
					self.trans_speed_display = False
				elif self.trans_speed_display == False:
					self.trans_speed_display = True
				self.transfer_mode()
				
			elif line[:10] == "/cleardown":
				for userpath, values in self.transfers["downloads"].items():
					if values[3] == 0:
						self.send(messages.TransferRemove(0, values[1], values[2]))
						
			elif line[:10] == "/clearroom":
				if line[10:] == '':
					
					self.roomlogs[self.current_room] = []
					if self.DisplayMode == "chat":
						self.chat_mode()
				elif line[10:11] == ' ' and line[11:] != '':
					if line[11:] in self.roomlogs.keys():
						self.roomlogs[line[11:]] = []
						if self.DisplayMode == "chat":
							self.chat_mode()
			elif line == "/aliases":
				self.Hlog("status", "Aliases:")
				for alias in mucous_config["aliases"].keys():
					self.Hlog("status", "/"+alias+": "+str(mucous_config["aliases"][alias]))
					self.Hlog("status", "")
					
			elif line[:7] == "/alias " and line[7:] != '':
				if line[7:].find(" ") != -1:
					splited = line[7:].split(" ")
					if len(splited) > 1:
						alias = splited[0]
						splited = splited[1:]
						if splited[0] != None:
							message = ''
							for i in splited:
								if i != splited[0]:
									message += ' ' +i
								else:
									message += i
							mucous_config["aliases"][alias] = str(message)
							if alias in mucous_config["aliases"].keys():
								self.Hlog("status", "Modified alias: "+alias)
							else:
								self.Hlog("status", "Created alias: "+alias)
							if "/"+alias not in self.commandlist:
								self.commandlist.append("/"+alias)
				else: 
					return 0
				
			elif line[:9] == "/unalias " and line[9:] != '':
				alias = line[9:]
				if alias in mucous_config["aliases"].keys():
					self.Hlog("status", "Deleted alias: "+alias)
					del mucous_config["aliases"][str(alias)]
					if "/"+alias in self.commandlist:
						self.commandlist.remove("/"+alias)
						
			elif line[:1] == "/":
				good = 0
				for alias in mucous_config["aliases"].keys():
					if line == '/'+alias:
						if self.DisplayMode == "chat":
							if self.current_room != None:
								self.say_in_chat("chat", self.current_room, mucous_config["aliases"][alias])
								good = 1
								break
							
						elif self.DisplayMode == "private":
							if self.pm_user != None:
								self.say_in_chat("private", self.pm_user, mucous_config["aliases"][alias])
								good = 1
								break
						
				if good != 1:
					return 0
				
			else:
				return 1
			
			
		elif self.current and line:
			'''
			Special Input Box for Downloading Manually
			'''
			# escape //
			if line[:2] == '//':
				line = line[1:]
			# Manual Download input box
			if self.current[:10] == '% % User: ' and line != '':
				if self.manual_user != None and self.manual_user != '':
					path = line
					self.send(messages.DownloadFile(self.manual_user, path))
					self.Hlog("status", "Trying to Download: " + path+" from "+ self.manual_user)
			# Ticker set input box
			elif self.current[:12] == '% Set ticker' and line != '':
				self.send(messages.RoomTickerSet(self.ticker_room, line))
				
			elif self.current == '% Give Privileges to ' + str(self.privuser) and line != '':
				try:
					days = int(line)
					self.send(messages.GivePrivileges(self.privuser, days))
					self.privuser = None
					if self.DisplayMode == "chat":
						self.set_edit_title(self.current_room)
				except:
					self.Hlog("debug", "Enter the Number of days of privileges you wish to give " + self.privuser)
		
			else:
				if line != '':
					if self.DisplayMode == "chat":
						#Normal Chat Room Message
						if self.current_room:
							self.say_in_chat("chat", self.current_room, line)
					elif self.DisplayMode == "private":
						#Normal Private Messaging
						if self.pm_user != None:
							# Private Message
							self.send_private_message(self.pm_user, line)
						else:
							# Set user to message
							self.pm_user = self.decode_language( line)
							self.set_edit_title("Send message to: " + self.pm_user)
							self.start_pm(self.pm_user)
							
							
					elif self.DisplayMode == "search":
						
						if len(line) > 2 and line != 'mp3':
							# Normal Search
							query = line
							#self.decode_language( )
							if self.search_type == "globally":
								self.send(messages.Search(0, query ))
								
							# Buddies Search
							elif self.search_type == "buddies":
								self.send(messages.Search(1, query ))
							# Rooms Search	
							elif self.search_type == "rooms":	
								self.send(messages.Search(2, query ))
					elif self.DisplayMode == "browse":
						# Browse User's shares
						if line[:3] == "cd ":
							self.user_shares_cd(line[3:])
							return 1

						elif line[:3] == "get" and line[3:] != '':
							linput = None
							if line[:4] == "get " and line[4:] != '':
								dtype = "file"
								linput = line[4:]
							elif line[:7] == "getdir "  and line[7:] != '':
								dtype = "dir"
								linput = line[7:]
							if linput != None:
								if linput.isdigit():
									self.download_path_file(dtype, linput)
								else:
									self.Hlog("status", "Enter an Integer")
								return 1
						
						
						self.start_browse(line)
						
						
					elif self.DisplayMode == "info":
						# Get User's UserInfo and PeerStats
						line = self.decode_language(line)
						self.info_log("Getting information about user: " + line)
						self.info_requested.append(line)
						self.stat_requested = line
						self.send(messages.UserInfo(line))
						self.send(messages.PeerStats(line))
						
					elif self.DisplayMode == "lists":
						if self.display_which_list == "buddies":
							self.mod_config("buddy", line, '')
						elif self.display_which_list == "banned":
							self.mod_config("ban", line, '')
						elif self.display_which_list == "ignored":
							self.mod_config("ignore", line, '')
					elif self.DisplayMode == "rooms":
						self.send(messages.JoinRoom(line.decode(mucous_config["mucous"]["language"])))
					elif self.DisplayMode == "setup":
						self.setup_input_parse(line)
						#.decode(mucous_config["mucous"]["language"])
			try:
				self.edit.reset()
			except:
				pass

	def setup_input_parse(self, line):
			
		if self.setup_input_mode == "interface":
			line = self.decode_language(line)
			mucous_config["connection"]["interface"] = line
		elif self.setup_input_mode=="interface-password":
			line = self.decode_language(line)
			mucous_config["connection"]["passw"] = line
			self.password = line
		elif self.setup_input_mode=="custom-url":
			line = self.decode_language(line)
			if "$" in line:
				custom = line.split("$")
				if len(custom) > 1 and len(custom) < 3:
					mucous_config["mucous"]["url custom prefix"] = custom[0]
					mucous_config["mucous"]["url custom suffix"] = custom[1]
				elif len(custom) == 1:
					mucous_config["mucous"]["url custom prefix"] = custom[0]
					mucous_config["mucous"]["url custom suffix"] = ''
		elif self.setup_input_mode=="museek-interface-password":
			self.send(messages.ConfigSet("interfaces", "password", line))
		elif self.setup_input_mode=="museek-interface-bind":
			self.send(messages.ConfigSet("interfaces.bind", line))
		elif self.setup_input_mode=="server-host":
			self.send(messages.ConfigSet("server", "host", line))
		elif self.setup_input_mode=="server-port":
			self.send(messages.ConfigSet("server", "port", line))
		elif self.setup_input_mode=="soulseek-username":
			line = self.decode_language(line)
			self.send(messages.ConfigSet("server", "username", line))
		elif self.setup_input_mode=="soulseek-password":
			line = self.decode_language(line)
			self.send(messages.ConfigSet("server", "password", line))
		elif self.setup_input_mode=="download-dir":
			self.send(messages.ConfigSet("transfers", "download-dir", line))
		elif self.setup_input_mode=="incomplete-dir":
			self.send(messages.ConfigSet("transfers", "incomplete-dir", line))
		elif self.setup_input_mode=="userinfo":
			try:
				if '\\n' in line:
					line = line.replace('\\n', '\n')
				self.send(messages.ConfigSet("userinfo", "text", line))
			except Exception, e:
				self.Hlog("debug", "set userinfo: "+str( e))
		elif self.setup_input_mode=="userimage":
			try:
				self.send(messages.ConfigSet("userinfo", "image", line))
			except:
				pass
		elif self.setup_input_mode=="adddir":
			line = self.decode_language(line)
			self.muscan_fuzzy = line
			self.muscan_command = ["muscan", "-s", self.muscan_fuzzy]
			self.muscan_timer.cancel()
			self.muscan_timer = threading.Timer(1.0, self.muscan_display)
			self.muscan_timer.start()
			self.Hlog("status", "Adding "+line+" to shares. Scanning will begin.")
		elif self.setup_input_mode=="rmdir":
			line = self.decode_language(line)
			self.muscan_fuzzy = line
			self.muscan_command = ["muscan", "-u", self.muscan_fuzzy]
			self.muscan_timer.cancel()
			self.muscan_timer = threading.Timer(1.0, self.muscan_display)
			self.muscan_timer.start()
			self.Hlog("status", "Removing "+line+" from shares. Please rescan or update.")
		self.setup_input_mode = "default"
		self.setup_mode()
		
	def logging_toggle(self):
		if "logging" in mucous_config["mucous"]:
			if str(mucous_config["mucous"]["logging"]) not in ("True", "False"):
				mucous_config["mucous"]["logging"] = "True"
			else:
				if str(mucous_config["mucous"]["logging"]) == "True":
					mucous_config["mucous"]["logging"] = "False"
				elif str(mucous_config["mucous"]["logging"]) == "False":
					mucous_config["mucous"]["logging"] = "True"
		else:
			if str(mucous_config["mucous"]["logging"]) == "True":
				mucous_config["mucous"]["logging"] = "False"
			elif str(mucous_config["mucous"]["logging"]) == "False":
				mucous_config["mucous"]["logging"] = "True"
				
		if str(mucous_config["mucous"]["logging"]) == "True":
			self.Hlog("status", "Logging Chat is now Enabled.")
		elif str(mucous_config["mucous"]["logging"]) == "False":
			self.Hlog("status", "Logging Chat is now Disabled.")

	# -- v Museek Messages v

	
	def cb_login_error(self, reason):
		self.connected = 0
		if reason == "INVPASS":
			self.invalidpass = 1
			self.Hlog("status", "couldn't log in: Invalid Password")
			self.connect()
		else:
			self.invalidpass = 0
			self.Hlog("status", "couldn't log in: " + reason)

	def cb_login_ok(self):
		self.invalidpass = 0
		self.connected = 1
		self.Hlog("status", "Logging into Museek at "+ mucous_config["connection"]["interface"])
		self.timeout_timer = threading.Timer(self.timeout_time, self.timeout)
		self.timeout_timer.start()
		
		
	def cb_disconnected(self):
		self.connected = 0
		self.onlinestatuslog="Closed  "
		try:
			self.onlinestatus.erase()
			self.onlinestatus.addstr(self.onlinestatuslog, self.colors["red"] |curses.A_BOLD |curses.A_REVERSE)
		except:
			pass
		self.onlinestatus.refresh()
		
		for room in self.rooms.keys():
			msg = ("--- Disconnected from the Museek Daemon ---")
			self.say("Status", room, '!!!!', msg)
		uploadlist = []
		self.up_transfer_numbers = {}
		self.transfers["downloads"] = {}
		self.transfers["uploads"] = {}
		for room in self.rooms.keys():
			self.rooms[room] = []
			
		if self.DisplayMode == "chat":
			self.chat_mode()
		elif self.DisplayMode == "transfer":
			self.transfer_mode()
		self.update_title()
		self.upload_status("0")
		self.download_status("0")
		self.muscan_timer.cancel()
		self.timer.cancel()
		self.ticker_timer.cancel()
		self.retry_timer.cancel()
		self.clear_timer.cancel()
		self.timeout_timer.cancel()
		
	def cb_status_message(self, type, message):
		try:
			if type == 1:
				self.Hlog("status", "Peer Message: %s" % message)
			elif type == 0:
				self.Hlog("status", "Server Message: %s" % message)
		except Exception,e:
			self.Hlog("debug", "cb_server_state: " +str( e) )	
			
	def cb_server_state(self, state, username):
		try:
			self.username = username
			
			self.usernamewin.erase()
			self.usernamewin.addstr(self.decode_language(self.username[:15]), self.colors["blafgcyabg"] )
			self.usernamewin.refresh()
		
			self.upload_status("0")
			self.download_status("0")
			self.search_status(0)
		
			if state:
# 				self.Hlog("status", "Connected to Server, username: " + username)
				
				self.onlinestatuslog="Online"
				
	
				if self.rooms.keys():
					for room in self.rooms.keys():
						msg = ("--- Connected ---")
						self.say("Status", room, '!!!!', msg)
				
			else:
				self.Hlog("status", "Museek is not connected to Soulseek")
	
				self.onlinestatuslog="Offline"
				
				
	
				if self.rooms.keys():
					for room in self.rooms.keys():
						msg = ("--- Disconnected from the Server ---")
						self.say("Status", room, '!!!!', msg)
				uploadlist = []
				self.up_transfer_numbers = {}
				self.transfers["downloads"] = {}
				self.transfers["uploads"] = {}
				for room in self.rooms.keys():
					self.rooms[room] = []
				if self.DisplayMode == "chat":
					self.chat_mode()
				elif self.DisplayMode == "transfer":
					self.transfer_mode()

			self.onlinestatus.erase()
			self.onlinestatus.addstr(self.decode_language(self.onlinestatuslog), self.colors["blafgcyabg"] )
			self.onlinestatus.refresh()
			
		except Exception,e:
			self.Hlog("debug", "cb_server_state: " +str( e) )
		self.update_title()
		
	def toggle_away(self):
		try:
			if self.connected == 1:
				if self.status == 0:
					self.send(messages.SetStatus(1))
				elif self.status == 1:
					self.send(messages.SetStatus(0))
		except Exception,e:
			self.Hlog("debug", "toggle_away: " +str( e) )
			
	def update_title(self):
		# Changes Terminal TItle when Away Status changes
		try:
			if os.path.expandvars("$SHELL") in  ("/bin/bash", "/bin/sh"):
				if str(curses.termname() ) != "linux":
					os.system("echo -ne \"\033]0;Mucous %s: %s\007\" " %(Version, self.onlinestatuslog ))
		except Exception,e:
			self.Hlog("debug", "update_title: " +str( e) )

			
	def cb_server_privileges(self, time_left):
		try: 
			time = time_left
			hours_i = time/3600
			minutes_i = time/60
			seconds_i = time - (60 * minutes_i)
			if minutes_i > 59:
				minutes_i = time/60 - (60 * hours_i)
				
			days = hours_i/24
			hours = hours_i - (days*24)
			time = 'You have %d Days, %2.2d:%2.2d:%2.2d of privileges left' % (days, hours, minutes_i, seconds_i)
				
			self.Hlog("status", time)
		except Exception,e:
			self.Hlog("debug", "cb_server_privileges: " +str( e) )
		
	def cb_room_state(self, roomlist, joined, tickers):
		try:
			for rooms1, numbers in roomlist.items():
				self.all_roomlist[rooms1] = numbers
			
			for room in joined:
	
				if room not in self.roomlogs:
					self.roomlogs[room] = []
					self.statuslogs[room] = []
					self.add_logs_to_chat(room)
						
				
				roomlist = []
	
				alpha_list  = SortedDict()
				
				for users in joined[room]:
					roomlist.append(users)
					self.user_status[users] = joined[room][users][0]
					self.user_stats[users] = joined[room][users][1], joined[room][users][2 ], joined[room][users][3], joined[room][users][4]
					
				self.rooms[room] = joined[room].keys()
					#avgspeed, numdownloads, numfiles, numdirs
	
				# tickers == (rooms, [(user1: message1), (user2: message2),] )
				# a string and then a dictionary
	
				for rooms14, ticks in tickers.items():
					if rooms14 == room:
						self.master_ticklist[room] = ticks
	
				for rooms2, ticks in alpha_list.items():
					if rooms2 == room:
						self.master_ticklist[room] = alpha_list[room]
						
				#SMALL ROOM USER PRINTOUT
	# 			
	# 			if self.chatdisplaymode not in ('big', 'small', "nostatuslog"):
	# 				if len(joined[room]) <= 30:
	# 					self.show_nick_list(room)
	# 				else:
	# 					self.say("List", room, '!!!!', [[str(len(joined[room])), "Normal"]])
	
				if mucous_config["tickers"]["tickers_enabled"] == 'yes':
					if len(joined[room]) <= 30:
						for rooms3, ticks in self.master_ticklist.items():
							if rooms3 == room:
								ttickers =[]
								ttickers = ticks.keys()
								if ttickers != []:
									self.info_log("Tickers in room: "+str(rooms3))
									ttickers.sort()
									for names in ttickers:
										self.info_log(" ["+str(names)+'] '+str(ticks[names]))
									self.info_log("")
	
					
			joined = self.rooms.keys()
			joined.sort()
			if joined != []:
				if mucous_config["rooms"]["default_room"] != None:
					if mucous_config["rooms"]["default_room"] in joined:
						self.current_room = mucous_config["rooms"]["default_room"]
						self.set_room(mucous_config["rooms"]["default_room"])
					else:
						self.send(messages.JoinRoom(mucous_config["rooms"]["default_room"]))
						self.set_room(joined[0])
	
				else:
					self.current_room = joined[0]
					self.set_room(joined[0])
	
# 			for rooms4, tickers in mucous_config["tickers"]["rooms"].items():
# 				if rooms4 in joined:
# 					if self.username not in self.master_ticklist[rooms4].keys():
# 						self.send(messages.RoomTickerSet(rooms4, tickers))
# 					elif self.master_ticklist[rooms4][self.username] != tickers:
# 						self.send(messages.RoomTickerSet(rooms4, tickers))
		except Exception, e:
			self.Hlog("debug", "CB Room state" + str(e))	
		
	def cb_room_list(self, roomlist):
		try:
			for name in  roomlist:
				alpha_list[name] = roomlist[name]
			
			self.all_roomlist = {}
			
			for x, y in alpha_list.items():
				self.all_roomlist[x] = y
				
			if self.DisplayMode=="rooms":
				self.rooms_mode()
		except Exception, e:
			self.Hlog("debug", "CB Room List" + str(e))
			
	def cb_get_global_recommendations(self, recommendations):
		try:
			self.recommendations_list = SortedDict()
			for rec, num in recommendations.items():
				self.recommendations_list [rec] = num
# 			recommends = SortedDict()
# 			for rec, num in recommendations.items():
# 				recommends[rec] = num
# 			for rec, num in recommends.items():
# 				self.Hlog("debug", str(rec)+" "+str(num)) 
		except Exception, e:
			self.Hlog("debug", "CB Get Global Recommendations" + str(e))

	def cb_get_similar_users(self, users):
		try:
			
			self.similar_users = SortedDict()
			for rec, num in users.items():
				self.similar_users[rec] = num
#  			for rec, num in users.items():
#  				self.Hlog("debug", str(rec)+" "+str(num)) 
		except Exception, e:
			self.Hlog("debug", "CB Similar Users" + str(e))
			
	def cb_get_recommendations(self, recommendations):
		try:
			self.recommendations_list = SortedDict()
			for rec, num in recommendations.items():
				self.recommendations_list [rec] = num
# 			self.recommendations_list = recommends
# 			for rec, num in recommends.items():
# 				self.Hlog("debug", str(rec)+" "+str(num)) 
		except Exception, e:
			self.Hlog("debug", "CB Get  Recommendations" + str(e))
			
	def cb_get_item_similar_users(self, item, users):
		try:
			#self.Hlog("debug", str(users)) 
			self.similar_users = SortedDict()
			for rec, num in users.items():
				self.similar_users[rec] = num
			#for users in users.keys():
			#	self.Hlog("debug", str(users)) 
		except Exception, e:
			self.Hlog("debug", "CB Item Similar Users" + str(e))
			
	def cb_get_item_recommendations(self, item, recommendations):
		try:
# 			recommends = SortedDict()
# 			self.Hlog("debug", str(item)+" "+str(recommendations)) 
			self.recommendations_list = SortedDict()
			for rec, num in recommendations.items():
				self.recommendations_list [rec] = num
# 			for rec, num in recommendations.items():
# 				recommends[rec] = num
# 			for rec, num in recommends.keys():
# 				self.Hlog("debug", str(rec)+" "+str(num)) 
		except Exception, e:
			self.Hlog("debug", "CB Get Item Recommendations" + str(e))
			
	def cb_add_hated_interest(self, interest):
		self.Hlog("debug", str(interest)) 
		
	def beep(self):
		if mucous_config["mucous"]["beep"] == "True":
			if os.path.expandvars("$SHELL") in  ("/bin/bash", "/bin/sh"):
				os.system("echo -ne \"\a\" " )
				
	def cb_room_said(self, room, user, text):
		try:
			#text = text.replace('\n', " ").replace('\t', "     ")
			text = text.replace('\t', "     ")
			
			
	
			if text[:4] == "/me ":
				self.say("Me", room, user, text[4:])
				if self.username in text[4:]:
					if self.DisplayMode != "chat":
						self.alert_status(room)
						
						self.alert["CHAT"][room] = "nick"
						self.beep()
					elif self.DisplayMode == "chat" and self.current_room != room:
						self.alert_status(room[:14])
						self.alert["CHAT"][room] = "nick"
						self.beep()
					
				else:
					if self.DisplayMode != "chat":
						self.alert_status("%s" % room)
						if room not in self.alert["CHAT"]:
							self.alert["CHAT"][room] = "normal"
					elif self.DisplayMode == "chat" and self.current_room != room:
						self.alert_status(room)
						if room not in self.alert["CHAT"]:
							self.alert["CHAT"][room] = "normal"
			else:
				if self.username in text:
					self.say("Mentioned", room, user, text)
					if self.DisplayMode != "chat":
						self.alert_status(room)
						self.beep()
						self.alert["CHAT"][room] = "nick"
					elif self.DisplayMode == "chat" and self.current_room != room:
						self.alert_status(room)
						self.beep()
						self.alert["CHAT"][room] = "nick"
	
				else:
					self.say("Normal", room, user, text)
					if self.DisplayMode != "chat":
						self.alert_status( room)
						if room not in self.alert["CHAT"]:
							self.alert["CHAT"][room] = "normal"
	
					elif self.DisplayMode == "chat" and self.current_room != room:
						self.alert_status(room)
						if room not in self.alert["CHAT"]:
							self.alert["CHAT"][room] = "normal"
			self.hotkeys()
						
			if mucous_config["mucous"]["logging"] in (True, "True"):
				message = "[%s]\t%s" % (user, text)
				self.log_to_file("rooms", time.strftime("%d %b %Y %H:%M:%S"), room, message )
		except Exception, e:
			self.Hlog("debug", "CB Room Said" + str(e))
			
	
	def cb_room_joined(self, room, list_of_users):
		try:
			self.master_ticklist[room] = {}
			if room not in self.roomlogs:
				self.roomlogs[room] = []
				self.statuslogs[room] = []
				
			for users, stats in list_of_users.items():
				self.user_stats[users] = stats[1], stats[2 ], stats[3], stats[4] #avgspeed, numdownloads, numfiles, numdirs
				self.user_status[users] = stats[0] # online status
			
			self.rooms[room] = list_of_users.keys()
			
			curses.doupdate()
		except Exception, e:
			self.Hlog("debug", "CB Room Joined: " + str(e))
	
	def cb_room_left(self, room):
		try:
			joined = self.rooms.keys()
			joined.sort()
			del self.rooms[room]
			if room == self.current_room:
				if len(joined) == 1:
					self.set_room(None)
				else:
					ix = joined.index(room)
					if ix > 0:
						ix -= 1
					elif ix == 0:
						ix = -1
					self.set_room(joined[ix])
					self.say("Status", joined[ix], '!!!!', "Left room %s" % room)
			joined.remove(room)
			
			if joined == []:
				self.set_room(None)
				self.drawchatwindow()
				self.textwin.refresh()
			else:
				joined.sort()
			if room in self.alert["CHAT"]:
				del self.alert["CHAT"][room]
			curses.doupdate()	
		except Exception, e:
			self.Hlog("debug", "CB Room Left" + str(e))
			
		if self.alertwinlog == "%s" % room[:14]:
			self.alert_status("")
	
	def cb_room_user_joined(self, room, user, data):
		try:
			status, speed, downloads, files, dirs, other = data 
			s = self.window_dimensions["chat"]
			did = "join"
			what = data
			if self.config !=  {}: 
				if "ignored" in self.config.keys(): 
					if user not in self.config["ignored"].keys():
						self.log_window(user, room, did, what)
			if user not in self.rooms[room]:
				self.rooms[room].append(user)
			self.user_stats[user] = speed, downloads, files, dirs
			self.user_status[user] = status
			# correct placement in roombox
			if self.DisplayMode == "chat":
				if self.current_room == room:
					if self.chatroomscroll  == "roombox":
						self.rooms[room].sort()
						if self.rooms[room].index(user) < self.Sup:
							self.Sup += 1

					self.roomstatusbox()
					for lines in self.roomlogs[self.current_room][len(self.roomlogs[self.current_room])-s["height"]:]:
						if lines[2] == user:
							self.set_room(self.current_room)
							break
					curses.doupdate()
		except Exception, e:
			self.Hlog("debug", "CB Room User Joined" + str(e))

	
	def cb_room_user_left(self, room, user):
		try:
			did = "left"
			what = None
			if self.config !=  {}: 
				if "ignored" in self.config.keys(): 
					if user not in self.config["ignored"].keys():
						self.log_window(user, room, did, what)
			# correct placement in roombox
			if  self.DisplayMode == "chat" and self.chatroomscroll  == "roombox":
				self.rooms[room].sort()
				if self.rooms[room].index(user) < self.Sup:
					self.Sup -= 1
			if user in self.rooms[room]:
				self.rooms[room].remove(user)
			if room in self.master_ticklist:
				if user in self.master_ticklist[room]:
					del self.master_ticklist[room][user]
			if self.DisplayMode == "chat" and self.current_room == room:
				self.roomstatusbox()
				for lines in self.roomlogs[room][len(self.roomlogs[self.current_room])-self.window_dimensions["chat"]["height"]:]:
					if lines[2] == user:
						self.set_room(room)
						break
				curses.doupdate()
		except Exception, e:
			self.Hlog("debug", "CB Room User Left" + str(e))
	
	def cb_peer_status(self, user, status):
		try:
			if status == 1: what = "away"
			elif status == 2: what = "online"
			elif status == 0: what = "offline"
			
			if user in self.user_status:
				if self.user_status[user] == status:
					return
				else: 
					self.user_status[user] = status
			else:
				self.user_status[user] = status

			room = None
			did = "change"
			if self.config !=  {}: 
				if "ignored" in self.config.keys(): 
					if user not in self.config["ignored"].keys():
						self.log_window(user, room, did, what)
						
			if self.DisplayMode == "chat" and user in self.rooms[self.current_room]:
				self.roomstatusbox()
				curses.doupdate()
			elif self.DisplayMode in ("private", "info", "browse", "lists"):
				self.reload_mode(user)
		except Exception, e:
			self.Hlog("debug", "CB Peer Status" + str(e))
			
	def reload_mode(self, user):
		if self.DisplayMode == "private":
			if user in self.privatelog.keys():
				self.private_mode()
		elif self.DisplayMode == "chat":
			if user in self.rooms[self.current_room]:
				self.chat_mode()
		elif self.DisplayMode == "info":
			if user in self.info_users:
				self.info_mode()
		elif self.DisplayMode == "lists":
			if self.display_which_list in self.config.keys():
				if user in self.config[self.display_which_list].keys():
					self.list_mode()
		elif self.DisplayMode == "browse":
			if user in self.browsed:
				self.browse_mode()
		elif self.DisplayMode == "search":
			if user in self.s_query.keys():
				self.search_mode()
		elif self.DisplayMode == "transfers":
			self.transfer_mode()
		elif self.DisplayMode == "rooms":
			self.rooms_mode()
		elif self.DisplayMode == "setup":
			self.setup_mode()
		elif self.DisplayMode in ("help", "debug", "status"):
			self.help_mode()
			
	def cb_user_info(self, user, info, picture, uploads, queue, slotsfree):
		try:
			if user in self.info_requested:
				self.info_requested.remove(user)
				self.info_user = user
				message = info.split('\n')
				self.userinfo_log(user, message, [queue, uploads, slotsfree])
				if picture != '':
					r = file(config_dir+str(user)+".image", 'w')
					print >> r, str(picture)
					r.close()
					self.info_log( "Saved UserImage as: "+ str(user)+".image")
				if self.DisplayMode != "info":
					self.alert_status("New Userinfo")
					self.alert["INFO"].append(user)
					self.hotkeys()
		except Exception, e:
			self.Hlog( "debug", "cb_user_info: " + str(e))
				
	def cb_peer_address(self, user, ip, port):
		try:
			if user == self.ip_requested:
				self.ip_requested = None
				
				if geoip_fail==0:
					try:
						country =  gi.country_name_by_addr( str(ip) )
						self.info_log("%s's IP: %s Port: %s Country: %s"  % (user, str(ip), str(port), country) )
					except Exception, e:
						self.Hlog("debug", "CB Peer Address: " + str(e))
				else:
					self.info_log("%s's IP: %s Port: %s"  % (user, str(ip), str(port)) )
				if self.DisplayMode != "info":
					self.alert_status("New IP")
		except Exception, e:
			self.Hlog( "debug", "cb_peer_address: " + str(e))
			
	def cb_peer_stats(self, user, avgspeed, numdownloads, numfiles, numdirs):
		try:
			self.user_stats[user] = avgspeed, numdownloads, numfiles, numdirs
			if user == self.stat_requested:
	
				self.info_log("Peer Stats for: %s" % user)
				self.info_log("Speed: %s" % avgspeed)
				self.info_log("Downloads: %s" % numdownloads)
				self.info_log("Files: %s" % numfiles)
				self.info_log("Directories: %s" % numdirs)
				
				self.stat_requested = None
				if self.DisplayMode != "info":
					self.alert_status("New Stats")
				else:
					self.display_userinfo_log()
			if user == self.username:
				self.stats = user,  avgspeed, numdownloads, numfiles, numdirs
				if self.DisplayMode == "setup":
					self.setup_mode()
		except Exception, e:
			self.Hlog( "debug", "cb_peer_stats: " + str(e))

	def cb_private_message(self, direction, timestamp, user, message):
		try:
			ctcpversion = 0
			if message == curses.ascii.ctrl("A")+"VERSION"+curses.ascii.ctrl("A"):
				message = "CTCP VERSION"
				ctcpversion = 1
			
			if user not in self.privatelog.keys():
				self.privatelog[user] = []
				if mucous_config["mucous"]["logging"] in (True, "True"):
					self.add_logs_to_private(user)
				
			if self.DisplayMode == 'private':
				self.private_mode()
				
			if mucous_config["mucous"]["logging"] in (True, "True"):
				if direction == 0:
					self.log_to_file("private", time.strftime("%d %b %Y %H:%M:%S"), user, "["+user+"]\t"+ message )
				elif direction == 1:
					self.log_to_file("private", time.strftime("%d %b %Y %H:%M:%S"), user, "["+self.username+"]\t"+ message )
			if self.pm_user == None:
				self.pm_user = user

			if direction == 0:	
				pmtype = "incoming"
			elif direction == 1:
				pmtype = "outgoing"
			
			self.private_log(pmtype, user, message)

			if self.DisplayMode != "private":
				self.alert_status("New PM")
				if user not in self.alert["PRIVATE"]:
					self.alert["PRIVATE"].append(user)
					self.hotkeys()
				self.beep()
				
			elif self.DisplayMode == "private" and self.pm_user != user:
				if user not in self.alert["PRIVATE"]:
					self.alert["PRIVATE"].append(user)
					self.hotkeys()
				self.beep()
				
			if ctcpversion == 1 and direction == 0:
				if mucous_config["mucous"]["extra_requests"] == "Yes":
					self.send_private_message(user, "Mucous %s" % Version)
				
		except Exception, e:
			self.Hlog( "debug", "cb_private_message: " + str(e))
				
		
	def cb_server_status_set(self, status):
		try:
			self.status = status
			if status:
				stat = "Away"
			else:
				stat = "Online"
			
			self.onlinestatuslog=stat
			
			try:
				self.onlinestatus.erase()
				self.onlinestatus.addstr(self.decode_language(self.onlinestatuslog), self.colors["blafgcyabg"] )
				
			except:
				pass
			self.onlinestatus.refresh()
			self.update_title()
		except Exception, e:
			self.Hlog( "debug", "cb_server_status_set: " + str(e))
			
	def cb_room_tickers(self, room, tickers):
		try:
			for user, message in tickers.items():
				self.master_ticklist[room][user] = message
		except Exception, e:
			self.Hlog( "debug", "cb_room_tickers: " + str(e))
		
	def cb_room_ticker_set(self, room, user, message):
		try:
			what = message
			did = "ticker"
			if self.config !=  {}: 
				if "ignored" in self.config.keys(): 
					if user not in self.config["ignored"].keys():
						self.log_window(user, room, did, what)
			if room in self.master_ticklist.keys():
				
				self.master_ticklist[room][user] = message
					
		except Exception, e:
			self.Hlog( "debug", "cb_room_ticker_set: " + str(e))
			
	def cb_search_ticket(self, query, ticket):
		try:
			self.s_query[str(ticket)] = query
			self.chosen_search=str(ticket)
			self.begin_search(self.chosen_search, query)
		except Exception, e:
			self.Hlog( "debug", "cb_search_ticket: " + str(e))
		
	def cb_search_results(self, ticket, user, free, speed, queue, results):
		# search results
		try:
			if self.search_visible == 1:
				self.search_log("sstatus","Search: " +str(self.s_query[str(ticket)]) + " Results from: User: "+ user, str(ticket), 0 )
	
			for result in results:
				result_list = []
				# Create Result List for future use 
				# clear it next interation
				# Count Search Result
				self.search_number += 1
				# Send Num of Results to Search Window
				self.search_status(self.search_number)
	
				ftype = result[2]
				if ftype in ('', None):
					if result[0][-4:-3] == ".":
						ftype = result[0][-3:]
				ftype = ftype.upper()
				result_list = str(ticket), user, free, speed, queue, result[0], result[1], ftype, result[3]
				self.search_results[self.search_number] = result_list
				
			if self.DisplayMode != "search" or self.chosen_search != str(ticket):
				if str(ticket) not in self.alert["SEARCH"]:
					self.alert["SEARCH"].append( str(ticket) )
					self.check_alert_state()
				
			if self.chosen_search!= "default__" and  self.showmenu != True:
					self.Format_Search_Results(str(ticket))
		except Exception, e:
			pass


	def cb_user_shares(self, user, shares):
		self.get_shares_timer.cancel()
		self.get_shares_timer = threading.Timer(0.5, self.get_shares, (user, shares) )
		self.get_shares_timer.start()
		
	def browse_file_stats(self, user, dirs):
		if self.DisplayMode != "browse":
			self.alert["BROWSE"].append(user)
			self.alert_status("Browse: %s" % user)
			return
		try:
			w = self.window_dimensions["browse"]
			self.browse_number[user] = 0
			self.browse_results = {}
			browse_list = []
			count =0 
			# file, stats[ size, ftype, [bitrate, length ] ]
			if dirs not in self.usershares[user]:
				self.textwin.erase()
				self.textwin.addstr("Empty..")
				self.textwin.refresh()
				self.files =  []
				return
			if self.usershares[user][dirs] == {}:
				self.textwin.erase()
				self.textwin.addstr("Empty..")
				self.textwin.refresh()
				self.files =  []
				return
			length_list = len(str(len(self.usershares[user][dirs].keys() ) ) )
			for file, stats in self.usershares[user][dirs].items():
				count += 1
				
				self.browse_number[user] = self.browse_number[user] +1
				size  = self.byte_format(stats[0])
				if len(size) < 6:
					size = ' '* (6-len(size)) + size
				ftype =stats[1]
				
				if ftype in ('OGG', 'MP3', 'ogg', 'mp3') and stats[2] != []:
					bitrate =str(stats[2][0])
					if bitrate == '':
						bitrate = '0'	
					length =str(stats[2][1])
					if length != '' and length != None:
						minutes = int(length)/60
						seconds = str( int(length) - (60 * minutes))
						if len(seconds) < 2:
							seconds = '0' + seconds
						length = str(minutes)+":"+str(seconds)
					else:
						length = "0:00"
						bitrate = '0'
				else:
					ftype = "None"
					length = "0:00"
					bitrate = '0'
					
				filename = dirs + "\\" + file
				#result_list = user, filename
				# Activate Number for Result
				if len(str(count)) < length_list:
					s = " " * (length_list - len(str(count)))
				else:
					s = ''
				line = "%s%s|%s| %s" % ( s, str(count), size, file )
				browse_list.append(line)
				
			self.files = self.usershares[user][dirs].keys()
				
			if self.bfilter != None:
				a = []
				for path in browse_list:
					if re.match( self.bfilter, path):
						a.append(path)
				browse_list = a
				del a
					
			if self.browse_scroll == "directories":
				clipped_list, sup, self.window_dimensions["browse"]["start"] = self.scrollbox(browse_list, 0, w["height"])
			else:
				clipped_list, self.Sup, self.window_dimensions["browse"]["start"] = self.scrollbox(browse_list, self.Sup, w["height"])
				sup = self.Sup
				
			

			count = 0
			self.textwin.erase()
			for line in clipped_list:
				self.display_browse_text(line, count, sup)
				count += 1
			self.textwin.refresh()
			
		except Exception, e:
			self.Hlog("debug", "browse_file_stats: " + str(e))
			
	
	
	def browse_file_bar(self):
		try:
			self.browse_bar.erase()
			if self.browse_scroll == "files":
				num = self.Sup
				if self.browse_current_dir not in self.usershares[self.browse_current]:
					self.browse_bar.refresh()
					return
					
				if self.usershares[self.browse_current][self.browse_current_dir].keys() != []:
					file, stats = self.usershares[self.browse_current][self.browse_current_dir].items()[num]
				else: 
					self.browse_bar.refresh()
					return
			else:
				num = 0
				if self.browse_current_dir not in self.usershares[self.browse_current]:
					self.browse_bar.refresh()
					return
				if self.usershares[self.browse_current][self.browse_current_dir].keys() != []:
					file, stats = self.usershares[self.browse_current][self.browse_current_dir].items()[num]
				else: 
					self.browse_bar.refresh()
					return
				#self.Hlog("debug", str( self.usershares[self.browse_current][self.browse_current_dir].keys()[num] ))

			size  = self.byte_format(stats[0])
			
			ftype =stats[1]
			if ftype == '':
				ftype = "None"
				length = "0:00"
				bitrate = '0'
			else:
				bitrate =str(stats[2][0])
				if bitrate == '':
					bitrate = '0'	
				length =str(stats[2][1])
				if length != '' and length != None:
					minutes = int(length)/60
					seconds = str( int(length) - (60 * minutes))
					if len(seconds) < 2:
						seconds = '0' + seconds
					length = str(minutes)+":"+str(seconds)
				else:
					length = "0:00"
			
			#self.browse_file_bar('['+str(self.browse_number[user])+'] '+" Size: " + str(size)+" Length: " + length + " Bitrate: " + bitrate)
			line ='['+str(num+1)+'] '+" Size: " + str(size)+" Length: " + length + " Bitrate: " + bitrate
			self.browse_bar.addstr(line)
			self.browse_bar.refresh()
		except Exception, e:
			self.Hlog("debug", "browse_file_bar: " + str(e)+":"+str(self.Sup))
			
	def get_shares(self, user, shares):
		try:
			if user in self.browse_requested and shares != {}:
				
				if user not in self.browsed:
					self.browsed.append(user)
				self.browse_requested.remove(user)
				self.browse_current = user
				if self.DisplayMode != "browse":
					self.alert["BROWSE"].append(self.browse_current)
					self.check_alert_state()

				#self.browse_log("Browsing files: " + user, user)
				self.browse_list_results[user] = {}
				self.browse_number[user] = 0
				self.browse_list_results[user]["dirs"] = []
				# Debugging
				#self.Hlog("debug", shares.keys())
				#########
				sdirs = shares.keys()
				sdirs.sort()
				
				if sdirs != []:
					for item in sdirs:
						s = item.split("\\")
						path = ''
	
						parent = s[0]
						for seq in s[1:]:

							parent += "\\"
	
							path = parent+seq

			
							if path not in self.browse_list_results[user]["dirs"]:
								self.browse_list_results[user]["dirs"].append(path)
							parent =  path
									
				self.browse_list_results[user]["dirs"].sort()
								
				self.browse_current_dir=self.browse_list_results[user]["dirs"][0]
				
				self.usershares[user] = shares
				
				for dirs, files in shares.items():
					self.browse_list_results[user][dirs] = files
					#result_list = []
					
				if self.DisplayMode == "browse":
					self.set_edit_title("Browse "+user+"'s files in " + self.browse_current_dir + " ")
					self.browse_mode()
					
		except Exception, e:
			self.Hlog("debug", "CB User Shares: " + str(e))
			
	def cb_transfer_state(self, downloads, uploads):
		
		for transfer in uploads:

			self.transfers["uploads"][(transfer.user, transfer.path)] =  [transfer.is_upload, transfer.user, transfer.path, int(transfer.state), transfer.error, transfer.filepos, transfer.filesize, transfer.rate, transfer.place]
		self.upload_status(str(len(self.transfers["uploads"].keys())))
		
		for transfer in downloads:
			self.transfers["downloads"][(transfer.user, transfer.path)] =  [transfer.is_upload, transfer.user, transfer.path, int(transfer.state), transfer.error, transfer.filepos, transfer.filesize, transfer.rate, transfer.place]

		self.download_status(str(len(self.transfers["downloads"].keys())))		
		if self.DisplayMode == "transfer":
			if mucous_config["mucous"]["transbox"] == "split":
				self.upload_manager()
				self.download_manager()
				curses.doupdate()
			else:
				if self.transferscroll == "upload":
					self.upload_manager()
					curses.doupdate()
				else:
					self.download_manager()
					curses.doupdate()
		if mucous_config["mucous"]["Auto-Retry"] == "True":
			self.retry_timer.cancel()
			self.retry_timer = threading.Timer(30.0, self.retry_display)
			self.retry_timer.start()
		if mucous_config["mucous"]["Auto-Clear"] == "True":
			self.clear_timer.cancel()
			self.clear_timer = threading.Timer(30.0, self.clear_display)
			self.clear_timer.start()
		
		
		
 	def cb_transfer_update(self, transfer):
		if transfer.is_upload:
			
			self.transfers["uploads"][(transfer.user, transfer.path)] =   [transfer.is_upload, transfer.user, transfer.path, int(transfer.state), transfer.error, transfer.filepos, transfer.filesize, transfer.rate, transfer.place]
			if self.DisplayMode == "transfer":
				if mucous_config["mucous"]["transbox"] == "split":
					self.upload_manager()
					curses.doupdate()
				else:
					if self.transferscroll == "upload":
						self.upload_manager()
						curses.doupdate()
			self.upload_status(str(len(self.transfers["uploads"].keys())))
		else:
	
			self.transfers["downloads"][(transfer.user, transfer.path)] =  [transfer.is_upload, transfer.user, transfer.path, int(transfer.state), transfer.error, transfer.filepos, transfer.filesize, transfer.rate, transfer.place]
			if self.DisplayMode == "transfer":
				if mucous_config["mucous"]["transbox"] == "split":
					self.download_manager()
					curses.doupdate()
				else:
					if self.transferscroll == "upload":
						pass
					else:
						self.download_manager()
						curses.doupdate()
			self.download_status(str(len(self.transfers["downloads"].keys())))
		if self.DisplayMode == "transfer":
			if self.showmenu == True:
				self.create_menu(self.currentmenu, self.menunumber)
		
		
	def cb_transfer_remove(self, transfer):
		
		user_path = transfer[1], transfer[2]
		if transfer[0]:
			del self.transfers["uploads"][user_path]
			if self.DisplayMode == "transfer":
				if mucous_config["mucous"]["transbox"] == "split":
					self.upload_manager()
					curses.doupdate()
				else:
					if self.transferscroll == "upload":
						self.upload_manager()
						curses.doupdate()
			self.upload_status(str(len(self.transfers["uploads"].keys())))
					
		else:
			del self.transfers["downloads"][user_path]
			if self.DisplayMode == "transfer":
				if mucous_config["mucous"]["transbox"] == "split":
					self.download_manager()
					curses.doupdate()
				else:
					if self.transferscroll == "upload":
						pass
					else:
						self.download_manager()
						curses.doupdate()
			self.download_status(str(len(self.transfers["downloads"].keys())))

	def cb_config_set(self, domain, key, value):
		if key in self.config[domain].keys():
			self.Hlog("status", "Modified <"+key+"> in <" +domain+"> to <"+value + ">")
			self.config[domain][key] = value
		else:
			if value == '' and domain is not "userinfo":
				self.Hlog("status", "Added <"+key+"> to <" +domain+">")
			else:
				self.Hlog("status", "Added <"+key+"> to <" +domain+"> and set to <"+value+">")
			self.config[domain][key] = value
		self.display_config_update(domain)
		
	#Delete keys from self.config
	def cb_config_remove(self, domain, key):

		if key in self.config[domain].keys():
			self.Hlog("status", "Removed <"+key+"> from <" +domain+">")
			del self.config[domain][key]
		self.display_config_update(domain)
	
	#Copy config to self.config at connection
	def cb_config_state(self, config):
		self.config = config.copy()
		self.Hlog("status", "Server is at: "+self.config["server"]["host"]+":"+self.config["server"]["port"])
		self.buddylist()
		self.banlist()
		self.ignorelist()
		
	# -- ^ Museek Messages ^
	
	def display_room_list(self):
		
		mucous_config["mucous"]["rooms_sort"] ="alpha"
		
		if self.size == None:
			if len(self.all_roomlist) > 100:
				self.size = 50
			else:
				self.size = 1
		
		collapsed_roomlist = {}
		if mucous_config["mucous"]["rooms_sort"] == "alpha":
			for x, y in self.all_roomlist.items():
				if y >= self.size:
					collapsed_roomlist[x] = y
				try:
					self.textwin.addstr(self.decode_language(x))
					self.textwin.refresh()
				except:
					pass
			roomstring = []
			for x, y in collapsed_roomlist.items():
				roomstring.append(x + ' ['+str(y)+'],')
				
		self.info_log("Rooms: " +(string.join(map(str, roomstring))[:-1]))
		self.info_log("Rooms with at least %s user(s): %s" % (self.size, len(collapsed_roomlist.keys() ) ))
		self.info_log("Total Number of rooms: %s" % len(self.all_roomlist.keys()))
		self.requested_room_refresh = False

	def say_in_chat(self, mode, place, message):
		message = self.dencode_language(message)
		#message = self.encode_language(message)
		if place != None:
			if '\\n' in message:
				
				splited =  message.split('\\n')
				
				if len(splited) > 7:
					
					for i in range(8):
						if self.DisplayMode == "chat":
							
							self.send(messages.SayRoom(place, splited[i]))
						elif self.DisplayMode == "private":
							self.send(messages.PrivateMessage(1, place, splited[i]))
						
				else:
					for i in range(len(splited)):
						if self.DisplayMode == "chat":
							self.send(messages.SayRoom(place, splited[i]))
						elif self.DisplayMode == "private":
							self.send(messages.PrivateMessage(1, place, splited[i]))
				

			elif '\n' in message:
				splited =  message.split('\n')
				
				if len(splited) > 5:
					for i in range(5):
						if self.DisplayMode == "chat":
							self.send(messages.SayRoom(place, splited[i]))
						elif self.DisplayMode == "private":
							self.send(messages.PrivateMessage(1, place, splited[i]))
				else:
					for i in range(len(splited)):
						if self.DisplayMode == "chat":
							self.send(messages.SayRoom(place, splited[i]))
						elif self.DisplayMode == "private":
							self.send(messages.PrivateMessage(1, place, splited[i]))
			else:
				
				if self.DisplayMode == "chat":
					self.send(messages.SayRoom(place, message))
				elif self.DisplayMode == "private":
					self.send(messages.PrivateMessage(1, place, message))
		
	def display_userinfo_log(self):
		try:
			self.infostatswin.erase()
			if self.info_user != None and self.DisplayMode=="info":
				userinfo = self.userinfolog[self.info_user]
				self.infostatswin.addstr('Queue: '+str(userinfo[1][0]))
				self.infostatswin.addstr('\nUploads: '+str(userinfo[1][1]))
				self.infostatswin.addstr('\nSlots: '+str(userinfo[1][2]))

				if self.info_user in self.user_stats.keys():
					try:
						self.infostatswin.addstr('\nSpeed: '+str(self.user_stats[self.info_user][0]))
						self.infostatswin.addstr('\nDown: '+str(self.user_stats[self.info_user][1]))
						self.infostatswin.addstr('\nFiles: '+str(self.user_stats[self.info_user][2]))
						self.infostatswin.addstr('\nDirs: '+str(self.user_stats[self.info_user][3]))
					except:
						pass
			self.infostatswin.noutrefresh()
		except Exception, e:
			self.Hlog("debug", "display_userinfo_log: " + str(e))
				
	def userinfo_log(self, user, message, stats):
		if self.info_user == None:
			self.info_user = user
		if user not in self.userinfolog:
			self.userinfolog[user] = []
		if user not in self.info_users:
			self.info_users.append(user)
		self.userinfolog[user] = message, stats
		if user not in self.user_stats.keys():
			self.send(messages.PeerStats(user))
		if self.DisplayMode == 'info':
			self.info_mode()
			
	
				
	def send_private_message(self, user, message):
		try:
			#Username is already utf-8ified
			lang = mucous_config["mucous"]["language"]
			if '\\n' in message:
				
				splited =  message.split('\\n')
				if len(splited) > 7:
					for i in range(8):
						self.send(messages.PrivateMessage(1, user, splited[i]))
				else:
					for i in range(len(splited)):
						self.send(messages.PrivateMessage(1, user, splited[i]))
				

			elif '\n' in message:
				splited =  message.split('\n')
				
				if len(splited) > 5:
					for i in range(5):
						self.send(messages.PrivateMessage(1, user, splited[i]))
				else:
					for i in range(len(splited)):
						self.send(messages.PrivateMessage(1, user, splited[i]))
			else:
				self.send(messages.PrivateMessage(1, user, self.decode_language(message) ) )
		
		 	if message == curses.ascii.ctrl("A")+"VERSION"+curses.ascii.ctrl("A"):
				message = "CTCP VERSION"
			if mucous_config["mucous"]["logging"] in (True, "True"):
				self.log_to_file("private", time.strftime("%d %b %Y %H:%M:%S"), user, "["+self.username+"]\t" +message )
			pmtype = "outgoing"
			self.private_log(pmtype, user, self.decode_language(message))
			
			if self.alertwinlog == "New PM":
				self.alert_status("")
		except Exception ,e:
			self.Hlog("debug", "Send PM: " + str(e))
	

				
	def begin_search(self, ticket, query):
		if self.DisplayMode == "search":
			self.search_mode()
			if query not in self.searchlog:
				self.searchlog[str(ticket)] = []
			
			self.search_log("sstatus", "Started search for: %s" % query, str(ticket), 0)
		
	def Format_Search_Results(self, this_ticket):
		if self.DisplayMode == "search":
			try:
				sorting_list = {}
				
				for numbers, results in self.search_results.items():
					ticket, user, free, speed, queue, path, size, ftype, extended = results
					if this_ticket == ticket and  self.chosen_search == ticket and self.DisplayMode == "search":
						if ftype in ('MP3', 'OGG', 'mp3', 'ogg'):
							if extended != []:
								bitrate = extended[0]
								time = extended[1]
							else:
								bitrate = 0
								time = 0
						else: 
							bitrate = 0
							time = 0
	
						if time in ('', None):
							time = 0
						
							
						if self.search_format == "num":
							sorting_list[numbers] = 0
						elif self.search_format == "user":
							sorting_list[numbers] = user
						elif self.search_format == "free":
							sorting_list[numbers] =  free
						elif self.search_format == "speed":
							sorting_list[numbers] =  speed
						elif self.search_format == "que":
							sorting_list[numbers] =  queue
						elif self.search_format == "path":
							sorting_list[numbers] =  path
						elif self.search_format == "size":
							sorting_list[numbers] =  size
						elif self.search_format == "file":
							sorting_list[numbers] =  ftype
						elif self.search_format == "bitrate":
							sorting_list[numbers] = bitrate
						elif self.search_format == "time":
							sorting_list[numbers] = time
							
				
				#for n in sorting_list:
				slist = self.sortbyvalue (sorting_list)
				# Filter search while browsing
				if self.sfilter != None:
					s = []
					searchfilter = re.compile('.*' +str(self.sfilter) + '.*', re.DOTALL | re.I)
					for x,y  in slist:
						z =self.search_results[x]
						for c in (z[1], z[5]) :
							if re.match(searchfilter, c): s.append(x); break
					
					self.sorted_search = s
				else:
					s = []
					for x,y  in slist:
						s.append(x)
					self.sorted_search = s
				if self.search_reverse == True:
					self.sorted_search.reverse()
				self.searchlog[str(this_ticket)] = []
				
				clipped_list, self.Sup, self.window_dimensions["search"]["start"] = self.scrollbox(self.sorted_search, self.Sup, self.window_dimensions["search"]["height"])
				self.textwin.erase()
				count = 0
				self.searchlist_displayed = clipped_list
				for number in clipped_list:
					#self.format_this_search(n)
					self.search_log("result1", number, str( self.search_results[number][0] ), count )
					count += 1
				self.textwin.noutrefresh()
			except Exception, e:
				self.Hlog("debug", "FSR: " + str(e))
	
	def byte_format(self, filesize):
		filesize =  int(filesize)
		if filesize >= 1073741824:
			filefrmt = str(filesize/1024/1024/1024) +"GB"
		elif filesize >= 1048576 and filesize <= 1073741824:
			filefrmt = str(filesize/1024/1024) +"MB"
		elif filesize < 1048576 and filesize >= 1024:
			filefrmt = str(filesize/1024) +"KB"
		elif filesize < 1024 and filesize > 0:
			filefrmt = str(filesize) +" B"	
		elif filesize == 0:
			filefrmt = '0'
		return filefrmt
		
	def path_split(self, path):
		r = path.split('\\')
		directory = ''
		for s in r:
			if s is not r[-1]:
				directory += s+'\\'
			if s is r[-1]:
				file = s
		return directory, file
	
	def search_log(self, typer, result, ticket, count):
		if str(ticket) in self.searchlog:
			try:
				if typer == "sstatus":
					#self.searchlog[str(ticket)].append("%s" % result)
					#self.display_search_result(typer, -1, ticket)
					#if self.chosen_search==str(ticket) and 
					if self.DisplayMode == "search":
						#self.Hlog("debug", result)
						self.statswin.erase()
						self.statswin.addstr(self.decode_language(result), self.colors["cyan"])
						self.statswin.noutrefresh()
				elif typer == "result1":
					number = result
					ticket, user, free, speed, queue, path, size, ftype, extended = self.search_results[number]
					size  = self.byte_format(size)

					if ftype in ('MP3', 'OGG', "mp3", "ogg"):
						if extended != []:
							bitrate = extended[0]
							length = int(extended[1])
							minutes = length/60
							seconds = str(length - (60 * minutes))
							
							if len(seconds) < 2:
								seconds = '0' + seconds
						else:
							bitrate = '0'
							minutes = '0'
							seconds = '00'
							length = 0
					else:
						bitrate = '0'
						minutes = '0'
						seconds = '00'
						length = 0
					if free:
						free = 'Y'
					else:
						free = 'N'
			
					
					if self.chosen_search==str(ticket) and self.DisplayMode == "search":
						#result = -1
						if count + self.window_dimensions["search"]["start"]== self.Sup:
							attr =  curses.A_REVERSE | curses.A_BOLD
							attrc = self.colors["cybg"]| curses.A_BOLD
							self.statswin.erase()

							self.statswin.addstr("F: ")
							atr = self.colors["cyan"] | curses.A_BOLD
							self.statswin.addstr(free, atr )
							self.statswin.addstr(" | Q:")
							self.statswin.addstr(str(queue), atr )
							self.statswin.addstr(" | ")
							self.statswin.addstr(user[:15], atr )
							self.statswin.addstr(" | ")
							self.statswin.addstr(str(speed/1024), atr )
							self.statswin.addstr("KB/s | Size: ")
							self.statswin.addstr(str(size), atr )
							if bitrate != '0' and length != 0:
								self.statswin.addstr(" | ")
								self.statswin.addstr(str(bitrate), atr )
								self.statswin.addstr("KHz | Len: ")
								self.statswin.addstr(str(minutes), atr )
								self.statswin.addstr(":")
								self.statswin.addstr(str(seconds), atr )
							self.statswin.noutrefresh()
						else:
							attr = curses.A_NORMAL
							attrc = self.colors["cyan"]
						try:
							sn = len(str(number))
							sr = len(str(self.search_number))
							if sn < sr :
								nub = (" " * (sr - sn)) + str(number)
							else:
								nub = str(number)
							
							if len(nub+"| ")+len(path) >= self.w-2:
								pos = self.w-2-len(str(nub)+"| ")-len(path)
								#pp = path[-pos:]
								directory, file = self.path_split(path)
								if abs(pos) > len(directory):
									a = abs(pos) - len(directory)
									file = file[:-a]
									directory = ''
								else:
									directory = directory[-pos:]
									
								extra = ''
							else:
								if len(str(nub)+"| "+ path) < self.w-2:
									
									directory, file = self.path_split(path)
									extra = " " * (self.w-2-len(str(nub)+"| "+ path))
								else:
									directory, file = self.path_split(path)
									extra = ''
							self.textwin.addstr(nub, attrc)
							self.textwin.addstr("| "+directory, attr)
							self.textwin.addstr(file, attrc)
							self.textwin.addstr(extra, attr)
						except:
							pass

			except Exception, e:
				self.Hlog("debug", "Search Log: " + str(e))
				
	def display_search_result(self, typer, result, ticket):
		lang = mucous_config["mucous"]["language"]
		if self.chosen_search==str(ticket) and self.DisplayMode == "search":
			search = self.searchlog[ str(ticket)][result]
			try:
				if typer =="result1":
					self.textwin.addstr(self.decode_language(search[0]))
					self.textwin.addstr(self.decode_language(search[1]), self.colors["blafgcyabg"] | curses.A_BOLD| curses.A_REVERSE)
					z = self.w-2-len(self.decode_language( search[result][1] ))
					space = ""
					while z >0:
						z -= 1
						space +=" "
					self.textwin.addstr(space, self.colors["blafgcyabg"] |curses.A_REVERSE|curses.A_BOLD)
				elif typer =="sstatus":
					self.textwin.addstr(self.decode_language(search))
				
			except Exception, e:
				pass
				
	def user_shares_cd(self, line):
		if self.browse_current_dir== '' or line[0:1] == '\\' or line[1:2] == ":":
			if self.browse_current in self.browse_list_results.keys():
				if line[0:1] == '\\':
					if line in self.browse_list_results[self.browse_current].keys():
						self.browse_current_dir = line
					else:
						self.Hlog("status", "No such directory: %s user:" % (line[1:],  self.browse_current))
				if line[1:2] == ":":
					if line in self.browse_list_results[self.browse_current].keys():
						self.browse_current_dir = line
					else:
						self.Hlog("status", "No such directory: %s user:" % (line,  self.browse_current))
				else:
					if line in self.browse_list_results[self.browse_current].keys():
						self.browse_current_dir = line
					else:
						self.Hlog("status", "No such directory: %s user:" % (line,  self.browse_current))
			
		elif line =='..':
			z = self.cd_dot_dot()
			if z != 0:
				self.browse_current_dir = z
			else:
				self.Hlog("status", "No parent directory, User: " +  self.browse_current)
		else:
			if self.browse_current_dir + '\\'+line in self.browse_list_results[self.browse_current].keys():
				self.browse_current_dir += '\\'+line
			else:
				self.Hlog("status", "No such directory: %sUser: " % (line, self.browse_current) )
				
		if self.browse_current == None:
			self.set_edit_title("Choose a user to Browse Shares")
		else:
			s = "Browse "+self.browse_current+"'s files in "
			ls = len(s)
			self.set_edit_title(s  + self.browse_current_dir[:self.w-ls-4] + " ")
			
	def cd_dot_dot(self):
		splitit = self.browse_current_dir
		splitit = splitit.split("\\")
		s = len(splitit)
		z=''
		for r in range(s-1):
			if r == 0:
				z += splitit[r]
			else:
				z += "\\"+splitit[r]
				
		if z in self.browse_list_results[self.browse_current].keys():
			return z
		else:
			return 0
		
			
	#Add new/replace old keys to self.config
	def mod_config(self, changetype, username, value):
		username = self.decode_language(username)
		if changetype == "buddy":
			if username not in self.config["buddies"].keys():
				self.send(messages.ConfigSet("buddies", username, "buddied by mucous"))
				
		elif changetype == "unbuddy":
			if username in self.config["buddies"].keys():
				self.send(messages.ConfigRemove("buddies", username))
			else:
				self.Hlog("status", "User not in buddy list: %s" % username)
		elif changetype == "ban":
			if username not in self.config["banned"].keys():
				self.send(messages.ConfigSet("banned", username, "banned by mucous"))
		elif changetype == "unban":
			if username in self.config["banned"].keys():
				self.send(messages.ConfigRemove("banned", username))
			else:
				self.Hlog("status", "User not in ban list: %s" % username)
		elif changetype == "ignore":
			if username not in self.config["ignored"].keys():
				self.send(messages.ConfigSet("ignored", username, ""))
				self.Hlog("status", "Ignored: %s" % username)
		elif changetype == "unignore":
			if username in self.config["ignored"].keys():
				self.send(messages.ConfigRemove("ignored", username))
			else:
				self.Hlog("status", "User not in ignore list: %s" % username)
		elif changetype == "autojoin":
			room = username
			if room not in self.config["autojoin"].keys():
				self.send(messages.ConfigSet("autojoin", room, ""))
			else:
				self.send(messages.ConfigRemove("autojoin", room))

		elif changetype == "unautojoin":
			room = username
			if room in self.config["autojoin"].keys():
				self.send(messages.ConfigRemove("autojoin", room))
			else:
				self.send(messages.ConfigSet("autojoin", room, ""))
		elif changetype == "trust":
			if username not in self.config["trusted"].keys():
				self.send(messages.ConfigSet("trusted", username,  ""))
		elif changetype == "distrust":
			if username in self.config["trusted"].keys():
				self.send(messages.ConfigRemove("trusted", username))
				
	def display_config_update(self, domain):
		if domain in ("buddies", "banned", "ignored",  "autojoin", "trusted"):
			if self.DisplayMode == "lists":
				if self.display_which_list == "buddies" and domain == "buddies":
					self.buddy_mode()
				elif self.display_which_list == "banned"  and domain == "banned":
					self.ban_mode()
				elif self.display_which_list == "ignored" and domain == "ignored":
					self.ignore_mode()
			elif self.DisplayMode == "chat" :
				self.roomstatusbox()
				
			if self.showmenu == True:
				self.draw_menu(self.currentmenu)
				
		elif domain in ("interests.like", "interests.hate"):
			if self.DisplayMode == "lists" and self.display_which_list == "interests":
				self.interests_mode()
		elif domain in ("clients", "transfers", "server", "interfaces", "interfaces.bind", "userinfo") and self.DisplayMode == "setup":
			self.setup_mode()
		elif domain in ("encoding.users", "encoding" ) and self.DisplayMode == "browse":
			self.browse_mode()
		elif domain in ("encoding.users" ) and self.DisplayMode == "private":	
			self.private_mode()
		elif domain in ("encoding.rooms" ) and self.DisplayMode == "chat":
			self.chat_mode()
		
	def download_path_file(self, dtype, number):
		try:
			number = int(number)
			if self.DisplayMode=="search":
				if self.search_results != {}:
					if self.search_results[number] != None:
						user = self.search_results[number][1]
						path = self.search_results[number][5]
					else:
						self.Hlog("status", "No such file")
				else:
					self.Hlog("status", "You need to search, first ;)")
					
			elif self.DisplayMode=="browse":
				if self.browse_scroll == "files":
					w = self.window_dimensions["browse"]
					if dtype == "dir":
						path = self.browse_current_dir
						#self.files[self.Sup+w["start"]
						user = self.browse_current
						#self.send(messages.GetFolderContents(user, directory))
					elif dtype == "file":
						user = self.browse_current
						path = self.browse_current_dir+"\\"+self.files[number]
				elif self.browse_scroll == "directories":
					w = self.window_dimensions["directories"]
					if dtype == "dir":
						path = self.browse_current_dir
						user = self.browse_current
						#self.send(messages.GetFolderContents(user, directory))
			if user != None and path != None:
				if dtype == "file":
					self.send(messages.DownloadFile(user, path))
					self.Hlog("status", "Try to Download file: %s from %s" % (path, user))
				elif dtype == "dir":
					r = path.split('\\')
					directory = ''
					for s in r:
						if s != r[-1]:
							directory += s+'\\'
					self.send(messages.GetFolderContents(user, directory))
					self.Hlog("status", "Try to Download directory: %s from %s" % (directory, user))
				
				if mucous_config["mucous"]["autobuddy"]  == "yes":
					if user not in self.config["buddies"].keys():
						self.send(messages.ConfigSet("buddies", user, "buddied by mucous"))
						self.Hlog("status", "Auto-Buddied: %s" % user)
				
		except Exception, e:
			self.Hlog("debug", "DPF: " + str(e))
			
	def upload_manager(self):
		try: 
			if self.DisplayMode == "transfer":
	
				if self.transfer_display_mode == 'active':
					status_list = (1, 2, 3, 4, 5, 6, 8, 9,)
				elif self.transfer_display_mode == 'all':
					status_list = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14)
				elif self.transfer_display_mode == 'finished':
					status_list = (0, 99999)
				elif self.transfer_display_mode == 'queued':
					status_list = (7, 99999)
				elif self.transfer_display_mode == 'failed':
					status_list = (  10, 11, 12, 13)
				uploadlist = []
				num = 0
				self.up_transfer_numbers = {}
				userlist = self.transfers["uploads"].keys()
				userlist.sort()
				
				self.sorted_transfer_list["uploads"] = userlist
				for user_path in userlist:
					num += 1
					item = self.transfer_item("uploads", user_path, num, status_list)
					if item != None:
						uploadlist.append(item)
					
				
				if mucous_config["mucous"]["transbox"] == "split":
					self.Win_Height =self.h/2-5
				else:
					self.Win_Height =self.h -8
				if self.transferscroll == "upload":
					clipped_list, self.Sup, start = self.scrollbox(uploadlist, self.Sup, self.Win_Height)
					s = self.Sup
				else:
					clipped_list, s, start = self.scrollbox(uploadlist, 0, self.Win_Height)
				self.window_dimensions["uploads"]["start"] = start
				
				try:
					if self.transferscroll == "upload" or mucous_config["mucous"]["transbox"] == "split":
						
						if self.trans_speed_display == True:
							swting = "Numb|Speed| Size | Username |  Status  |  Path"
						else:
							swting = "Numb|Perc | Size | Username |  Status  |  Path"
						spaces = self.w-2-len(swting)
						while spaces > 0:
							spaces -= 1
							swting += " "
						self.upwin.erase()
						if self.transferscroll == "upload":
							self.upwin.addstr(swting, self.colors["green"] | curses.A_REVERSE)
						else:
							self.upwin.addstr(swting, self.colors["blafgcyabg"] )
				except Exception, e:
					self.Hlog("debug", "Upload Item: " + str(e))
					
				try:
					if clipped_list != []:
						count = 0
						for transfers in clipped_list:
							
							if transfers[1] == 1:
								attr = self.colors["green"]
							elif transfers[1] == 0:
								attr = self.colors["magenta"]
							elif transfers[1] in (10, 11, 12, 13, 14):
								attr = self.colors["red"]
							else:
								attr = curses.color_pair(0)
							if count + start == s:
								attr = curses.A_REVERSE | curses.A_BOLD
							try:
								self.upwin.addstr(self.decode_language(transfers[0]), attr)
							except:
								pass
							count += 1
					else:
						self.upwin.addstr("\nNo transfers in this category, hit INSERT to switch to another.")
						
				except:
					pass
			self.upwin.noutrefresh()
		except Exception, e:
			self.Hlog("debug", "Upload Manager: " + str(e))
			
	def transfer_item(self, tran, user_path, num, status_list):
		try:
			if tran == 'downloads':
				vals = self.transfers["downloads"][user_path]
			else:
				vals = self.transfers["uploads"][user_path]
				
			transfer, user, path, status, error, filepos, filesize, rate, place = vals[0], vals[1], vals[2], vals[3], vals[4], vals[5], vals[6], vals[7], vals[8]
			
			username = {}
			username[user] = path
			if tran == 'downloads':
				self.down_transfer_numbers[num] = username
			elif tran == "uploads":
				self.up_transfer_numbers[num] = username
	
			if status in status_list:
	
				if filesize != 0:
					percent = str(100 * filepos / filesize)
					if len(percent) < 2:
						percent = '  ' + percent
					if len(percent) < 3:
						percent = ' ' + percent
					filefrmt  = self.byte_format(filesize)
					if len(filefrmt) < 6:
						filefrmt = ' ' * (6-len(filefrmt)) + filefrmt

				else: 
					percent = '  0'
					filefrmt = '0 Bits'
	
				ae = str(num)
				while len(ae) < 4:
					ae = ' '+ae
				mo = {}
				while len(user[:10]) < 10:
					user += " "
				cut_status = self.states[status][:10]
				if len(cut_status) < 10:
					cut_status += (10-len(cut_status)) *" "
				
				if tran == "downloads":
					if place == 4294967295:
						place = ""
					else:
						place = str(place)
					if len(place) < 4:
						cut_place = (" " * (4 -(len(place) )) )+ place
					else:
						cut_place = place[:3] + "~"

				if self.trans_speed_display == True:
					ratefrmt  = self.byte_format(rate)
					if len(ratefrmt) < 5:
						ratefrmt += ' '* (5-len(ratefrmt))
					
					
					#Speed
					if tran == "downloads":
						ea = "%s|%s|%s|%s|%s|%s|%s" % (str(ae), ratefrmt[:5], filefrmt , user[:10], cut_status, cut_place, path[-self.w+45+2:])
					else:
						ea = "%s|%s|%s|%s|%s|%s" % (str(ae), ratefrmt[:5], filefrmt , user[:10], cut_status,  path[-self.w+40+2:])
				else:
					# Percent
					if tran == "downloads":
						ea = "%s| %s%%|%s|%s|%s|%s|%s" % (str(ae), percent[:5] , filefrmt , user[:10], cut_status, cut_place, path[-self.w+45+2:])
					else:
						ea = "%s| %s%%|%s|%s|%s|%s" % (str(ae), percent[:5] , filefrmt , user[:10], cut_status,  path[-self.w+40+2:])
	
				if len(ea) < self.w-2:
					ea += " " * (self.w -2- len(ea))
				mo = ea, status
				return mo
		except Exception, e:
			self.Hlog("debug", "Transfer Item: "+tran +": " + str(e))
			
	def download_manager(self):
		try:
			if self.DisplayMode == "transfer":
				w = self.window_dimensions["downloads"]
				if self.transfer_display_mode == 'active':
					status_list = (1, 2, 3, 4, 5, 6, 8, 9,)
				elif self.transfer_display_mode == 'all':
					status_list = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,  14)
				elif self.transfer_display_mode == 'finished':
					status_list = (0, 99999)
				elif self.transfer_display_mode == 'queued':
					status_list = (7, 99999)
				elif self.transfer_display_mode == 'failed':
					status_list = (  10, 11, 12, 13)
				downloadlist = []
				num = 0
				self.down_transfer_numbers = {}
				userlist = self.transfers["downloads"].keys()
				userlist.sort()
				self.sorted_transfer_list["downloads"] = userlist
				for user_path in userlist:
					num += 1
					item = self.transfer_item("downloads", user_path, num, status_list)
					if item != None:
						downloadlist.append(item)
				#self.Hlog("debug", downloadlist)
				if self.transferscroll == "download":
					self.Win_Height =self.window_dimensions["downloads"]["height"]-1
					
				if self.transferscroll == "download":
					clipped_list, self.Sup, start = self.scrollbox(downloadlist, self.Sup, self.Win_Height)
					s = self.Sup
 				else:
 					clipped_list, s, start = self.scrollbox(downloadlist, 0, self.Win_Height)
# 				clipped_list, self.Sup, start = self.scrollbox(downloadlist, self.Sup, self.Win_Height)
				self.window_dimensions["downloads"]["start"] = start
				if self.transferscroll == "download" or mucous_config["mucous"]["transbox"] == "split":
					
					try:
						if self.trans_speed_display == True:
							swting = "Numb|Speed| Size | Username |  Status  | Que|  Path"
						else:
							swting = "Numb|Perc | Size | Username |  Status  | Que|  Path"
							#4294967295
						spaces = self.w-2-len(swting)
						while spaces > 0:
							spaces -= 1
							swting += " "
						self.downwin.erase()
						if self.transferscroll == "download":
							self.downwin.addstr(swting, self.colors["green"] | curses.A_REVERSE)
						else:
							self.downwin.addstr(swting, self.colors["blafgcyabg"] )
					except:
						pass
					try:
						
						if clipped_list != []:
							count = 0
							for transfers in clipped_list:
								if transfers == None:
									continue
								
								if transfers[1] == 1:
									attr = self.colors["green"]
								elif transfers[1] == 0:
									attr = self.colors["magenta"]
								elif transfers[1] in (10, 11, 12, 13, 14):
									attr = self.colors["red"]
								else:
									attr = curses.color_pair(0)
								if count + start == s:
									attr = curses.A_REVERSE | curses.A_BOLD
								try:
									self.downwin.addstr(self.encode_language(transfers[0])[:w["width"]], attr)
									
								except:
									pass
								count += 1
						else:
						
							self.downwin.addstr("\nNo transfers in this category, hit INSERT to switch to another.")
					except Exception, e:
						self.Hlog("debug", "Download log: " + str(e))
					self.downwin.noutrefresh()

		except Exception, e:
			self.Hlog("debug", "Download Manager: " + str(e))
		
		# Change Room Title in edit window
		
	def scrollbox(self, current_list, hightlight_position, height):
		length =len(current_list)
		if hightlight_position < 0:
			hightlight_position = 0
		elif hightlight_position > length -1:
			hightlight_position = length-1
		
		start = hightlight_position-height/2
		
		if start  < 0:
			to = hightlight_position + (height-height/2)-start
			start  = 0
			
		else:
			to = hightlight_position + (height-height/2)
			
		if to >= length:
			start = abs(to - length - start)
			to =length
			
		if length < height:
			start =0
		#self.Hlog("debug", "s%se%su%s"%(start,to,hightlight_position) )
		if current_list[start:to] != [None]:
			clipped_list = current_list[start:to]
		else:
			clipped_list = []
		return clipped_list, hightlight_position, start
			
	def show_nick_list(self, room):
		self.colorednicks = {}
		
		if self.rooms[room] != None:
			
			self.colorednicks[room] = []
			alphanicks=[]
			alphanicks = self.rooms[room]
			alphanicks.sort()
			self.Hlog("status", "Users in " + room)
			for username in alphanicks:
				if username == self.username:
					self.colorednicks[room].append([username, "Me"])
				elif username not in self.rooms[room]:
					self.colorednicks[room].append([username, "Left"])
				elif username in self.config["banned"]:
					self.colorednicks[room].append([username, "Banned"])
				elif username in self.config["buddies"]:
					self.colorednicks[room].append([username, "Buddies" ])
				else:
					self.colorednicks[room].append([username, "Normal"])
				self.colorednicks[room].append([" ["+str(self.user_stats[username])+"]", "Normal"])
				line = username + (" " * (30 - len(username)) ) + "Files: " + str(self.user_stats[username][2])
				
				#line = "%s": [%s] Files" % (username,  )
 				self.Hlog("status", line)
				if username is not alphanicks[-1]:
					self.colorednicks[room].append([", ", "NotLast"])
			mtype = "List"
			user = "!!!!"
			msg = self.colorednicks[room]
			
			#self.say("List", room, '!!!!', msg)
			
	def close_userinfo(self, user):
		if user in self.info_users:
			self.info_users.remove(user)
		if self.info_users != []:
			for users in self.info_users:
				self.info_user = users
				break
		else:
			self.info_user = None
		if self.DisplayMode == 'info':
			self.info_mode()
			
	def close_private_chat(self, user):
		try:
			del self.privatelog[user]
			if self.privatelog.keys() != {}:
				for users in self.privatelog.keys():
					self.pm_user = users
					break
			else:
				self.pm_user = None
			if self.DisplayMode == 'private':
				self.private_mode()
		except Exception, e:
			self.Hlog("debug", "close_private_chat: %s" % str(e))
					
	def close_search(self, ticket):
		if ticket in self.s_query.keys():
			del self.s_query[ticket]
		if ticket in self.searchlog:
			del self.searchlog[ticket]
		if self.s_query.keys() != []:
			self.chosen_search = self.s_query.keys()[0]
		else:
			self.chosen_search = "default__"
		self.search_mode()
		
	def close_browse(self, user):
		if user in self.browsed:
			self.browsed.remove(user)
			self.dsup = 0
		if user in self.browselog:
			del self.browselog[user]
		if self.browsed != []:
			if self.browse_current == user:
				self.browse_current = self.browsed[0]
		else:
			self.browse_current = "default__"
		self.browse_mode()
		
	def clear_searchs(self):
		self.s_query = {}
		self.searchlog = {}
		self.search_number = 0
		self.chosen_search="default__"
		self.search_mode()
		
	
		
	# Rebuild Buddylist from self.config
 	def buddylist(self):
		if "buddies" in self.config.keys():
			self.buddylog = []
			alpha_list = SortedDict()
			for keyname, keyvalue in self.config["buddies"].items():
				alpha_list[keyname] = keyvalue
			
			for keyname, keyvalue in alpha_list.items():
				banned = None
				ignored = None
				for bdomain, bkey in self.config.items()[:]:
					if bdomain == "banned":
						for bkeyname, bkeyvalue in bkey.items():
							if keyname == bkeyname:
								banned = 1
					elif bdomain == "ignored":
						for bkeyname, bkeyvalue in bkey.items():
							if keyname == bkeyname:
								ignored = 1
				if banned != None:
					self.buddy_log("Banned",  keyname, keyvalue)
				elif ignored != None:
					self.buddy_log("Ignored",  keyname, keyvalue)
				else:
					self.buddy_log("Normal",  keyname, keyvalue)

	# Rebuild Banlist from self.config
 	def banlist(self):
		if "banned" in self.config.keys():
			self.banlog = []
			alpha_list = SortedDict()
			for keyname, keyvalue in self.config["banned"].items():
				alpha_list[keyname] = keyvalue
			
			for keyname, keyvalue in alpha_list.items():
				buddies = None
				ignored = None
				for bdomain, bkey in self.config.items()[:]:
					if bdomain == "buddies":
						for bkeyname, bkeyvalue in bkey.items():
							if keyname == bkeyname:
								buddies = 1
					elif bdomain == "ignored":
						for bkeyname, bkeyvalue in bkey.items():
							if keyname == bkeyname:
								ignored = 1
				if buddies != None:
					self.ban_log("Buddies", keyname, keyvalue)
				elif ignored != None:
					self.ban_log("Ignored",  keyname, keyvalue)
				else:
					self.ban_log("Normal",  keyname, keyvalue)
		
	# Rebuild Ignorelist from self.config
	def ignorelist(self):
		if self.config !=  {}:
			if "ignored" in self.config.keys():
				self.ignorelog = []
				alpha_list = SortedDict()
				for keyname, keyvalue in self.config["ignored"].items():
					alpha_list[keyname] = keyvalue
				
				for keyname, keyvalue in alpha_list.items():
					banned = None
					buddies = None
					for bdomain, bkey in self.config.items()[:]:
						if bdomain == "buddies":
							for bkeyname, bkeyvalue in bkey.items():
								if keyname == bkeyname:
									buddies = 1
						elif bdomain == "banned":
							for bkeyname, bkeyvalue in bkey.items():
								if keyname == bkeyname:
									banned = 1	
					if buddies != None:
						self.ignore_log("Buddies",  keyname, keyvalue)
					elif banned != None:
						self.ignore_log("Banned",  keyname, keyvalue)
					else:
						self.ignore_log("Normal",  keyname, keyvalue)

					
	def completion_list(self):
		usercompletionlist = {}
		if "buddies" in self.config:
			for users in self.config["buddies"].keys():
				usercompletionlist[self.decode_language(users)] = 0
		if "banned" in self.config:
			for users in self.config["banned"].keys():
				usercompletionlist[self.decode_language(users)] = 0
		if "ignored" in self.config:
			for users in self.config["ignored"].keys():
				usercompletionlist[self.decode_language(users)] = 0
		if self.rooms.keys() != []:
			for room in self.rooms.keys():
				for users in  self.rooms[room]:
					usercompletionlist[self.decode_language(users)] = 0
		if self.transfers["uploads"].keys() != []:
			for userpath, values in self.transfers["uploads"].items():
				usercompletionlist[self.decode_language(values[1])] = 0
		if self.transfers["downloads"].keys() != []:
			for userpath, values in self.transfers["downloads"].items():
				usercompletionlist[self.decode_language(values[1])] = 0
		if self.DisplayMode == "browse":
			if self.browse_current != None:
				if self.browse_current in self.browse_list_results:
					for dirs in self.browse_list_results[self.browse_current].keys():
						usercompletionlist[self.decode_language(dirs)] = 0
		for values in self.commandlist:
			usercompletionlist[self.decode_language(values)] = 0
			
		if usercompletionlist.keys() != []:
			self.tab_complete_list = usercompletionlist.keys()
			self.tab_complete_list.sort()
		else:
			self.tab_complete_list=[]


	def scrolltext(self, line):
		key = self.key
		color_added = None
		if self.DisplayMode in ("dsfsdbrodfwse"):
			# not in ("transfer", "setup", "search", "help", "debug", "info", "private"):
			
			if self.DisplayMode == "browse":
				window = "browse"
				selected_log = self.browselog[self.browse_current]
			
			
			if key == "KEY_UP":	
				# SCROLLING UP
				# Redisplay chat log with one less line every time the Up key is pressed
				self.Sup_last = self.Sup
				self.Sup = self.Sup -1
			elif key == "KEY_DOWN":
				#SCROLLING DOWN
 				if self.Sup_last == 1:
 					if self.DisplayMode not in ("lists", "rooms") and self.chatroomscroll != "roombox":
 						return
				self.Sup_last = self.Sup
				self.Sup = self.Sup +1
			elif key == "KEY_PPAGE":
				self.Sup_last = self.Sup
				self.Sup = self.Sup - self.window_dimensions[window]["height"]
			elif key == "KEY_NPAGE":
				self.Sup_last = self.Sup
				self.Sup = self.Sup + self.window_dimensions[window]["height"]
			log_scroll = []
			if selected_log != None:
				if self.DisplayMode != "rooms":
					log_scroll = selected_log
					
					
				if self.DisplayMode  ==  "browse":
					self.Win_Height = self.window_dimensions[window]["height"]
				
						
				
				if self.DisplayMode == "browse":
					# NORMAL scrolling
					
					if self.Sup > len(log_scroll)  - self.Win_Height:
						self.Sup = len(log_scroll)  - self.Win_Height 
					if self.Sup < 0:
						self.Sup = 0
					
					self.end = end = self.Sup + abs(self.Win_Height)
					start = self.Sup
					if start <= 0:
						start = 0
					
					self.start = start
					self.end = end
					
					if len(log_scroll) + 2 < self.Win_Height:
						self.Sup = 0
						return	
				
					
				if self.DisplayMode == "browse":
					self.textwin.erase()
					count = 0 
					for lines in log_scroll[start:end]:
						
						self.display_browse_text(lines, count , self.Sup )
						count += 1
				else :
					if  len(log_scroll) > self.Win_Height:
						self.textwin.erase()
						for lines in log_scroll[start:end]:
							try:
								self.textwin.addstr(self.decode_language(lines))
							except:
								pass
						self.textwin.refresh()
			
		elif self.DisplayMode in ( "transfer", "search", "help", "debug", "info", "private", "lists", "rooms", "chat", "browse"):
			if self.DisplayMode == "chat":
				if self.chatroomscroll == "roomchat":
					w = self.window_dimensions["chat"]
					if self.current_room != None:
						selected_log = self.roomlogs[self.current_room]
					else: 
						self.drawchatwindow()
						self.textwin.refresh()
						return
				elif self.chatroomscroll == "roombox":
					w = self.window_dimensions["roombox"]
					selected_log = self.roomboxlist[self.current_room]
				scrolldiff = w["height"]
			elif self.DisplayMode == "browse":
				scrolldiff = self.window_dimensions["browse"]["height"]
			elif self.DisplayMode in ("help", "debug"):
				scrolldiff = self.window_dimensions["help"]["height"]
			elif self.DisplayMode in ("info", "private"):
				scrolldiff = self.window_dimensions[self.DisplayMode]["height"]
			elif self.DisplayMode == "search":
				scrolldiff = self.window_dimensions["search"]["height"]
			elif self.DisplayMode == "lists":
				if self.display_which_list == "buddies":
					scrolldiff = self.window_dimensions[self.display_which_list]["height"]
					selected_log = self.buddylog
				elif self.display_which_list == "banned":
					scrolldiff = self.window_dimensions[self.display_which_list]["height"]
					selected_log = self.banlog
				elif self.display_which_list == "ignored":
					scrolldiff = self.window_dimensions[self.display_which_list]["height"]
					selected_log = self.ignorelog
			elif self.DisplayMode == "rooms":
				scrolldiff = self.window_dimensions[self.DisplayMode]["height"]
			elif self.DisplayMode == "transfer":
				if mucous_config["mucous"]["transbox"] == "split":
					if self.transferscroll == "upload":
						scrolldiff = self.window_dimensions["uploads"]["height"]-1
					elif self.transferscroll == "download":
						scrolldiff = self.window_dimensions["downloads"]["height"]-1
				else:
					scrolldiff = self.h-7
					
			if key == "KEY_UP":	
				self.Sup = self.Sup -1
			elif key == "KEY_DOWN":
				self.Sup = self.Sup +1
			elif key == "KEY_PPAGE":
				# upload or download window height - one line for heading
				self.Sup = self.Sup -scrolldiff +1
			elif key == "KEY_NPAGE":
				self.Sup = self.Sup + scrolldiff -1
			
			if self.Sup < 0:
				self.Sup = 0
			
			if self.DisplayMode == "chat":
				if self.chatroomscroll  == "roomchat":
					#start -= 1
					self.chat_display()
				elif self.chatroomscroll  == "roombox":
					self.chat_roombox_display()
			elif self.DisplayMode == "browse":	
				
				self.browse_display()
				curses.doupdate()
			elif self.DisplayMode == "info":
				self.info_display()
			elif self.DisplayMode == "private":
				self.private_display()
			elif self.DisplayMode == "search":
				self.search_display()
			elif self.DisplayMode == "lists":
				self.display_lists()
				return
			elif self.DisplayMode == "rooms":
				self.display_room_list_mode()
				return self.sizedrooms[self.Sup]
			elif self.DisplayMode in ("help", "debug"):
				self.help_display()
			elif self.DisplayMode == "transfer":
				if self.transferscroll == "upload":
					self.upload_manager()
					curses.doupdate()
				elif self.transferscroll == "download":
					self.download_manager()
					curses.doupdate()
			
		self.key = None
	# ---v  KEYS v
	
	# Tab completion
	def tabbing(self, line, word, firsttab, listline):
		self.firsttab = firsttab
		self.listline = listline
		if self.firsttab ==0:
			self.completion_list()
		if self.tab_complete_list !=[]:
			
			if self.DisplayMode in ("rooms", "chat", "lists", "info", "private", "browse", "transfer", "setup", "search", "help", "debug", "status"):
				if self.firsttab ==0:
					self.keepit=[]
					if self.DisplayMode == "rooms":
						for words in self.all_roomlist.keys():
							if words.startswith(word[0:1]):
								self.keepit.append(words)
					else:
						for words in self.tab_complete_list:
							if word[0:1] == '/':
								if len(word) > 2:
									if words.startswith(word[0:3]):
										self.keepit.append(words)
								else:
									if words.startswith(word[0:2]):
										self.keepit.append(words)
								# Be more picky with /commands
							else:
								if words.startswith(word[0:1]):
									self.keepit.append(words)
					self.keepit.sort()
	
				self.firsttab +=1
				if self.listline == []:
					self.listline = line.split(" ")
				split_line = self.listline
				
				for words in self.keepit:
					if len(split_line[-1]) > 1:
						x = len(split_line[-1])
					else:
						x = 1
					# WOO HOO
					# The above x fixes the previously broken tabbing
					if words.startswith(split_line[-1][0:x]) and split_line[-1] != ' ' and split_line[-1] != '':
						self.listline = []
						r = len(split_line)
						if r >1:
							
							for s in split_line:
								if s is not split_line[-1]:
									self.listline.append(s)
								elif s is split_line[-1]:
									if s != words:
										self.listline.append(words)
										break
									elif s == words:
										if self.firsttab ==0:
											if words.startswith(split_line[-1]):
												self.listline.append(self.keepit[0])
												break
										else:
											self.keepit.append(self.keepit[0])
											del self.keepit[0]
											self.listline.append(self.keepit[0])
											break
							break
						else:
							s =  split_line[0]
							if s != words:
								if words.startswith(s):
									self.listline.append(words)
									break
							elif s == words:
								if self.firsttab ==0:
									if words.startswith(split_line[-1]):
										self.listline.append(self.keepit[0])
										break
								else:
									
									self.keepit.append(self.keepit[0])
									del self.keepit[0]
									self.listline.append(self.keepit[0])
									break
	
	
				return self.listline, self.firsttab
		return self.listline, self.firsttab
							
	def history(self, key, line, history_count):
		self.history_count = history_count
		if line not in self.historylog and line !='':
			if line.isspace():
				pass
			else:
				self.historylog.append(line)
		if len(self.historylog) == 0:
			return line, self.history_count
		if key == "KEY_UP":
			self.history_count += 1
		if key == "KEY_DOWN":
			self.history_count -= 1

		last_line = len(self.historylog) -1 - self.history_count
		if last_line < 0:
			last_line = len(self.historylog) -1
			self.history_count = 0
		elif last_line > len(self.historylog) -1:
			last_line = len(self.historylog) -1
			self.history_count += 1
		line = self.historylog[ last_line]
		
		return line, self.history_count
		
	def get_transfer_number(self, this_list):
		number = None
		username = this_list[self.Sup][1] 
		path = this_list[self.Sup][2]
		
		userpath = (username, path)
		
		if self.transferscroll != "download":
			listw = "uploads"
		else:
			listw = "downloads"
		count = 1
		transfer = None
		for user, path  in self.sorted_transfer_list[listw]:
			if (user, path) == userpath:
				#transfer = count
				number = count
				break
			count += 1
		return number

	def create_menu(self, menu, up):
		try:
			
			self.currentmenu=menu
			title = None
			number = None
			self.menunumber = up
			this_list = self.find_menu()
			if this_list == []:
				return
			if menu == "roombox":
				if self.chatdisplaymode == "rightlist":
					left = self.window_dimensions["roombox"]["left"] - 22
				else:
					left = self.window_dimensions["roombox"]["left"]+self.window_dimensions["roombox"]["width"]+1
				top = 2; width = 20
				title = "%s" % (self.roomboxlist[self.current_room][self.Sup])[:16]
				user = name = self.roomboxlist[self.current_room][self.Sup]
				if user in self.user_stats.keys():
					number = str(self.user_stats[user][2]) + " Files"
				items = [["Private Message", "all"], ["Userinfo", "all"], ["IP Address", "all"], ["Browse", "all"], ["", "line"], ["Buddy", "buddies"], ["Ban", "banned"], ["Ignore", "ignored"], ["Trusted", "trusted"], ["Give Privileges", "giveprivs"]  ]
				height = len(items) + 2	
			elif menu == "lists":
				left = 25; top = 2; width = 20
				title = "%s" % (this_list[self.Sup])[1][:16]
				name = this_list[self.Sup][1]
				items = [["Private Message", "all"], ["Userinfo", "all"], ["IP Address", "all"], ["Browse", "all"], ["", "line"], ["Buddy", "buddies"], ["Ban", "banned"], ["Ignore", "ignored"], ["Trusted", "trusted"], ["Give Privileges", "giveprivs"]  ]
				height = len(items) + 2	
				
			elif menu == "transfers":
				left = 25; top = 1; width = 20
				
				title = "%s" % this_list[self.Sup][1][:16]
				name = this_list[self.Sup][1]
				
				number = self.get_transfer_number(this_list)
				if self.transferscroll == "download":
					items = [["Retry", "transfers"], ["Retry All", "transfers"],["Abort", "transfers"], ["Abort User", "transfers"], ["Clear", "transfers"], ["Clear Finished", "transfers"], ["Clear User", "transfers"], ["", "line"], ["Private Message", "all"], ["Userinfo", "all"], ["IP Address", "all"], ["Browse", "all"], ["", "line"], ["Buddy", "buddies"], ["Ban", "banned"], ["Ignore", "ignored"], ["Trusted", "trusted"], ["Give Privileges", "giveprivs"],  ["Get Queue Place", "getplace"] ]
				else:
					items = [["Retry", "transfers"], ["Retry All", "transfers"],["Abort", "transfers"], ["Abort User", "transfers"], ["Clear", "transfers"], ["Clear Finished", "transfers"], ["Clear User", "transfers"], ["", "line"], ["Private Message", "all"], ["Userinfo", "all"], ["IP Address", "all"], ["Browse", "all"], ["", "line"], ["Buddy", "buddies"], ["Ban", "banned"], ["Ignore", "ignored"], ["Trusted", "trusted"], ["Give Privileges", "giveprivs"]  ]
				height = len(items) + 2	
			elif menu == "search":
				left = 25; top = 5; width = 20
				number = this_list[self.Sup-self.window_dimensions["search"]["start"]]
				title = "%s" % (self.search_results[number][1])
				name = self.search_results[number][1]
				
				items = [ ["Download", "download"], ["Download Dir", "downdir"], ["Display Full Path", "displaypath"], ["", "line"], ["Private Message", "all"], ["Userinfo", "all"], ["IP Address", "all"], ["Browse", "all"], ["", "line"], ["Buddy", "buddies"], ["Ban", "banned"], ["Ignore", "ignored"], ["Trusted", "trusted"], ["Give Privileges", "giveprivs"]]
				height = len(items) + 2	
			elif menu == "browse-dirs":
				left = 23; top = 5; width = 20
				#number = this_list[self.Sup-self.window_dimensions["directories"]["start"]]
				title = "Directory" 
				name = self.browse_current
				
				items = [ ["Download Dir", "downdir"], ["Display Full Path", "displaypath"], ["", "line"], ["Private Message", "all"], ["Userinfo", "all"], ["IP Address", "all"], ["Refresh Shares", "all"], ["", "line"], ["Buddy", "buddies"], ["Ban", "banned"], ["Ignore", "ignored"], ["Trusted", "trusted"],  ["Give Privileges", "giveprivs"]]
				height = len(items) + 2	
			elif menu == "browse-files":	
				left = 2; top = 5; width = 20
				number =self.Sup + 1 #self.window_dimensions["browse"]["start"]+1
				title = "File"
				name = self.browse_current
				
				items = [ ["Download", "download"], ["Download Dir", "downdir"], ["Display Full Path", "displaypath"], ["", "line"], ["Private Message", "all"], ["Userinfo", "all"], ["IP Address", "all"], ["Browse", "all"], ["", "line"], ["Buddy", "buddies"], ["Ban", "banned"], ["Ignore", "ignored"], ["Trusted", "trusted"], ["Give Privileges", "giveprivs"]]
				height = len(items) + 2	
			elif menu == "encoding":
				left = self.w-27; top = 2; width = 20
				number =  None
				title = "Encoding"
				
				if self.DisplayMode == "browse":
					if self.browse_current != "default__":
						name = self.browse_current
					else:
						name = "Filesystem"
				elif self.DisplayMode == "chat":
					name = self.current_room
				elif self.DisplayMode == "private":
					name = self.pm_user
					
				items = [ ["UTF-8", ""], ["iso-8859-1", ""], ["iso-8859-2", ""], ["iso-8859-3", ""], ["iso-8859-4", ""], ["iso-8859-5", ""], ["iso-8859-6", ""], ["iso-8859-7", ""], ["iso-8859-8", ""], ["iso-8859-9", ""], ["iso-8859-10", ""], ["iso-8859-11", ""], ["iso-8859-13", ""],["iso-8859-14", ""],["iso-8859-15", ""], ["iso-8859-16", ""],["KIO8-R", ""], ["CP1250", ""], ["CP1251", ""],["CP1252", ""],["CP1253", ""],["CP1254", ""],["CP1255", ""],["CP1256", ""],["CP1257", ""],["CP1258", ""],["CP874", ""] ]
				if  len(items)+2 > self.h-9:
					height = self.h-9
				else:
					height = len(items)+2
			winbg =  curses.newwin(height+1, width+1, top, left)
			winbg.erase()
			winbg.noutrefresh()
			win =  curses.newwin(height, width, top, left)
			win.attron(self.colors["green"] | curses.A_BOLD)
# 			win.bkgdset(" ", self.colors["green"])
			win.erase()
			win.border()
			if title != None:
				win.addstr(0, 1,  "<%s>" % title)
			if number != None:
				win.addstr(height-1, 1,  "< %s >" % number)
			win.attroff(self.colors["green"] | curses.A_BOLD)
			win.noutrefresh()
			scroll = win.subwin(height-2, width-2, top+1, left+1)
# 			scroll.erase()
			scroll.scrollok(0)
# 			scroll.noutrefresh()
			self.menus[menu] = {"window": win, "scroll": scroll, "name": name, "items": items, "top": top, "width": width, "height": height, "left": left}
			self.draw_menu(menu)
			
			#sleep(1)
		except Exception, e:
			self.Hlog("debug", "Create Menu " +str(e))
		
	def draw_menu(self, menu):
		try:
			self.menus[menu]["scroll"].erase()
			c = 0

			clipped_list, self.menunumber, start = self.scrollbox(self.menus[menu]["items"], self.menunumber, self.menus[menu]["height"]-2)
			#for z in self.menus[menu]["items"]:
			for z in clipped_list:
				try:
					username = self.menus[menu]["name"]
						
					if z[1] in ("banned", "ignored", "buddies", "trusted"):
						if z[1]=="buddies":
							that_list = self.config["buddies"].keys()
						elif z[1]=="banned":
							that_list = self.config["banned"].keys()
						elif z[1]=="ignored":
							that_list = self.config["ignored"].keys()
						elif z[1]=="trusted":
							that_list = self.config["trusted"].keys()	
						r = 0
						if username in that_list:
							r = 1
								
						if r == 1:
							self.menus[menu]["scroll"].addstr("* ", self.colors["green"])
						else:
							self.menus[menu]["scroll"].addstr("* ", self.colors["red"])
						
						spaces = " " * (self.menus[menu]["width"]-2 - len(z[1]) -2)
						line = z[1].capitalize()+spaces
	
					elif z[1] == "line":
						line =" "  * (self.menus[menu]["width"]-2)
						if self.menunumber == c + start:
							self.menus[menu]["scroll"].addstr(line, self.colors["green"] | curses.ACS_HLINE)
						else:
							self.menus[menu]["scroll"].addstr(line,  curses.ACS_HLINE)
						c += 1
						continue
					else:
						spaces = " " * (self.menus[menu]["width"]-2 - len(z[0]) )
						line = z[0] + spaces
						
					if self.menunumber == c +start:
						self.menus[menu]["scroll"].addstr(line, self.colors["green"])
					else:
						self.menus[menu]["scroll"].addstr(line)
				except Exception, e:
	
					pass
				c += 1
			self.menus[menu]["scroll"].noutrefresh()
			curses.doupdate()
		except Exception, e:
			self.Hlog("debug", "draw_menu " +str(e))
			
	def find_menu(self):
		try:
			if self.currentmenu == "encoding":
				return [""]
			if self.DisplayMode == "chat":
				this_list = self.roomboxlist[self.current_room]
			elif self.DisplayMode == "lists":
				if self.display_which_list=="buddies":
					this_list = self.buddylog
				elif self.display_which_list=="banned":
					this_list = self.banlog
				elif self.display_which_list=="ignored":
					this_list = self.ignorelog
			elif self.DisplayMode == "transfer":
				this_list = self.get_transfers_list()
			elif self.DisplayMode == "search":
				this_list = self.searchlist_displayed
			elif self.DisplayMode == "browse":
				if self.browse_current != "default__":
					if self.browse_scroll == "files":
						this_list = self.files
					elif self.browse_scroll == "directories":
						this_list = self.directories
				
			return this_list
		except Exception, e:
			self.Hlog("debug", "find_menu " +str(e))
			
	def get_transfers_list(self):
		this_list = []
		
		if self.transfer_display_mode == 'active':
			status_list = (1, 2, 3, 4, 5, 6, 8, 9,)
		elif self.transfer_display_mode == 'all':
			status_list = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,  14)
		elif self.transfer_display_mode == 'finished':
			status_list = (0, 99999)
		elif self.transfer_display_mode == 'queued':
			status_list = (7, 99999)
		elif self.transfer_display_mode == 'failed':
			status_list = (  10, 11, 12, 13)
		if self.transferscroll == "upload":
			
			for username, path in self.sorted_transfer_list["uploads"]:
				vals = self.transfers["uploads"][(username, path)]
				upload, username, path, status, error, filepos, filesize, rate = vals[0], vals[1], vals[2], vals[3], vals[4], vals[5], vals[6], vals[7]
				if status in status_list:
					this_list.append(vals)
					
		elif self.transferscroll == "download":
			#self.Hlog("debug", self.sorted_transfer_list["downloads"])
			for username, path in self.sorted_transfer_list["downloads"]:
				vals = self.transfers["downloads"][(username, path)]
				upload, username, path, status, error, filepos, filesize, rate = vals[0], vals[1], vals[2], vals[3], vals[4], vals[5], vals[6], vals[7]
				if status in status_list:
					this_list.append(vals)
		#this_list.sort()
		return this_list
			
	def pick_menu_item(self, x, y, click):
		width = self.menus[self.currentmenu]["width"]
		top = self.menus[self.currentmenu]["top"]
		height = self.menus[self.currentmenu]["height"]
		left = self.menus[self.currentmenu]["left"]
		
		if x >= left and x < width + left and y >= top and y < top + height:
			if y > top and y < top + height -1:
				y -= top+1
				#self.error_bar("y"+str(y) + " x"+ str(x))
				self.menunumber = y
				self.draw_menu(self.currentmenu)
				if click in (2, 8, 16384):
					
					s = self.menu_exec()
					if s == 0:
						self.refresh_windows()
						self.showmenu = False
						self.currentmenu = None
					elif s == 3:
						self.showmenu = False
						self.currentmenu = None
		else:
			self.showmenu = False
			self.currentmenu = None
			self.refresh_menu()

	def menu_enter(self):
		s = self.menu_exec()
		if s == 0:
			self.refresh_windows()
			self.showmenu = False
			self.currentmenu = None
		elif s == 3:
			self.showmenu = False
			self.currentmenu = None
		else:
			self.draw_menu(self.currentmenu)
		#self.menu()
		
	def refresh_menu(self):
		#self.menu()
		self.refresh_windows()
		
	def menu_clear(self):
		self.showmenu = False
		self.currentmenu = None
		self.refresh_menu()
		
	def menu_exec(self):
		try:
			num = self.menunumber
			if self.currentmenu in ("roombox", "lists", "transfers", "search", "browse-dirs", "browse-files"):
				if self.currentmenu == "roombox":
					username = self.roomboxlist[self.current_room][self.Sup]
				elif self.currentmenu == "lists":
					username = self.find_menu()[self.Sup][1]
				elif self.currentmenu == "transfers":
					the_list = self.find_menu()
					item_num = self.Sup
					username = the_list[item_num][1] 
					
					path = the_list[item_num][2]
					userpath = (username, path)
					transfer = self.get_transfer_number(the_list)
					if transfer == None:
						return
					if num == 0:
						# RETRY DOWNLOAD
						if self.transferscroll != "download":
							return 1
						if transfer in self.down_transfer_numbers.keys():
							for username, path in self.down_transfer_numbers[transfer].items():
								self.Hlog("status", "Retrying download: [%s] %s" % (username, path))
								self.send(messages.DownloadFile(username, path))
						else:
							self.Hlog("status", "No such transfer #" + str(transfer))
						return 0
					elif num == 1:
						# RETRY ALL DOWNLOADS
						if self.transferscroll != "download":
							return 1
						for user_path, transfer  in self.transfers["downloads"].items():
							if int(transfer[3]) in (10, 11, 12, 13, 14):
								self.send(messages.DownloadFile(transfer[1], transfer[2]))
						return 0
					elif num == 2:
						# ABORT TRANSFER
						if self.transferscroll == "download":
							if transfer in self.down_transfer_numbers.keys():
								for username, path in self.down_transfer_numbers[transfer].items():
									self.Hlog("status", "Aborting download: [%s] %s" % (username, path))
									self.send(messages.TransferAbort(0, username, path))
							else:
								self.Hlog("status", "No such transfer #" + str(transfer))
						elif self.transferscroll == "upload":
							if transfer in self.up_transfer_numbers.keys():
								for username, path in self.up_transfer_numbers[transfer].items():
									self.Hlog("status", "Aborting upload: [%s] %s" % (username, path))
									self.send(messages.TransferAbort(1, username, path))
							else:
								self.Hlog("status", "No such transfer #" + str(transfer))
						return 0
					elif num == 3:
						# ABORT USER's TRANSFER(s)
						if self.transferscroll == "download":
							for userpath, values in self.transfers["downloads"].items():
								if userpath[0] == username:
									self.Hlog("status", "Aborting download: [%s] %s" % (username, values[2]))
									self.send(messages.TransferAbort(0, username, values[2]))
	
						elif self.transferscroll == "upload":
							for userpath, values in self.transfers["uploads"].items():
								if userpath[0] == username:
									self.Hlog("status", "Aborting upload: [%s] %s" % (username, values[2]))
									self.send(messages.TransferAbort(1, username, values[2]))
	
						return 0
					elif num == 4:
						# Clear
						if self.transferscroll == "download":
							if transfer in self.down_transfer_numbers.keys():
								for username, path in self.down_transfer_numbers[transfer].items():
									self.Hlog("status", "Removing download: [%s] %s" % (username, path))
									self.send(messages.TransferRemove(0, username, path))
							else:
								self.Hlog("status", "No such transfer #" + str(transfer))
							
						elif self.transferscroll == "upload":
							if transfer in self.up_transfer_numbers.keys():
								for username, path in self.up_transfer_numbers[transfer].items():
									self.Hlog("status", "Removing upload: [%s] %s" % (username, path))
									self.send(messages.TransferRemove(1, username, path))
							else:
								self.Hlog("status", "No such transfer #" + str(transfer))
						return 0
					elif num == 5:
						# Clear ALL FINISHED/FAILED
						if self.transferscroll == "download":
							for userpath, values in self.transfers["downloads"].items():
								if values[3] == 0:
									self.send(messages.TransferRemove(0, values[1], values[2]))
						elif self.transferscroll == "upload":
							for userpath, values in self.transfers["uploads"].items():
								if values[3] in (0, 10, 11, 12, 13, 14):
									self.send(messages.TransferRemove(1, values[1], values[2]))
						return 0
					elif num == 6:
						# Clear USER's Transfers
						if self.transferscroll == "download":
							for userpath, values in self.transfers["downloads"].items():
								if userpath[0] == username:
									self.send(messages.TransferRemove(0, values[1], values[2]))
						elif self.transferscroll == "upload":
							for userpath, values in self.transfers["uploads"].items():
								if userpath[0] == username:
									self.send(messages.TransferRemove(1, values[1], values[2]))
						return 0
					elif num == 7:
						return 1
					else:
						num -=8
				elif self.currentmenu == "search":
					the_list = self.find_menu()
					
					number = the_list[self.Sup-self.window_dimensions["search"]["start"]]
					#self.Hlog("status", number)
					username = self.search_results[number][1]
					path = self.search_results[number][5]
					
					userpath = (username, path)
					
					if num == 0:
						# Download
						self.download_path_file("file", number)
						return 0
					elif num == 1:
						# Download Dir
						self.download_path_file("dir", number)
						return 0
					elif num == 2:
						self.Hlog("status", "[%d] %s" % (number, path))
						return 0
					elif num == 3:
						# Line
						return 1
					else:
						num -= 4
				elif self.currentmenu in ("browse-dirs", "browse-files"):
					the_list = self.find_menu()
					username = self.browse_current

					path = self.browse_current_dir
					
					userpath = (username, path)
					
					if self.browse_scroll == "directories":
						number = self.Sup-self.window_dimensions["directories"]["start"]
						if num == 0:
							# Download
							self.download_path_file("dir", number)
							return 0
						elif num == 1:
							self.Hlog("status", "[%d] %s" % (number, path))
							return 0
						else:
							num -= 2
					if self.browse_scroll == "files":
						number = self.Sup
						if num == 0:
							# Download
							self.download_path_file("file", number)
							return 0
						elif num == 1:
							# Download Dir
							self.download_path_file("dir", number)
							return 0
					
						elif num == 2:
							self.Hlog("status", "[%d] %s" % (number, path))
							return 0
						else:
							num -= 3
	
					if num == 0:
						return 1
					else:
						num -=1
				if num == 0:
					self.start_pm(username)
					self.private_mode()
				elif num == 1:
					self.info_requested.append( username)
					self.send(messages.UserInfo(username))
					self.info_mode()
				elif num == 2:
					self.ip_requested = username
					self.send(messages.PeerAddress(self.ip_requested))
					self.info_mode()
				elif num == 3:
					self.start_browse(username)
				elif num == 4:
					return 1
				elif num == 5:
					if username not in self.config["buddies"].keys():
						self.mod_config("buddy", username, '')
					else:
						self.mod_config("unbuddy", username, '')
					return 1
				elif num == 6:
					if username not in self.config["banned"].keys():
						self.mod_config("ban", username, '')
					else:
						self.mod_config("unban", username, '')
					return 1
				elif num == 7:
					if username not in self.config["ignored"].keys():
						self.mod_config("ignore", username, '')
					else:
						self.mod_config("unignore", username, '')
					return 1
				elif num == 8:
					if username not in self.config["trusted"].keys():
						self.mod_config("trust", username, '')
					else:
						self.mod_config("distrust", username, '')
					return 1
				elif num == 9:
					self.privuser = username
					self.set_edit_title( "% Give Privileges to " + self.privuser)
				elif num == 10:
					self.send(messages.TransferUpdate(username, path) )
			elif self.currentmenu == "encoding":
				if num == 0: coding = "UTF-8"
				elif num == 1: coding = "iso-8859-1"  
				elif num == 2: coding = "iso-8859-2"  
				elif num == 3: coding = "iso-8859-3"  
				elif num == 4: coding = "iso-8859-4"  
				elif num == 5: coding = "iso-8859-5"  
				elif num == 6: coding = "iso-8859-6"  
				elif num == 7: coding = "iso-8859-7" 
				elif num == 8: coding = "iso-8859-8"  
				elif num == 9: coding = "iso-8859-9"  
				elif num == 10: coding = "iso-8859-10"  
				elif num == 11: coding = "iso-8859-11"  
				elif num == 12: coding = "iso-8859-13" 
				elif num == 13: coding = "iso-8859-14" 
				elif num == 14: coding = "iso-8859-15"  
				elif num == 15: coding = "iso-8859-16" 
				elif num == 16: coding = "KIO8-R" 
				elif num == 17: coding = "CP1250" 
				elif num == 18: coding = "CP1251" 
				elif num == 19: coding = "CP1252" 
				elif num == 20: coding = "CP1253" 
				elif num == 21: coding = "CP1254" 
				elif num == 22: coding = "CP1255" 
				elif num == 23: coding = "CP1256" 
				elif num == 24: coding = "CP1257" 
				elif num == 25: coding = "CP1258"
				elif num == 26: coding = "CP874" 
				#self.Hlog("debug", coding)
				if self.DisplayMode == "chat":
					self.send(messages.ConfigSet("encoding.rooms", self.current_room, coding))
				elif self.DisplayMode == "private":
					self.send(messages.ConfigSet("encoding.users", self.pm_user, coding))
				elif self.DisplayMode == "browse":
					if self.browse_current != "default__":
						self.send(messages.ConfigSet("encoding.users", self.browse_current, coding))
					else:
						self.send(messages.ConfigSet("encoding", "filesystem", coding))
					
			return 0
		except Exception, e:
			self.Hlog("debug", "menu_exec " +str(e))

	def refresh_windows(self):
		
		try:
			if self.DisplayMode =="transfer":
				if mucous_config["mucous"]["transbox"]=="split":
					self.transwin2.redrawwin()
					self.transwin2.refresh()
					self.transwin.redrawwin()
					self.transwin.refresh()
				else:
					if self.transferscroll == "download":
						self.transwin.redrawwin()
						self.transwin.refresh()
					elif self.transferscroll == "upload":
						self.transwin2.redrawwin()
						self.transwin2.refresh()
			elif self.DisplayMode =="chat":
				self.Mwin.redrawwin()
				self.Mwin.refresh()
				self.textwin.redrawwin()
				self.textwin.refresh()
				if self.chatdisplaymode !=  "nostatuslog":
					self.logwin.redrawwin()
					self.logwin.refresh()
					self.borderlogwin.redrawwin()
					self.borderlogwin.refresh()
				if self.chatdisplaymode not in ( "noroombox", "chat-only"):
					self.roomstatusborderwin.redrawwin()
					self.roomstatusborderwin.refresh()
					
			elif self.DisplayMode =="browse":
				self.browse_redraw()
				self.browse_display()
				curses.doupdate()
			else:
				self.Mwin.redrawwin()
				self.Mwin.refresh()
				self.textwin.redrawwin()
				self.textwin.refresh()
				
			self.inputwin.redrawwin()
			self.inputwin.refresh()
		except Exception,e:
			self.Hlog("debug", "Refresh Windows: "+str(e))
		
	def math_transfer_window(self, w, event, x, y, up):
		if y >= w["top"]+1 and y < w["top"] + w["height"] and x >= w["left"] and x < w["left"] +w["width"]:
						
			y -= w["top"] +1
			
			if y  + w["start"] in range(len( self.get_transfers_list() )):
				self.Sup = y  + w["start"]

			
			if self.transferscroll == "download":
				self.download_manager()
				curses.doupdate()
			else:
				self.upload_manager()
				curses.doupdate()
			if event in ( 4096, 16384):
				if self.get_transfers_list() != []:
					self.showmenu = True
					self.create_menu("transfers", 0)
			return 1
		elif y == w["top"] + w["height"]:
			if x >=2 and x < 18:
				if mucous_config["mucous"]["transbox"]=="split":
					mucous_config["mucous"]["transbox"]="tabbed"
				elif mucous_config["mucous"]["transbox"]=="tabbed":
					mucous_config["mucous"]["transbox"]="split"
				self.transfer_mode()
				return
			elif x >= 20:
				if x >=20 and x < 28:
					self.transfer_display_mode = 'all'
				elif x >=28 and x < 39:
					self.transfer_display_mode = 'active'
				elif x >=39 and x < 50:
					self.transfer_display_mode = 'queued'	
				elif x >=50 and x < 58:
					self.transfer_display_mode = 'finished'
				elif x >=63 and x < 75:
					self.transfer_display_mode = 'failed'
				self.transfer_mode()
				return 1
		return 0
				
	def tab_click(self, x, chosen):
		try:
			choz = self.tab_positions[chosen]
			match = None
			if x >= choz[0] and x < choz[1]:
				# do nothing if chose search is clicked
				return chosen, 'yes'
			else:
				for key, pos in self.tab_positions.items():
					if x >= pos[0]   and x < pos[1] :
						match = 'yes'
						break
			if match != None:
				return key, match
			else:
				return chosen, None
		except Exception, e:
			self.Hlog("debug", "tab_click: " +str(e) )
			
	def key_mouse_funks(self, key, line):
		try:
			if key == "KEY_RESIZE":
				self.line = line 
				self.stdscr.keypad(1)
				self.build()
				
			elif key in ("KEY_UP",  "KEY_DOWN", "KEY_PPAGE", "KEY_NPAGE"):
				if self.showmenu == True:
					if key =="KEY_UP":
						key = "menu_up"
					elif key =="KEY_DOWN":
						key = "menu_down"
				else:
					self.key = key
					sline = self.scrolltext(line)
					#self.Hlog("debug", "scrolltext"+str(sline))
					if sline != None:
						line = sline
	
			elif key == "KEY_F(1)":
				if self.DisplayMode != "chat": self.chat_mode()
				return
			elif key == "KEY_F(2)":
				if self.DisplayMode != "private": self.private_mode()
				return
			elif key == "KEY_F(3)":
				if self.DisplayMode != "transfer": self.transfer_mode()
				return
			elif key == "KEY_F(4)":
				if self.DisplayMode != "search": self.search_mode()
				return
			elif key == "KEY_F(5)":
				if self.DisplayMode != "info": self.info_mode()
				return
			elif key == "KEY_F(6)":
				if self.DisplayMode != "browse": self.browse_mode()
				return
			elif key == "KEY_F(7)":
				if self.DisplayMode != "lists": self.list_mode()
				return
			elif key == "KEY_F(8)":
				if self.DisplayMode != "rooms": self.rooms_mode()
				return
			elif key == "KEY_F(9)":
				if self.DisplayMode != "setup": self.setup_mode()
				return
			elif key == "KEY_F(10)":
				if self.DisplayMode not in ("help", "debug", "status") : self.help_mode()
				return
			elif key == chr(10) or key == "KEY_ENTER":
				if line not in self.historylog and line !='':
					self.historylog.append(line)
			elif key in ("popup"):
				if self.showmenu == True:
					self.menu_clear()
				else:
					self.showmenu = True
					if self.DisplayMode == "chat":
						if self.chatdisplaymode not in ( "noroombox", "chat-only"):
							self.create_menu("roombox", 0)
						else:
							return
					elif self.DisplayMode == "lists":
						self.create_menu("lists", 0)
					elif self.DisplayMode == "transfer":
						self.create_menu("transfers", 0)
					elif self.DisplayMode == "search":
						if self.chosen_search != "default__":
							self.create_menu("search", 0)
					elif self.DisplayMode == "browse":
						
						if self.browse_current != "default__":
							if self.browse_scroll == "files":
								self.create_menu("browse-files", 0)
							elif self.browse_scroll == "directories":
								self.create_menu("browse-dirs", 0)
			 
			elif key in ("switch", "KEY_HOME", "KEY_END"):
				if self.DisplayMode == "transfer":
					# Tab to switch between upload and download scrolling
					if self.transferscroll == "upload":
						self.transferscroll="download"
						self.Sup =0
					elif self.transferscroll=="download":
						self.transferscroll="upload"
						self.Sup =0
					self.transfer_mode()
				
				elif self.DisplayMode == "chat":
					if key in ("switch"):
						if self.chatroomscroll == "roomchat":
							if self.chatdisplaymode not in ( "noroombox", "chat-only"):
								self.Sup =0
								self.chatroomscroll = "roombox"
						elif self.chatroomscroll == "roombox":
							self.chatroomscroll = "roomchat"
							self.Sup = -1
 						self.chat_mode()
						
					elif key == "KEY_END":
						if self.chatroomscroll == "roomchat":
							self.Sup = -1
							self.chat_display()
						elif self.chatroomscroll == "roombox":
							self.Sup = len(self.rooms[self.current_room])
	 						self.chat_mode()
					elif key == "KEY_HOME":
						if self.chatroomscroll == "roomchat":
							self.Sup = 0 
							self.chat_display()
						elif self.chatroomscroll == "roombox":
							self.Sup = 0
							self.chat_mode()
						
					
				elif self.DisplayMode == "search":
					# Hotkeys to switch types of searches
					if self.search_type == "globally":
						self.search_type = "buddies"
					elif self.search_type == "buddies":
						self.search_type = "rooms"
					elif self.search_type == "rooms":
						self.search_type = "globally"
					self.search_mode()
				elif self.DisplayMode == "browse":	
					if self.browse_scroll == "files":
						self.browse_scroll = "directories"
					elif self.browse_scroll == "directories":
						self.browse_scroll = "files"
					self.browse_mode()
			elif key == "KEY_MOUSE":
				(id,x,y,z,event)=curses.getmouse()
				#self.Hlog("debug", "%d %d %d %d %d" % (id, x, y, z,event))
				if event in (1, 128, 8192):
					# Ignore PRESSED and RELEASED
					return
				if x in range(8) and y == 0:
					if self.connected == 0:
						self.connect()
					elif self.connected == 1:
						self.toggle_away()
					return
	# 1Chat 2Private 3Transfers 4Search 5Info 6Browse 7Users 8Rooms 9Setup 10Help
				if y >= self.h-1:
					# clickable mode switching
					if x >= 0 and x < 7:
						self.chat_mode()
					elif x >= 7 and x < 16:
						self.private_mode()
					elif x >= 16 and x < 27:
						self.transfer_mode()
					elif x >= 27 and x < 35:
						self.search_mode()
					elif x >= 35 and x < 41:
						self.info_mode()
					elif x >= 41 and x < 49:
						self.browse_mode()
					elif x >= 49 and x < 56:
						self.list_mode()
					elif x >= 56 and x < 63:
						self.rooms_mode()
					elif x >= 63 and x < 70:
						self.setup_mode()
					elif x >= 70 and x < 76:
						self.help_mode()
						
				if self.showmenu == True and self.currentmenu != None:
					width = self.menus[self.currentmenu]["width"]
					top = self.menus[self.currentmenu]["top"]
					height = self.menus[self.currentmenu]["height"]
					left = self.menus[self.currentmenu]["left"]
					if x >= left and x < left+width and y >= top and y < top+height:
						self.pick_menu_item(x, y, event)
						return
					else:
						self.menu_clear()
	
				if self.DisplayMode == "chat":
					w = self.window_dimensions["chat"]
					if y == w["top"]-1 and x >= w["left"]-1 and x < w["left"]+3:
						self.chat_room_cycle()
						return
					# Clickable room switch
					
					if "roombox" in self.window_dimensions and self.chatdisplaymode not in ( "noroombox", "chat-only"):
						roombox = self.window_dimensions["roombox"]
						if y >= roombox["top"] and y < roombox["top"] + roombox["height"] and x < roombox["width"] + roombox["left"] and x > roombox["left"]:
							if self.chatroomscroll != "roombox":
								self.chatroomscroll = "roombox"
								self.chat_mode()
							y -= roombox["top"]
							if "start" not in roombox:
								return
							if y  + roombox["start"] in range(len(self.roomboxlist[self.current_room])):
								
								sup = y  + roombox["start"]
								if event in ( 4096, 16384):
									if sup != self.Sup:
										self.Sup = sup
									self.roomstatusbox()
									
									self.showmenu = True
									self.create_menu("roombox", 0)
									curses.doupdate()
								else:
									if sup != self.Sup:
										self.Sup = sup
										self.roomstatusbox()
										curses.doupdate()
							return
								
					if y == self.h-3 or y == self.h-4:
						if x>= self.w-27 and x < self.w-18:
							self.showmenu = True
							self.create_menu("encoding", 0)
						
						elif x >= self.w-17 and x < self.w-1:
							joined = self.rooms.keys()
							joined.sort()
							if not self.current_room in joined:
								ix = 0
							else:
								ix = joined.index(self.current_room)
								
								if x >= self.w-9 and x < self.w-1:
									# Next Button
									ix += 1
								elif x <= self.w-10 and x >= self.w-17:
									# Prev Button
									ix -= 1
								else:
									return
								if ix < 0:
									ix = -1
								elif ix >= len(joined):
									ix = 0
							self.set_room(joined[ix])
							
					elif y  in (w["top"] + w["height"], w["top"] + w["height"]-1) and x >= w["left"] + w["width"]-5 and x <= w["left"] + w["width"]:
						self.key = "KEY_NPAGE"
						self.scrolltext(line)
						
					elif y in ( w["top"], w["top"]+1)  and x >= w["left"] + w["width"]-5 and x <= w["left"] + w["width"]:
						self.key = "KEY_PPAGE"
						self.scrolltext(line)
					else:
						if y >= w["top"]-1 and y < w["top"] + w["height"] +1 and x >= w["left"] -1 and x < w["left"] +w["width"]+1:
							if self.chatroomscroll != "roomchat":
								self.chatroomscroll = "roomchat"
								self.chat_mode()
							
					
				elif self.DisplayMode == "private":
					# Clickable private message switch
					if self.pm_user != None:
						if y in (2, 3, 4):
							if len(self.privatelog.keys()) > 1:
								pmusers =  self.privatelog.keys()
								pmusers.sort()
								self.pm_user, match = self.tab_click(x, self.pm_user)
								if match == None:
									s = pmusers.index(self.pm_user)
									self.pm_user = pmusers[s-1]
								self.start_pm(self.pm_user)
								self.private_mode()
								
						if y == self.h-3 or y == self.h-4:
							if x>= self.w-27 and x < self.w-18:
								self.showmenu = True
								self.create_menu("encoding", 0)
							elif x >=self.w-10 and x < self.w-1:
								self.close_private_chat(self.pm_user)
								
				elif self.DisplayMode == "browse":
					d = self.window_dimensions["directories"]
					w = self.window_dimensions["browse"]
					if y in (1, 2, 3):
						if len(self.browsed) >= 1:
							
							if self.browse_current == "default__":
								self.browse_current = self.browsed[0]
							else:
								self.browse_current, match = self.tab_click(x, self.browse_current)
								if match == None:
									s = self.browsed.index(self.browse_current)
									self.browse_current = self.browsed[s-1]
								sdirs =  self.browse_list_results[self.browse_current].keys()
								sdirs.sort()
								self.browse_current_dir=sdirs[0]
							
							self.browse_mode()
					
					elif y == w["top"]-1:
						if x >=self.w-17 and self.browse_current != "default__":
							self.browse_current="default__"
							self.browse_mode()
					elif x in range(d["width"]) and y >= d["top"] and y <= d["top"] + d["height"]:
						if self.browse_current == "default__":
							return
						if self.browse_scroll != "directories":
							self.browse_scroll = "directories"
							self.browse_redraw()
							
						self.Sup = y - d["top"] + d["start"]
						self.browse_display()
						
						if event in ( 4096, 16384):
							self.roomstatusbox()
							self.showmenu = True
							self.create_menu("browse-dirs", 0)
						else:
							self.roomstatusbox()
						curses.doupdate()
						
					elif x >=  w["left"] and y >= w["top"] and y <= w["top"] + w["height"]:
						if self.browse_current == "default__":
							return
						if self.browse_scroll != "files":
							self.browse_scroll = "files"
							self.browse_redraw()
						self.Sup = y - w["top"]+ w["start"]
						self.browse_display()
						
						if event in ( 4096, 16384):
							self.roomstatusbox()
							self.showmenu = True
							self.create_menu("browse-files", 0)
						else:
							self.roomstatusbox()
						curses.doupdate()
						
					elif y in ( self.h-5, self.h-6):
						if x>= self.w-27 and x < self.w-18:
							self.showmenu = True
							self.create_menu("encoding", 0)
							return
						elif x >=self.w-10 and x < self.w-1 and self.browse_current != "default__":
							self.close_browse(self.browse_current)
							
								
				elif self.DisplayMode == "info":
					# Clickable user info tabs
					
					if y in (2, 3, 4):
						if len(self.info_users) >= 1:
							
							if self.info_user == None:
								self.info_user = self.info_users[0]
							self.info_user, match = self.tab_click(x, self.info_user)
							if match == None:
								s = self.info_users.index(self.info_user)
								self.info_user = self.info_users[s-1]
							#self.display_userinfo_log()
							self.info_mode()
							
					if self.info_user != None:
						if y  in (5,6):
							if x >=self.w-19-2-16 and x < self.w-12:
								self.info_user=None
								self.info_mode()
						elif y in ( self.h-3, self.h-4, self.h-5):
							if x >=self.w-10 and x < self.w-1:
								self.close_userinfo(self.info_user)
				
				elif self.DisplayMode == "search":
					w = self.window_dimensions["search"]
					if self.chosen_search != "default__":
						if y >= w["top"] and y < w["top"] + w["height"] and x >= w["left"] and x < w["left"] +w["width"]:
							#self.Hlog("debug", "%d:%d::%d" %(x,y,w["top"]) )
							y1 = y- w["top"]
							
							if y1  + w["start"] in range(self.search_number):
								self.Sup  = y1  + w["start"]
								self.search_display()
								if event in ( 4096, 16384):
									self.showmenu = True
									self.create_menu("search", 0)
									return

					if y in (1, 2, 3):
						if len(self.s_query.keys()) >= 1:
							
							
							if self.chosen_search == "default__":
								self.chosen_search = self.s_query.keys()[0]

							self.chosen_search, match = self.tab_click(x, self.chosen_search)	
								
							if match == None:
								s = self.s_query.keys().index(self.chosen_search)
								self.chosen_search = self.s_query.keys()[s-1]
							self.search_mode()
	
					elif y in ( self.h-3, self.h-4):
						if x >= 10 and x <= 20:
							# Toggle type of search
							if self.search_type == "globally":
								self.search_type = "buddies"
							elif self.search_type == "buddies":
								self.search_type = "rooms"
							elif self.search_type == "rooms":
								self.search_type = "globally"
							self.search_mode()
							
					elif y in ( self.h-5, self.h-6):
#m< Num|User|Free|Speed|Que|Path|Size|File|Bitrate|Time >< Reverse >

						change = 0
						if x >= 2 and x <= 6 and self.search_format != "num":
							self.search_format = "num"
							change = 1
						elif x >= 7 and x <= 11 and self.search_format != "user":
							self.search_format = "user"
							change = 1
						elif x >= 12 and x <= 16  and self.search_format != "free":
							self.search_format = "free"
							change = 1
						elif x >= 17 and x <= 22  and self.search_format != "speed":
							self.search_format = "speed"
							change = 1
						elif x >= 23 and x <= 26  and self.search_format != "que":
							self.search_format = "que"
							change = 1
						elif x >= 27 and x <= 31  and self.search_format != "path":
							self.search_format = "path"
							change = 1
						elif x >= 33 and x <= 36  and self.search_format != "size":
							self.search_format = "size"
							change = 1
						elif x >= 37 and x <= 41  and self.search_format != "file":
							self.search_format = "file"
							change = 1
						elif x >= 42 and x <= 49  and self.search_format != "bitrate":
							self.search_format = "bitrate"
							change = 1
						elif x >= 50 and x <= 54  and self.search_format != "time":
							self.search_format = "time"
							change = 1
						elif x >= 56 and x <= self.w-10:
							if self.search_reverse == True:
								self.search_reverse = False
							elif self.search_reverse == False:
								self.search_reverse= True
							change = 1
						elif x >=self.w-10 and x < self.w-1:
							self.close_search(self.chosen_search)
						if change == 1:
							self.search_mode()
					
					elif y == 4:
						if self.chosen_search != "default__":
							if x >=self.w-18:
								self.chosen_search="default__"
								self.search_mode()
	
				elif self.DisplayMode == "rooms":
					# ROOMLIST BUTTONS
					if y == self.h-5:
						if x >= 14 and x <= 22:
							mucous_config["mucous"]["rooms_sort"] = "alpha"
							self.rooms_mode()
						elif x >= 24 and x <= 35:
							mucous_config["mucous"]["rooms_sort"] = "alpha-reversed"
							self.rooms_mode()
						elif x >= 37 and x <= 46:
							mucous_config["mucous"]["rooms_sort"] = "size"
							self.rooms_mode()
						elif x >= 47 and x <= 56:
							mucous_config["mucous"]["rooms_sort"] = "size-reversed"
							self.rooms_mode()
						elif x >= self.w-16:
							self.send(messages.RoomList())
							
					w = self.window_dimensions["rooms"]
					if y >= w["top"] and y < w["top"] + w["height"] and x >= w["left"] and x < w["left"] +w["width"]:
						y -= w["top"]
						if y  + w["start"] in range(len(self.sizedrooms)):
							self.Sup  = y  + w["start"]
							self.display_room_list_mode()
							return self.sizedrooms[self.Sup]
	
							
				elif self.DisplayMode == "lists":
					w = self.window_dimensions[self.display_which_list]
					if y == 1:
						if x >= 3 and x <= 10:
							self.display_which_list="buddies"
							self.list_mode()
						elif x >= 13 and x <= 24:
							self.display_which_list="banned"
							self.list_mode()
						elif x >= 26 and x <= 33:
							self.display_which_list="ignored"
							self.list_mode()
						elif x >= 35 and x <= 50:
							self.display_which_list="interests"
							self.list_mode()
					
					elif y >= w["top"] and y < w["top"] + w["height"] and x >= w["left"] and x < w["left"] +w["width"]:
						y -= w["top"]
						
						if self.display_which_list=="buddies":
							this_list = self.buddylog
						elif self.display_which_list=="banned":
							this_list = self.banlog
						elif self.display_which_list=="ignored":
							this_list = self.ignorelog
						if y  + w["start"] in range(len(this_list)):
							self.Sup  = y  + w["start"]
							
							if event in ( 4096, 16384):
								self.display_lists()
								self.showmenu = True
								self.create_menu("lists", 0)
							else:
								self.display_lists()
							
							
				elif self.DisplayMode == "transfer":
					# TRANSFERS BUTTONS
					# Clickable transfer type switcher
					up = self.Sup
					if mucous_config["mucous"]["transbox"]=="split":
						u = self.window_dimensions["uploads"]
						d = self.window_dimensions["downloads"]
						
						w = None
						
						if y >= u["top"]+1 and y <= u["top"] + u["height"] and x >= u["left"] and x < u["left"] +u["width"]:
							if self.transferscroll != "upload":
								self.transferscroll = "upload"
								self.transfer_mode()
							w = u
							#y -= w["top"]+1
						elif y >= d["top"]+1 and y <= d["top"] + d["height"] and x >= d["left"] and x < d["left"] +d["width"]:
							if self.transferscroll != "download":
								self.transferscroll = "download"
								self.transfer_mode()
							w = d
	
						if w != None:
							r = self.math_transfer_window(w, event, x, y, up)
							if r == 1:
								return
	
					else:
						if y == 1:
							if x >=2 and x < 26:
								self.transferscroll="upload"
							elif x >=27 and x < 40:	
								self.transferscroll="download"
							self.transfer_mode()
							return
							
						if self.transferscroll == "upload":
							w = self.window_dimensions["uploads"]
						else:
							w = self.window_dimensions["downloads"]
						r = self.math_transfer_window(w, event, x, y, up)
						if r == 1:
							return	
		
				elif self.DisplayMode == "setup":
					if y in (0, 1):
						if x >=1 and x <=12:
							self.setup_display_mode="mucous"
						elif x >=16 and x <=26:
							self.setup_display_mode="museek"
						elif x >=31 and x <=41:
							self.setup_display_mode="shares"
						elif x >=46 and x <=57:
							self.setup_display_mode="userinfo"
						elif x >=60 and x <=69:
							self.setup_display_mode="logs"
						self.setup_mode()
						
					if self.setup_display_mode=="shares":
						if y in ( 3, 4, 5):
							if x >= 1 and x <= 16:
								self.muscan_command = ["muscan", "-v", "-r"]
								self.muscan_timer.cancel()
								self.muscan_timer = threading.Timer(1.0, self.muscan_display)
								self.muscan_timer.start()
								self.Hlog("status", "Rescanning shares with muscan, don't forget to Reload them.")
							elif x >= 17 and x <= 29:
							
								self.muscan_command = ["muscan", "-v"]
								self.muscan_timer.cancel()
								self.muscan_timer = threading.Timer(1.0, self.muscan_display)
								self.muscan_timer.start()
								self.Hlog("status", "Updating shares with muscan, don't forget to Reload them.")
							elif x >= 33 and x <= 49:
								self.send(messages.ReloadShares())
	
						if y in ( 6, 7, 8):
							if x >= 1 and x <= 16:
								self.muscan_command = ["muscan",  "-l"]
								self.muscan_timer.cancel()
								self.muscan_timer = threading.Timer(1.0, self.muscan_display)
								self.muscan_timer.start()
								self.Hlog("status", "Listing shares with muscan.")
							elif x >= 17 and x <= 29:
								self.setup_input_mode="adddir"
								self.setup_mode()
							elif x >= 33 and x <= 49:
								self.setup_input_mode="rmdir"
								self.setup_mode()
					elif self.setup_display_mode=="userinfo":
						if y >= 1 and y < self.h-7:
							self.setup_input_mode="userinfo"
						elif y <= self.h-5 and y >= self.h-7:
							self.setup_input_mode="userimage"
						self.setup_mode()
					elif self.setup_display_mode=="logs":
						if y >= 2 and y <= 4 and x < 17:
							self.logging_toggle()
							self.setup_mode()
						
							
					elif self.setup_display_mode in ("museek", "mucous"):
						
						if y in (2, 3, 4):
							
							if x >=1 and x <=35:
								if self.setup_display_mode=="museek":
									self.setup_input_mode="server-host"
								elif self.setup_display_mode=="mucous":
									self.setup_input_mode="interface"
									self.setup_mode()

							elif x >=36 and x <=64:
								if self.setup_display_mode=="museek":
									self.setup_input_mode="soulseek-username"
									self.setup_mode()
									

						elif y in (5, 6, 7):
							if self.setup_display_mode=="museek":
								if x >=36 and x <=64:
									self.setup_input_mode="soulseek-password"
								elif x >=1 and x <=35:	
									self.setup_input_mode="museek-interface-password"
								self.setup_mode()
							elif self.setup_display_mode=="mucous":
								if x >=1 and x <=35:
									self.setup_input_mode="interface-password"
								self.setup_mode()
						elif y in (8, 9, 10):
							if x >=1 and x <=16:
								#Buddies-only
								if self.setup_display_mode=="museek":
									if "transfers" in self.config:
										if self.config["transfers"]["only_buddies"] == "true":
											self.send(messages.ConfigSet("transfers", "only_buddies", "false"))
										elif self.config["transfers"]["only_buddies"] == "false":
											self.send(messages.ConfigSet("transfers", "only_buddies", "true"))
								elif self.setup_display_mode=="mucous":
									if mucous_config["tickers"]["tickers_enabled"] == 'no':
										mucous_config["tickers"]["tickers_enabled"] = 'yes'
										
									elif mucous_config["tickers"]["tickers_enabled"] == 'yes':
										mucous_config["tickers"]["tickers_enabled"] = 'no'
									self.setup_mode()
									
									
	
							elif x >=17 and x <=31:
								if self.setup_display_mode=="museek":
									#buddy-privs
									if "transfers" in self.config:
										if self.config["transfers"]["privilege_buddies"] == "true":
											self.send(messages.ConfigSet("transfers", "privilege_buddies", "false"))
												
										elif self.config["transfers"]["privilege_buddies"] == "false":
											self.send(messages.ConfigSet("transfers", "privilege_buddies", "true"))
								elif self.setup_display_mode=="mucous":
									# Minimum size of rooms displayed in room list
									if x >=17 and x <=23:
										mucous_config["mucous"]["roomlistminsize"] -= 1
									elif x >=24 and x <=31:
										mucous_config["mucous"]["roomlistminsize"] += 1
									if mucous_config["mucous"]["roomlistminsize"] < 1:
										mucous_config["mucous"]["roomlistminsize"] = 1
									self.setup_mode()
							elif x >=32 and x <=47:
								
								if self.setup_display_mode=="museek":
									# Connect Mode
									if "clients" in self.config:
										if self.config["clients"]["connectmode"] == "passive":
											self.send(messages.ConfigSet("clients", "connectmode", "active"))
										elif self.config["clients"]["connectmode"] == "active":
											self.send(messages.ConfigSet("clients", "connectmode", "passive"))
								elif self.setup_display_mode=="mucous":
									# Toggle Autobuddy
									if mucous_config["mucous"]["autobuddy"]  == "yes":
										mucous_config["mucous"]["autobuddy"] = "no"
			
									elif mucous_config["mucous"]["autobuddy"]  == "no":
										mucous_config["mucous"]["autobuddy"] = "yes"
									self.setup_mode()
							elif x >=47 and x <=62:
								if self.setup_display_mode=="museek" and "transfers" in self.config:
									
									s = int(self.config["transfers"]["upload_slots"]) 
									if x >=47 and x <=53:
										s  -= 1
									elif x >=53 and x <=62:
										s  += 1
									if s < 0:
										s = 0
									s = str(s)
									self.send(messages.ConfigSet("transfers", "upload_slots", s))
									self.setup_mode()
									
								if self.setup_display_mode=="mucous":
									if mucous_config["mucous"]["Auto-Retry"] == "True":
										mucous_config["mucous"]["Auto-Retry"] = "False"
										self.retry_timer.cancel()
									elif mucous_config["mucous"]["Auto-Retry"] == "False":
										mucous_config["mucous"]["Auto-Retry"] ="True"
										self.retry_timer.cancel()
										self.retry_timer = threading.Timer(30.0, self.retry_display)
										self.retry_timer.start()
									self.setup_mode()
									
	
										
											
									
						elif y in (11, 12, 13, 14):
							if self.setup_display_mode=="mucous" and "transfers" in self.config:
								if x >=1 and x <=16:
									
									if mucous_config["tickers"]["ticker_cycle"] == 'no':
										mucous_config["tickers"]["ticker_cycle"] = 'yes'
										
									elif mucous_config["tickers"]["ticker_cycle"] == 'yes':
										mucous_config["tickers"]["ticker_cycle"] = 'no'
									self.setup_mode()
								elif x >=17 and x <=32:
									if mucous_config["mucous"]["url reader"] == 'lynx':
										mucous_config["mucous"]["url reader"] = 'links'
									elif mucous_config["mucous"]["url reader"] == 'links':
										mucous_config["mucous"]["url reader"] = 'elinks'
									elif mucous_config["mucous"]["url reader"] == 'elinks':
										mucous_config["mucous"]["url reader"] = 'firefox'
									elif mucous_config["mucous"]["url reader"] == 'firefox':
										mucous_config["mucous"]["url reader"] = 'custom'
									elif mucous_config["mucous"]["url reader"] == 'custom':
										mucous_config["mucous"]["url reader"] = 'lynx'
									self.setup_mode()
								elif x >=33 and x <=49:
									# Change charset, encoding, language that text is piped thru
									if "language" in mucous_config["mucous"]:
										if mucous_config["mucous"]["language"] in self.encodings:
											pos = self.encodings.index(mucous_config["mucous"]["language"])
											pos +=1
											if pos not in range(len(self.encodings)):
												pos = 0
											mucous_config["mucous"]["language"]=self.encodings [pos]
											self.setup_mode()
										else:
											mucous_config["mucous"]["language"]=self.encodings [0]
											self.setup_mode()
								elif x >=50 and x <=66:
									if mucous_config["mucous"]["Auto-Clear"] == "True":
										mucous_config["mucous"]["Auto-Clear"] = "False"
										self.clear_timer.cancel()
										self.clear_timer = threading.Timer(30.0, self.clear_display)
										
									elif mucous_config["mucous"]["Auto-Clear"] == "False":
										mucous_config["mucous"]["Auto-Clear"] ="True"
										self.clear_timer.cancel()
										self.clear_timer = threading.Timer(30.0, self.clear_display)
										self.clear_timer.start()
									self.setup_mode()
					
							elif self.setup_display_mode=="museek":
								if x >=1 and x <=61:
									#Directories
									if y in (11, 12):
										self.setup_input_mode="download-dir"
									elif y in (13, 14):
										self.setup_input_mode="incomplete-dir"
									self.setup_mode()
									
						elif y in (15, 16, 17):
							if self.setup_display_mode=="mucous":
								if x >=1 and x <=32:
									self.setup_input_mode="custom-url"
									self.setup_mode()
								elif x >=33 and x <=49:
									
									if mucous_config["mucous"]["beep"] == "True":
										mucous_config["mucous"]["beep"] = "False"
									elif mucous_config["mucous"]["beep"] == "False":
										mucous_config["mucous"]["beep"] = "True"
									self.setup_mode()
								elif x >=50 and x <=65:
									update_config()
									self.Hlog("status", "Config Saved")
								
				elif self.DisplayMode in ("help", "debug"):
					if y == self.window_dimensions["help"]["top"]-1:
						if x >= 4 and x <= 16 and self.DisplayMode != "help":
							self.DisplayMode = "help"
							self.help_mode()
						elif x >= 18 and x <= 31 and self.DisplayMode != "debug":
							self.DisplayMode = "debug"
							self.help_mode()
				# END OF MOUSE
				
				
			if key in( "KEY_LEFT", chr(91), chr(34), "KEY_RIGHT", chr(93), chr(35), "KEY_IC"):
				
	
				if self.DisplayMode == "chat":
					joined = self.rooms.keys()
					joined.sort()
					if not joined:
						return
					# Hotkeys to switch rooms
					if not self.current_room in joined:
						if key == "KEY_LEFT" or key == chr(91) or key == chr(34):
							ix = -1
						elif key == "KEY_RIGHT" or key == chr(93) or key == chr(35) or key == "KEY_IC":
							ix = 0
						
	
					else:
						ix = joined.index(self.current_room)
						if key == "KEY_LEFT" or key == chr(91)  or key == chr(34):
							ix -= 1
						elif key == "KEY_RIGHT" or key == chr(93) or key == chr(35) or key == "KEY_IC":
							ix += 1
						
						if ix < 0:
							ix = -1
						elif ix >= len(joined):
							ix = 0
					if ix != None:
						self.set_room(joined[ix])
						self.ticker_z = 0
						try:
							if mucous_config["tickers"]["ticker_cycle"] == "yes" and mucous_config["tickers"]["tickers_enabled"] == "yes":
								self.ticker_timer.cancel()
								self.ticker_timer = threading.Timer(3.0, self.ticker_display)
								self.ticker_timer.start()
						except:
							pass
							
				elif self.DisplayMode == "info":
					if len(self.info_users) >= 1:
						if self.info_user == None:
							self.info_user = self.info_users[0]
						s = self.info_users.index(self.info_user)
						self.info_user = self.info_users[s-1]
						#self.display_userinfo_log()
						self.info_mode()
				elif self.DisplayMode == "private":
					if self.pm_user != None:
						if len(self.privatelog.keys()) > 1:
							pmusers =  self.privatelog.keys()
							pmusers.sort()
							s = pmusers.index(self.pm_user)
							self.pm_user = pmusers[s-1]
							self.start_pm(self.pm_user)
							self.private_mode()
							
				elif self.DisplayMode == "setup":
					if self.setup_display_mode == "mucous":
						self.setup_display_mode = "museek"
					elif self.setup_display_mode == "museek":
						self.setup_display_mode = "shares"
					elif self.setup_display_mode == "shares":
						self.setup_display_mode = "userinfo"
					elif self.setup_display_mode == "userinfo":
						self.setup_display_mode="logs"
					elif self.setup_display_mode=="logs":
						self.setup_display_mode = "mucous"
					self.setup_mode()
					
				elif self.DisplayMode == "transfer":
					# Hotkeys to switch listing transfer types
					if self.transfer_display_mode == 'all':
						self.transfer_display_mode = 'active'
					elif self.transfer_display_mode == 'active':
						self.transfer_display_mode = 'queued'	
					elif self.transfer_display_mode == 'queued':
						self.transfer_display_mode = 'finished'
					elif self.transfer_display_mode == 'finished':
						self.transfer_display_mode = 'failed'
					elif self.transfer_display_mode == 'failed':
						self.transfer_display_mode = 'all'
	
					self.transfer_mode()
		
				elif self.DisplayMode == "search":
					if key in( "KEY_LEFT", chr(91), chr(34), "KEY_RIGHT", chr(93), chr(35)):
						if len(self.s_query.keys()) >= 1:
						
							if self.chosen_search == "default__":
								self.chosen_search = self.s_query.keys()[0]
							s = self.s_query.keys().index(self.chosen_search)
							self.chosen_search = self.s_query.keys()[s-1]
							self.search_mode()
							
					if key == "KEY_IC":
						sf = self.search_format
						if sf == "num":
							self.search_format = "user"
						elif sf == "user":
							self.search_format = "free"
						elif sf == "free":
							self.search_format = "speed"
						elif sf == "speed":
							self.search_format = "que"
						elif sf == "que":
							self.search_format = "path"
						elif sf == "path":
							self.search_format = "size"
						elif sf == "size":
							self.search_format = "file"
						elif sf == "file":
							self.search_format = "bitrate"
						elif sf == "bitrate":
							self.search_format = "time"
						elif sf == "time":
							self.search_format = "num"

						self.search_sortbar()
						if self.chosen_search!= "default__":
							self.Format_Search_Results(self.chosen_search)
						curses.doupdate()
					
				elif self.DisplayMode == "browse":
					if len(self.browsed) >= 1:
						if self.browse_current == "default__":
							self.browse_current = self.browsed[0]
						s = self.browsed.index(self.browse_current)
						self.browse_current = self.browsed[s-1]
						sdirs =  self.browse_list_results[self.browse_current].keys()
						sdirs.sort()
						self.browse_current_dir=sdirs[0]
						
						self.browse_mode()
						
				elif self.DisplayMode=="lists":
					if self.display_which_list=="buddies":
						self.display_which_list="banned"
					elif self.display_which_list=="banned":
						self.display_which_list="ignored"
					elif self.display_which_list=="ignored":
						self.display_which_list="interests"
					elif self.display_which_list=="interests":
						self.display_which_list="buddies"
					self.list_mode()
					
				elif self.DisplayMode=="rooms":
					if mucous_config["mucous"]["rooms_sort"] =="alpha":
						mucous_config["mucous"]["rooms_sort"] ="alpha-reversed"
					elif mucous_config["mucous"]["rooms_sort"] =="alpha-reversed":
						mucous_config["mucous"]["rooms_sort"] ="size"
					elif mucous_config["mucous"]["rooms_sort"] =="size":
						mucous_config["mucous"]["rooms_sort"] ="size-reversed"
					elif mucous_config["mucous"]["rooms_sort"] =="size-reversed":
						mucous_config["mucous"]["rooms_sort"] ="alpha"
					self.rooms_mode()
			
			if self.DisplayMode in ("chat", "lists", "transfer", "search", "browse") and self.showmenu == True:
				# POPUP menu up and down keys
				try:
					if self.currentmenu == None:
							return
					if key == "menu_up":
						if self.menunumber >0:
							self.menunumber -= 1
							self.draw_menu(self.currentmenu)
							
					elif key == "menu_down":
						if self.menunumber < len(self.menus[self.currentmenu]['items'])-1:
							self.menunumber += 1
							self.draw_menu(self.currentmenu)
				except Exception, e:
					pass
			
			return line
		except Exception, e:
			self.Hlog("debug", "Keypresses: " + str(e))
	# ---^  KEYS ^
	
	def display_status_log(self):
		try:
			if self.showmenu == True: raise  Exception,  "popup"
			s = self.window_dimensions["chat"]
			if self.DisplayMode == "chat":
				if self.chatdisplaymode in ("nothing", "big", "small", "widelist", "rightlist", "noroombox"):
					self.logwin.erase()
					self.logwin.scrollok(1)
					self.logwin.idlok(1)
			
					if self.current_room != None:
						if len(self.statuslogs[self.current_room]) != 0:
							for i in range(len(self.statuslogs[self.current_room])):
								try:
									if i == 0:
										self.logwin.addstr(self.decode_language( self.statuslogs[self.current_room][i][1:] ))
									else:
										self.logwin.addstr(self.decode_language( self.statuslogs[self.current_room][i] ))
								except:
									pass
					
					self.logwin.noutrefresh()
		except Exception, e:
			#self.Hlog("debug", e)
			pass
									
	def now_playing(self):
		try:
			if "now-playing" in mucous_config["mucous"].keys():
				if mucous_config["mucous"]["now-playing"] == "default":
					p = "/tmp/xmms-info"
					if os.path.exists(p):
						fsock = open(p)
						for i in range(3):  s = fsock.readline()[8:-1]
						for i in range(10):  m = fsock.readline()[7:-1]
						if "now-playing-prefix" in mucous_config["mucous"].keys():
							if mucous_config["mucous"]["now-playing-prefix"] != 'None':
								message = ("%s %s") %(mucous_config["mucous"]["now-playing-prefix"], m)
							else:
								message ="Now %s: %s " % (s, m)
						else:
							message ="Now %s: %s " % (s, m)
						fsock.close()
						if self.DisplayMode == "chat":
							self.say_in_chat("chat", self.current_room, message)
							#self.send(messages.SayRoom(self.current_room, message))
						elif self.DisplayMode == "private":
							self.send_private_message(self.pm_user, message)
					else: self.Hlog("status", "WARNING: XMMS or BMP isn't running or the InfoPipe plugin isn't enabled")
				else:
					p = mucous_config["mucous"]["now-playing"]
					nowplaying = commands.getoutput(p)
					nowplaying = nowplaying.split('\n')
					nowplaying = nowplaying[0]
					if mucous_config["mucous"]["now-playing-prefix"] != None and mucous_config["mucous"]["now-playing-prefix"] != 'None':
						message = "%s %s" % (mucous_config["mucous"]["now-playing-prefix"], nowplaying)
						if self.DisplayMode == "chat" and self.current_room != None:
							self.say_in_chat("chat", self.current_room, message)
							#self.send(messages.SayRoom(self.current_room.decode(mucous_config["mucous"]["language"]),  message.decode(mucous_config["mucous"]["language"])) )
						elif self.DisplayMode == "private" and self.pm_user != None:
							self.send_private_message(self.pm_user, message )
					else:
						message = nowplaying
						if self.DisplayMode == "chat" and self.current_room != None:
							self.say_in_chat("chat", self.current_room, message)
							#self.send(messages.SayRoom(self.current_room.decode(mucous_config["mucous"]["language"]),  message.decode(mucous_config["mucous"]["language"])) )
						elif self.DisplayMode == "private" and self.pm_user != None:
							self.send_private_message(self.pm_user, message )
		except Exception, e:
			self.Hlog("debug", "now_playing " +str(e))
	# ---v  MODES v
	def showroomstatusbox(self, users, start):
		# RoomBox List Display
		try:
			w = self.window_dimensions["roombox"]
			if self.current_room != None:
				if self.roomboxlist[self.current_room] !=[]:
					#for users in self.roomboxlist[self.current_room][self.boxstart:self.boxend]:
					try:
						#if users != self.roomboxlist[self.current_room][0]:
						#	self.roomstatuswin.addstr('\n')
						if users in self.user_status:
							if self.user_status[users] == 1:
								self.roomstatuswin.addstr('* ', self.colors["yellow"]|curses.A_BOLD)
							elif  self.user_status[users] == 2:
								self.roomstatuswin.addstr('* ', self.colors["green"]|curses.A_BOLD)
							elif self.user_status[users] == 0:
								self.roomstatuswin.addstr('* ', self.colors["red"]|curses.A_BOLD)
						else:
							self.roomstatuswin.addstr('* ', curses.A_BOLD)
							
						if users in self.config["banned"].keys():
							if self.Sup == self.roomboxlist[self.current_room].index(users):
								attrib = curses.A_BOLD | curses.A_REVERSE | self.colors["red"]
							else: attrib = self.colors["red"]
							
						elif users in self.config["ignored"].keys():
							if self.Sup == self.roomboxlist[self.current_room].index(users):
								attrib = curses.A_BOLD | curses.A_REVERSE | self.colors["yellow"]
							else: attrib = self.colors["yellow"]
							
						elif users in self.config["buddies"].keys():
							if self.Sup == self.roomboxlist[self.current_room].index(users):
								attrib = curses.A_BOLD | curses.A_REVERSE | self.colors["green"]
							else:
								attrib = self.colors["green"]
							
						else:
							if self.Sup == self.roomboxlist[self.current_room].index(users):
								attrib = curses.A_BOLD | curses.A_REVERSE 
							else:
								attrib = curses.A_NORMAL
						if len(users[:w["width"]-2]) < w["width"]-2:
							space = " " * ( w["width"]-2 - len(users[:w["width"]-2]))
						else: space =''
						self.roomstatuswin.addstr(self.decode_language(users[:w["width"]-2])+space, attrib)	
						
					except:
						pass
				else:
					self.roomstatuswin.addstr("No one")
		except Exception, e:
			self.Hlog("debug", "showroomstatusbox " +str(e))	
			
			
	def roomstatusbox(self):
		# RoomBox Shape Display
		try:
			if self.DisplayMode=='chat' and self.chatdisplaymode != "noroombox":
				if self.chatdisplaymode in ("big", "nostatuslog", "widelist", "rightlist"):
					w = self.window_dimensions["chat"]
					if self.chatdisplaymode == "rightlist":
						s = self.window_dimensions["roombox"] = {"height": self.h-7, "top": 2, "left": (4+w["width"])-1, "width": self.w-4-w["width"] }
					else:
						s = self.window_dimensions["roombox"] = {"height": self.h-7, "top": 2, "left": 1, "width": self.w-4-w["width"] }
					#s = self.window_dimensions["roombox"] = {"height": self.h-7, "top": 2, "left": 1, "width": 13}
					self.roomstatusborderwin = curses.newwin(s["height"]+2, s["width"]+2, s["top"]-1, s["left"]-1)
					if self.chatroomscroll == "roombox":
						self.roomstatusborderwin.attron(self.colors["green"])
					self.roomstatusborderwin.border()
					self.roomstatusborderwin.attroff(self.colors["green"])
					self.roomstatuswin = self.roomstatusborderwin.subwin(s["height"], s["width"], s["top"], s["left"])
				elif self.chatdisplaymode == "small":
					s = self.window_dimensions["roombox"] = {"height": 4, "top": 2, "left": 1,  "width": 13}
					self.roomstatusborderwin = curses.newwin(s["height"]+2, s["width"]+2, s["top"]-1, s["left"]-1)
					if self.chatroomscroll == "roombox":
						self.roomstatusborderwin.attron(self.colors["green"])
					self.roomstatusborderwin.border()
					self.roomstatusborderwin.attroff(self.colors["green"])
					self.roomstatuswin = self.roomstatusborderwin.subwin(s["height"], s["width"], s["top"], s["left"])
					
				if self.chatdisplaymode in ("big", "small", "nostatuslog", "widelist", "rightlist"):
					self.roomstatuswin.scrollok(0)
					self.roomstatuswin.idlok(1)
				
	
					if self.current_room != None:
						try:
							if self.chatroomscroll == "roombox":
								
								self.roomstatusborderwin.addstr(0, 1, "<           >", self.colors["green"])
								self.roomstatusborderwin.addstr(0, 2, "Users: "+str(len(self.rooms[self.current_room])), self.colors["green"]|curses.A_BOLD)
							else:
								self.roomstatusborderwin.addstr(0, 1, "<           >")
								self.roomstatusborderwin.addstr(0, 2, "Users: "+str(len(self.rooms[self.current_room])),  curses.A_BOLD)
							
						except:
							pass
						
						if self.current_room in self.config["autojoin"].keys():
							try:
								self.roomstatusborderwin.addstr(self.window_dimensions["roombox"]["height"]+1, 2, "Auto-Joined",  curses.A_BOLD)
							except Exception, e:
								self.Hlog("debug", "AutoJoined: " + str(e))
					self.roomstatusborderwin.noutrefresh()
				
					if self.current_room != None:
						self.roomboxlist[self.current_room] = []
						if len( self.rooms[self.current_room] ) > 0:
							self.roomboxlist[self.current_room] = self.rooms[self.current_room]
							self.roomboxlist[self.current_room].sort()
					
						try:
							if self.roomboxlist[self.current_room] != []:
								#if self.chatdisplaymode in  ("big", "nostatuslog"):
									#self.roomstatuswin.erase()
								if self.chatroomscroll == "roombox":
									clipped_list, self.Sup, self.window_dimensions["roombox"]["start"] = self.scrollbox(self.roomboxlist[self.current_room], self.Sup, self.window_dimensions["roombox"]["height"])
								else:
									clipped_list, s, self.window_dimensions["roombox"]["start"] = self.scrollbox(self.roomboxlist[self.current_room], self.Sup, self.window_dimensions["roombox"]["height"])
									
								self.chat_roombox_display()
								#for lines in clipped_list:
								#	self.showroomstatusbox(lines, self.window_dimensions["roombox"]["start"])
							else:
								self.roomstatuswin.addstr("* Empty")
								self.roomstatuswin.noutrefresh()
						except Exception, e:
							self.Hlog("debug", "RSB: " + str(e))
				#curses.doupdate()
		except Exception, e:
			self.Hlog("debug", "roomstatusbox " +str(e))
			
	def chat_mode(self):
		self.DisplayMode = "chat"
		self.showmenu = False
		
		# Arrangements: 
		cs = None
		if self.chatdisplaymode == "big":
			w = self.window_dimensions["chat"] = {"height": self.h-13, "width": self.w-17, "top": 8, "left": 16}
			cs = self.window_dimensions["chatstatus"] = {"height": 6, "width": w["width"]+2, "top": 1, "left": w["left"]-1}
		elif self.chatdisplaymode == "widelist":
			w = self.window_dimensions["chat"] = {"height": self.h-13, "width": self.w-27, "top": 8, "left": 26}
			cs = self.window_dimensions["chatstatus"] = {"height": 6, "width": w["width"]+2, "top": 1, "left": w["left"]-1}
		elif self.chatdisplaymode in ("noroombox", "small"):
			w = self.window_dimensions["chat"] = {"height": self.h-13, "width": self.w-2, "top": 8, "left": 1}
			if self.chatdisplaymode in ("noroombox"):
				cs = self.window_dimensions["chatstatus"] = {"height": 6, "width": w["width"]+2, "top": 1, "left": 0}
				#cs["height"]-2, cs["width"]-1, cs["top"]+1,cs["left"]+1
				#self.logwin = self.borderlogwin.subwin(4, cs["width"], 2, 1)
			elif self.chatdisplaymode in ("small"):
				cs = self.window_dimensions["chatstatus"] = {"height": 6, "width": w["width"]+2, "top": 1, "left": 15}
		elif self.chatdisplaymode == "rightlist":
			w = self.window_dimensions["chat"] = {"height": self.h-13, "width": self.w-17, "top": 8, "left": 1}
			cs = self.window_dimensions["chatstatus"] = {"height": 6, "width": w["width"]+2, "top": 1, "left": 0}
		elif self.chatdisplaymode == "nostatuslog":
			w = self.window_dimensions["chat"] = {"height": self.h-7, "width": self.w-17, "top": 2, "left": 16}
		elif self.chatdisplaymode == "chat-only":
			w = self.window_dimensions["chat"] = {"height": self.h-7, "width": self.w-2, "top": 2, "left": 1}
		
		if cs != None:
			self.borderlogwin = curses.newwin(cs["height"], cs["width"], cs["top"], cs["left"])
			self.logwin = self.borderlogwin.subwin(cs["height"]-2, cs["width"]-2, cs["top"]+1,cs["left"]+1)
				
		self.window_dimensions["chat"]["start"] = 0
		try:
			self.Mwin = curses.newwin(w["height"]+2, w["width"]+2, w["top"]-1, w["left"]-1)
			if self.username==None:
				self.Mwin.border()
				self.Mwin.noutrefresh()
				
			self.textwin = self.Mwin.subwin(w["height"], w["width"], w["top"], w["left"])
		except Exception, e:
			self.Hlog("debug", "Chat Mode: " + str(e))

		
		self.textwin.scrollok(0)
		self.textwin.idlok(1)

		if self.chatroomscroll != "roombox":
			self.Sup  = -1
 		if self.alertwinlog in ( "New Chat", "Nick Mention"):
 			self.alert_status("")	
	
		
		
		
		if self.current_room != None:
			self.set_room(self.current_room)
		else:
			
			self.drawchatwindow()
			self.textwin.noutrefresh()
			self.set_edit_title("Join a Room")
			self.roomstatusbox()
			self.hotkeys()
		
		if mucous_config["tickers"]["ticker_cycle"] == "yes" and mucous_config["tickers"]["tickers_enabled"] == "yes":
			if self.rooms.keys() != []:
				self.ticker_z = 0
				self.ticker_timer.cancel()
				self.ticker_timer = threading.Timer(3.0, self.ticker_display)
				self.ticker_timer.start()
		curses.doupdate()
		
	def chat_roombox_display(self):
		w = self.window_dimensions["roombox"]
		lol = self.roomboxlist[self.current_room]
		self.roomstatuswin.erase()
		if self.chatroomscroll == "roomchat":
			sup = 0
		else:
			sup = self.Sup
			
		clipped_list, sup, self.window_dimensions["roombox"]["start"] = self.scrollbox(lol, sup, w["height"])
		if self.chatroomscroll == "roombox":
			self.Sup = sup
		for lines in clipped_list:
			self.showroomstatusbox(lines, w["start"])
		self.roomstatuswin.noutrefresh()
				
	def chat_display(self):
		w = self.window_dimensions["chat"]
		selected_log = self.roomlogs[self.current_room]
		lol = self.wrap_chat_text(selected_log, w)
		
		if self.chatroomscroll != "roomchat":
			sup =  len(lol)
		else:
			if self.Sup == -1:
				sup = self.Sup = len(lol)
			else:
				sup = self.Sup
		
		clipped_list, sup, self.window_dimensions["chat"]["start"] = self.scrollbox(lol, sup, w["height"])
		#self.wrap_chat_text(log_scroll[start:end], 0)
		if self.chatroomscroll == "roomchat":
			self.Sup = sup
		self.textwin.erase()
		for lines in clipped_list:
			#lines, ls = self.string_add_blanks(lines, w)
			self.display_room_text(lines)

		self.drawchatwindow()
		self.textwin.noutrefresh()
		
	def wrap_chat_text(self, the_list, w):
		# we wrap text here so that scrolling works properly... (it never does) *sigh*
		try:
			pos = 0
			cut_list = []
			for mtype, timestamp, username, message in the_list:
				length = 0
				#mtype, timestamp, username, message = line[0], line[1], line[2], line[3]
				if mtype == "Me":
					#username = self.decode_language(username)
					pre = " * %s " % username
					s = "%s" % self.decode_language(message)
					length += len(timestamp) + len(pre)
# 				elif mtype == "List":
# 					room = self.current_room
# 					pre = "Users in %s: "% room
# 					length +=  len(pre)
# 					for user, color in message:
# 						length += len(self.decode_language(user))
				elif mtype in ("Mentioned", "Normal", "Status"):
					if username != "": # Universal Timestamp
						if mtype == "Status": # Mucous debugging message
							length += len(timestamp) + 2
						else: # Normal user chat
							length += len(timestamp) + 4
						
						#length += len(self.decode_language(username))
						length += len(username)
		
				if "\n" in message:
					
					messagez = message.split('\n')
					# Wrap first line
					firstmsg = messagez[0]
					wit =  len(timestamp) + 4 + len(username)
					lm = len(firstmsg)
					mess = lm - ( (wit + lm ) - w["width"])
					cut_list.append( [ mtype, timestamp, username, firstmsg[:mess] ] )
					restmess = firstmsg[mess:]
					div = ( len(restmess)/w["width"] ) + 1
					spaces= (w["width"] * div) -  len(restmess)
					for seq in range(div):
						if mtype == "Me":
							cut_list.append(['cutme', '', '', restmess[:w["width"]] ])
						else:
							cut_list.append(['cut', '', '', restmess[:w["width"]] ])
						restmess = restmess[w["width"]:]

					# Prepend -- to all following lines
					m = []
					for messages in messagez[1:]:
						m.append("--"+messages)
					# Wrap each of the following lines
					for messages in m:
						lm = len(messages)
						restmess = messages
						div = ( len(restmess)/w["width"] ) + 1
						spaces= (w["width"] * div) -  len(restmess)
						for seq in range(div):
							if mtype == "Me":
								cut_list.append(['cutme', '', '', restmess[:w["width"]] ])
							else:
								cut_list.append(['cut', '', '', restmess[:w["width"]] ])
							restmess = restmess[w["width"]:]
					pos += 1
					continue	
							
					# Short message
				if length +len(message) <= w["width"]:
					cut_list.append([mtype, timestamp, username, message])
					
					# long message
				elif length +len(message) > w["width"]:
					lm = len(message)
					mess = lm - ( (length + lm ) - w["width"])
					cut_list.append( [ mtype, timestamp, username, message[:mess] ] )
					restmess = message[mess:]
					div = ( len(restmess)/w["width"] ) + 1
					spaces= (w["width"] * div) -  len(restmess)
					for seq in range(div):
						#self.Hlog("debug", str(div)+"--" + restmess[:w["width"]] )
						if mtype == "Me":
							cut_list.append(['cutme', '', '', restmess[:w["width"]] ])
						else:
							cut_list.append(['cut', '', '', restmess[:w["width"]] ])
						restmess = restmess[w["width"]:]
 						
				pos += 1
			return cut_list
		except Exception, e:
			# Exceptions are Inevitable
			self.Hlog("debug", "wrap_chat_text: " + str(e))
			
	def display_room_text(self, roomlinenumber):
		room = self.current_room
		mtype, timestamp, username, message = roomlinenumber[0],   roomlinenumber[1], roomlinenumber[2], roomlinenumber[3]
		lang = mucous_config["mucous"]["language"]
		w = self.window_dimensions["chat"]
		room = self.decode_language(room)
		length = 0
		try:
			if mtype == "Me":
				# /me message
				
				self.textwin.addstr(timestamp)
				username = self.decode_language(username)
				pre = " * %s " % username
				self.textwin.addstr(pre, self.colors["green"] | curses.A_BOLD)
				s = "%s" % self.decode_language(message)
				self.textwin.addstr(s, self.colors["green"] | curses.A_BOLD)
				length += len(timestamp) + len(pre)+ len(s)
			elif mtype == "List":
				# List of users in Room
				
				pre = "Users in %s: "% room
				self.textwi/n.addstr(pre)
				length +=  len(pre)
				for username, color in message:
					username = self.decode_language(username)
					length += len(username)
					if color == "Me":
						self.textwin.addstr(username, curses.A_BOLD)
					elif color == "Left":
						self.textwin.addstr(username, self.colors["yellow"])
					elif color == "Banned":
						self.textwin.addstr(username, self.colors["red"])
					elif color == "Buddies":
						self.textwin.addstr(username, self.colors["green"])
					elif color == "NotLast":
						self.textwin.addstr(username)
					elif color == "Normal":
						self.textwin.addstr(username)
						
			elif mtype == "cut":
				s = self.decode_language(message) 
				self.textwin.addstr(s)
				length += len(s)
			elif mtype == "cutme":
				s = self.decode_language(message) 
				self.textwin.addstr(s, self.colors["green"] | curses.A_BOLD)
				length += len(s)
			else:
				if username != "":
					# Universal Timestamp
					self.textwin.addstr(timestamp)
					if mtype == "Status":
						# Mucous debugging message
						pre = " "
						self.textwin.addstr(pre)
						
					else:
						# Normal user chat
						pre = " ["
						self.textwin.addstr(pre, curses.A_BOLD | self.colors["black"])
				length += len(timestamp) + len(pre)
				
				name = self.decode_language(username)
				if username == self.username:
					self.textwin.addstr(username ,  curses.A_BOLD )
				elif username not in self.rooms[room]:
					self.textwin.addstr(name, self.colors["yellow"])
				elif username in self.config["banned"].keys():
					self.textwin.addstr(name, self.colors["red"])
				elif username in self.config["buddies"].keys():
					self.textwin.addstr(name, self.colors["green"])
				else:
					self.textwin.addstr(name)
				length += len(name)
				
				if username != "":
					if mtype == "Status":
						suf = " "
						self.textwin.addstr(" ")
					else:
						suf = "] "
						self.textwin.addstr(suf, curses.A_BOLD | self.colors["black"])
				length += len(suf)
				if mtype == "Mentioned":
					x = message.split(" ")
					for e in x:
						e = self.decode_language(e)
						
						if self.username not in e:
							self.textwin.addstr(e)
							length += len(e)
						elif self.username in e:
							self.textwin.addstr(e, self.colors["cyan"] | curses.A_BOLD)
							length += len(e)
						if e is not  x[-1]:
							if length < w["width"]:
								self.textwin.addstr(" ")
								length +=  1
				elif mtype == "Normal":
					s = self.decode_language(message) 
					self.textwin.addstr(s)
					length += len(s)
				elif mtype == "Status":
					s = self.decode_language(message) 
					self.textwin.addstr(s)
					length += len(s)
			if length < w["width"]:
				self.textwin.addstr(" " * (w["width"] - length))

		except Exception, e:
			pass
			# Exceptions are Inevitable
			#self.Hlog("debug", "display room text: " + str(e))
		
		
	def decode_language(self, string):
		try:
			string = string.decode(mucous_config["mucous"]["language"], "replace" ).encode(mucous_config["mucous"]["language"], "replace").encode(mucous_config["mucous"]["language"], "replace")
			
		except:
			pass
		return string

			
	def add_logs_to_private(self, username):
		try:
			if "\\" in username: username = username.replace("/", "\\")
			if os.path.exists(os.path.expanduser(mucous_config["mucous"]["log_dir"])+"/private"+"/"+username):
				path = os.path.expanduser(mucous_config["mucous"]["log_dir"])+"/private"+"/"+username
				f = open(path, "r")
				a = f.read()
				f.close()
				z = a.split("\n" )
				for x in z[-10:]:
					if x == "":
						continue
					timex = x[12:20]
					user = x[22:]
					if x.find("\t") == -1:
						# old format
						user = user[:user.find("]")]
						message = x[21+len(user)+3:]
					else:
						# new format with Tab
						user = user[:user.find("\t")-1]
						message = x[x.find("\t")+1:]
						
					full_message = "%s * %s %s" % ( timex, user, message)
					self.privatelog[username].append(full_message)
				self.privatelog[username].append("------ Old Chat Above ------")
		except Exception,e:
			self.Hlog("debug", "add_logs_to_private: " +str( e) )
			
	def add_logs_to_chat(self, room):
		try:
			if "\\" in room: room = room.replace("/", "\\")
			if os.path.exists(os.path.expanduser(mucous_config["mucous"]["log_dir"])+"/rooms/"+room):
				path = os.path.expanduser(mucous_config["mucous"]["log_dir"])+"/rooms/"+room
				f = open(path, "r")
				a = f.read()
				f.close()
				z = a.split("\n" )
				for x in z[-30:]:
					if x == "":
						continue
					timex = x[12:20]
					if x[21] == "[":
						user = x[22:]
						if x.find("\t") == -1:
						# old format
							user = user[:user.find("]")]
							message = x[21+len(user)+3:]
						else:
							# new format with Tab
							user = user[:user.find("\t")-1]
							message = x[x.find("\t")+1:]
					else:
						user = x[21:]
						user = user[:user.find(" ")]
						message = x[21+len(user)+1:]
						
					
					if message[:4] == "/me ": 
						full_message = ["Me", timex, user, message[4:]]
					else:
						full_message = ["Normal", timex, user, message]
					self.roomlogs[room].append(full_message)
				self.roomlogs[room].append(["Status", "--------", "!!!!", "Connected to Museek"])
			
		except Exception,e:
			self.Hlog("debug", "add_logs_to_chat: " +str( e) )


	def dencode_language(self, string):
		try:
			string = string.decode(mucous_config["mucous"]["language"]).decode(mucous_config["mucous"]["language"]).encode(mucous_config["mucous"]["language"])
		except:
			pass
		return string
	
	def encode_language(self, string):
		try:
			string = string.encode(mucous_config["mucous"]["language"])
		except:
			pass
		return string
	
	# Change Room Title
	def set_room(self, r):
		self.current_room = r
		self.selected = r
		self.current = r
		
		if self.DisplayMode == "chat":
			
			
			
			# Change title in edit window
			
			if self.chatdisplaymode not in ("chat-only", "nostatuslog"):
				self.display_status_log_border()
				self.display_status_log()
			self.inputwin.erase()
			self.set_edit_title(self.current_room)
			# Display Next-room hotspot's text
			try:
				# Encoding
				if self.current_room in self.config["encoding.rooms"]:
					blah = self.config["encoding.rooms"][self.current_room]
				else:
					blah = self.config["encoding"]["network"]
				
				self.inputwin.addstr(0, self.w-17-len(blah)-4, "<" + (" " *( len(blah) +2) )+  ">")
				self.inputwin.addstr(0, self.w-17-len(blah)-2, blah, self.colors["cyan"] | curses.A_BOLD)
				# Previous, Next Buttons
				self.inputwin.addstr(0, self.w-17, "<      >")
				self.inputwin.addstr(0, self.w-15, "Prev", self.colors["cyan"] | curses.A_BOLD)
				self.inputwin.addstr(0, self.w-9, "<      >")
				self.inputwin.addstr(0, self.w-7,"Next", self.colors["cyan"] | curses.A_BOLD)

				# Clean screen
				self.inputwin.noutrefresh()
			except:
				pass
			
			try:
				self.editwin.noutrefresh()
			except:
				pass
			self.roomstatusbox()
			if self.chatroomscroll == "roomchat":
				self.Sup = -1
			# Display chat log
			try:
				if self.chatroomscroll == "roomchat":
					self.Mwin.attron(self.colors["green"])
				else:
					self.Mwin.attroff(self.colors["green"])
#				self.drawchatwindow()
			except:
				pass
			if self.current_room != None:
				#self.wrap_chat_text(self.roomlogs[self.current_room], 1)
				self.chat_display()
				
			# Clear Alert log
			if "%s" % self.current_room == self.alertwinlog:
				self.alert_status("")
			
						
		try:
			self.textwin.noutrefresh()
		except:
			pass
		
		self.check_alert_state()

			
	def set_edit_title(self, room):
		self.current = room
		self.inputwin.erase()
		self.inputwin.border()
		if self.current:
			try:
				current = self.decode_language(self.current)
				self.inputwin.addstr(0, 2, "< ")
				self.inputwin.addstr(0, 4, current[:self.w-8], self.colors["cyan"] | curses.A_BOLD)
				self.inputwin.addstr(0, 4+len(current[:self.w-8]), " >")
			except Exception, e:
				self.Hlog("debug", "set_edit_title: " + str(e))
		try:
			self.inputwin.noutrefresh()
			self.editwin.noutrefresh()
		except:
			pass

	def display_list_text(self, line, count, window):
		if self.DisplayMode == "lists":
			start = self.window_dimensions[window]["start"]
			linenumber = line
			mtype = linenumber[0]
			username = linenumber[1]
			note = linenumber[2]
			
			tabbeduser = self.decode_language(username[:20])

			while len(tabbeduser) < 24:
				tabbeduser += ' '
			try:
				if username in self.user_status.keys():
					if self.user_status[username] == 1:
						self.textwin.addstr('* ', self.colors["yellow"]|curses.A_BOLD)
					elif self.user_status[username] == 2:
						self.textwin.addstr('* ', self.colors["green"]|curses.A_BOLD)
					elif self.user_status[username] == 0:
						self.textwin.addstr('* ', self.colors["red"]|curses.A_BOLD)
				else: 
					self.textwin.addstr('* ')	
				pos = 2
				
				if self.display_which_list == "buddies":
					try:
						
						if mtype == 'Banned':
							color = curses.color_pair(1)
						elif mtype == 'Ignored':
							color = curses.color_pair(2)
						elif mtype == 'Normal':
							color = self.colors["green"]
						else:
							color = curses.A_NORMAL
						
					except Exception, e:
						self.Hlog("debug", "display list text" + str(e))
						pass
							
				elif self.display_which_list == "banned":
					
					try:
						if mtype == 'Buddies':
							color = self.colors["green"]
						elif mtype == 'Ignored':
							color = curses.color_pair(2)
						elif mtype == 'Normal':
							color = curses.color_pair(1)
						else:
							color = curses.A_NORMAL

					except:
						self.Hlog("debug", "display list text" + str(e))
						
						
				elif self.display_which_list == "ignored":
					try:
						if mtype == 'Buddies':
							color = self.colors["green"]
						elif mtype == 'Banned':
							color = self.colors["red"]
						elif mtype == 'Normal':
							color = self.colors["yellow"]
						else:
							color = curses.A_NORMAL
					except Exception, e:
						self.Hlog("debug", "display list text" + str(e))
				#else:
					#self.textwin.addstr(tabbeduser)
					#stats = note = ''
					
				if count + start == self.Sup:
					attrib = curses.A_BOLD | curses.A_REVERSE | color
					attrib2 = curses.A_BOLD | curses.A_REVERSE 
				else:
					attrib = curses.A_BOLD | color
					attrib2 = curses.A_BOLD 
					
				self.textwin.addstr(tabbeduser, attrib)
							
				if username in self.user_stats:
					stats = " %sKB/s" % str(self.user_stats[username][0]/1024)
					while len(stats) < 9:
						stats += " "
					files = str(self.user_stats[username][2])
					while len(files) < 7:
						files = " " + files
					stats += files
					while len(stats) < 18:
						stats += " "
					self.textwin.addstr( stats, attrib2)
				else:
					stats  = " 0KB/s         0  "
					self.textwin.addstr(stats, attrib2)
					
				width = len(tabbeduser) + len(stats) + len(note) + 5
				subtract = self.w - width
				if subtract < 0:
					self.textwin.addstr(note[:len(note)+subtract], attrib2)
				else:
					self.textwin.addstr(note, attrib2)
					
					
				pos += len(tabbeduser) + len(stats) + len(note)
				if self.window_dimensions[window]["width"] - pos > 0:
					spaces = " " * (self.window_dimensions[window]["width"] - pos)
					self.textwin.addstr(spaces, attrib2)
			except Exception, e:
				pass
				#self.Hlog("debug", "DLT"+str(e))


		
	def drawchatwindow(self):
		try:
			s = self.window_dimensions["chat"]
			if self.chatroomscroll != "roombox":
				self.Mwin.attron(self.colors["green"])
				self.Mwin.border()
				self.Mwin.addstr(0, 0, "Oo",  self.colors["green"] | curses.A_BOLD)
				self.Mwin.addstr(0, 3, "< Chat Rooms >",  self.colors["green"] | curses.A_BOLD)
				self.Mwin.addstr(1, s["width"]+1, "^",  self.colors["green"] | curses.A_BOLD)
				self.Mwin.addstr(s["height"], s["width"]+1, "v",  self.colors["green"] | curses.A_BOLD)
				self.Mwin.addstr(s["height"]+1, 2, "< "+str(abs(self.Sup))+" >", self.colors["green"] | curses.A_BOLD)
			else:
				self.Mwin.border()
				self.Mwin.addstr(0, 0, "Oo", curses.A_BOLD)
				self.Mwin.addstr(0, 3, "< Chat Rooms >",   curses.A_BOLD)
				self.Mwin.addstr(1, s["width"]+1, "^",  curses.A_BOLD)
				self.Mwin.addstr(s["height"], s["width"]+1, "v",  curses.A_BOLD)
				self.Mwin.addstr(s["height"]+1, 2, "< "+str(abs(self.Sup))+" >", curses.A_BOLD)
			self.Mwin.noutrefresh()
			
		except Exception,e :
			self.Hlog("debug", "display chat window: " + str(e))
			
	def say(self, mtype, room, user, message):
		try:
			if room == None:
				room = self.current_room
			full_message = [mtype, time.strftime("%H:%M:%S"), user, message]
			if len( self.roomlogs[room] ) >= 700:
				del self.roomlogs[room][0]
			oldlen = len(self.roomlogs[room])
			self.roomlogs[room].append(full_message)
			
				
			if self.DisplayMode == "chat":
				
				if room == self.current_room and self.chatroomscroll == "roomchat":
					if self.Sup >= oldlen:
						self.Sup = -1
						self.chat_display()
		
		except Exception,e :
			self.Hlog("debug", "say: " + str(e))


	def display_status_log_border(self):
		try:
			w = self.window_dimensions["chat"]
			if self.showmenu == True: raise  Exception,  "popup"

			if self.chatdisplaymode in ("noroombox", "big", "small", "rightlist", "widelist"):
				self.borderlogwin.border()
				self.borderlogwin.addstr(0, 3, "<")
				self.borderlogwin.addstr(0, 4, " Status Log ", self.colors["blue"] | curses.A_BOLD)
				self.borderlogwin.addstr(0, 16, ">")
				self.borderlogwin.noutrefresh()
		except:
			pass
		
	def chat_room_cycle(self):
		
		if self.chatdisplaymode == "noroombox":
			self.chatdisplaymode = "small"
			self.chatroomscroll  = "roombox"
		elif self.chatdisplaymode == "small":
			self.chatdisplaymode = "big"
			self.chatroomscroll  = "roombox"
		elif self.chatdisplaymode == "big":
			self.chatdisplaymode = "widelist"
			self.chatroomscroll  = "roombox"
		elif self.chatdisplaymode == "widelist":
			self.chatdisplaymode = "rightlist"
			self.chatroomscroll  = "roombox"
		elif self.chatdisplaymode == "rightlist":
			self.chatdisplaymode = "nostatuslog"
			self.chatroomscroll  = "roomchat"
		elif self.chatdisplaymode == "nostatuslog":	
			self.chatdisplaymode = "chat-only"
			self.chatroomscroll  = "roomchat"
		elif self.chatdisplaymode == "chat-only":
			self.chatdisplaymode = "noroombox"
			self.chatroomscroll  = "roomchat"
			
		mucous_config["mucous"]["roombox"] = self.chatdisplaymode
		self.chat_mode()


			
	def private_mode(self):
		self.DisplayMode = "private"
		self.showmenu = False
		try:
			w = self.window_dimensions["private"] = {"height": self.h-10, "width": self.w-2, "top": 5, "left": 1}
			self.Mwin = curses.newwin(w["height"]+2,w["width"]+2, w["top"]-1, w["left"]-1)
			
			if self.pm_user != None:
				self.Mwin.attron(self.colors["green"])
				attr = self.colors["green"]
			else:
				attr = curses.A_NORMAL
			self.Mwin.border()
			try:
				attr
				self.Mwin.addstr(0, 3, "< ", attr)
				if self.pm_user == None:
					self.Mwin.addstr(0, 5, "Private Chat",  self.colors["green"] | curses.A_BOLD)
					self.Mwin.addstr(0, 17, " >", attr)
				else:
					self.Mwin.addstr(0, 5, "Private Chat with %s" % self.pm_user,  self.colors["green"] | curses.A_BOLD)
					self.Mwin.addstr(0, 23+len(self.pm_user), " >", attr)
				self.Mwin.refresh()
			except:
				pass
			self.textwin = self.Mwin.subwin(w["height"], w["width"], w["top"], w["left"])
			
			self.textwin.scrollok(0)
			self.textwin.idlok(1)
			
			self.Sup = -1 
			self.private_display()
			if self.pm_user != None:
				self.selected = self.pm_user
				self.set_edit_title("Send message to: " + self.pm_user)
				try:
					if self.pm_user in self.config["encoding.users"]:
						blah = self.config["encoding.users"][self.pm_user]
					else:
						blah = self.config["encoding"]["network"]
					
					self.inputwin.addstr(0, self.w-17-len(blah)-4, "<" + (" " *( len(blah) +2) )+  ">")
					self.inputwin.addstr(0, self.w-17-len(blah)-2, blah, self.colors["cyan"] | curses.A_BOLD)
					self.inputwin.addstr(0, self.w-10, "< ")
					self.inputwin.addstr(0, self.w-8, "Close ", self.colors["cyan"] | curses.A_BOLD)
					self.inputwin.addstr(0, self.w-2, ">")
				except:
					pass
				self.inputwin.noutrefresh()
				
				self.check_alert_state()
	
			else:
				self.set_edit_title("Set a user to Private Message")
				self.hotkeys()
	
			if self.alertwinlog == "New PM" or self.alertwinlog[:5] =="PM: ":
				self.alert_status("")
			pmusers = self.privatelog.keys()
			pmusers.sort()
			self.select_tab_box(pmusers, self.pm_user)
			
			
		except Exception, e:
			self.Hlog("debug", "private_mode" +str(e))
		curses.doupdate()
		
	def wrap_n_clip(self, the_list, w):
		try:
			wrapped_lines = []
			for lines in the_list:
				#lines = str(lines)
				lines1 = ""
				for a in lines:
					if curses.ascii.isctrl(a):
						a = curses.ascii.unctrl(a)
					lines1 += a
					#lines = lines.replace("^A", "\^A")
					#self.Hlog("debug", lines +" "+ str(len(lines))+curses.ascii.ctrl("a"))
				list_of_strings = self.string_cut_width(lines1, w)
				for string in list_of_strings:
					wrapped_lines.append(string)
			if self.Sup == -1:
				self.Sup = len(wrapped_lines)
			clipped_list, self.Sup, w["start"] = self.scrollbox(wrapped_lines, self.Sup, w["height"])
			return clipped_list, self.Sup, w["start"]
		except Exception, e:
			self.Hlog("debug", "wrap_n_clip " +str(e))
	
	
	def private_display(self):
		w = self.window_dimensions["private"]
		self.textwin.erase()
		if self.pm_user != None:
			# Private chat log
			if self.pm_user in self.privatelog:
				clipped_list, self.Sup, w["start"] = self.wrap_n_clip( self.privatelog[self.pm_user], w )
				
				attrs = curses.A_BOLD #| curses.A_UNDERLINE
				attr = curses.A_NORMAL
				count = 0
				for lines in clipped_list:
					try:
						lines, ls = self.string_add_blanks(lines, w)
						if count + w["start"] == self.Sup:
							self.textwin.addstr(self.decode_language(lines), attrs)
						else:
							self.textwin.addstr(self.decode_language(lines), attr)
						count += 1
					except Exception, e:
						#self.Hlog("debug", "private display: " + str(e))
						pass
		else:
			# Instructions
			for lines in self.pminfolog:
				try:
					lines, ls = self.string_add_blanks(lines, w)
					self.textwin.addstr(self.decode_language(lines))
				except Exception, e:
					self.Hlog("debug", "private display: " + str(e))
				
		self.textwin.noutrefresh()
		
	def process_list_window(self, window):
		
		s = self.window_dimensions[window]
		
		if self.DisplayMode in ("lists", "rooms"):
			self.Mwin = curses.newwin(s["height"]+2, s["width"]+2, s["top"]-1, s["left"]-1)
			self.Mwin.attron(self.colors["green"])
			self.Mwin.border()
			self.Mwin.attroff(self.colors["green"])
			
		elif self.DisplayMode == "transfer":
			if window == "uploads":
				win = self.transwin2 = curses.newwin(s["height"]+2, s["width"]+2, s["top"]-1, s["left"]-1)
			elif window == "downloads":
				win = self.transwin = curses.newwin(s["height"]+2, s["width"]+2, s["top"]-1, s["left"]-1)
			
			if mucous_config["mucous"]["transbox"] == "tabbed":
				win.attron(self.colors["green"])
				win.border()
				if window == "uploads":
					win.addstr(0, 3, "< Uploading Transfers >",  self.colors["green"] | curses.A_BOLD)
					win.addstr(0, 27, "< Downloading Transfers >")
				elif window == "downloads":
					win.addstr(0, 3, "< Uploading Transfers >")
					win.addstr(0, 27, "< Downloading Transfers >",   curses.A_BOLD|self.colors["green"])	
				
			else:
				if self.transferscroll == "upload" and window == "uploads":
					win.attron(self.colors["green"])
					win.border()
					win.addstr(0, 3, "< Uploading Transfers >", curses.A_BOLD|self.colors["green"])
				elif self.transferscroll == "upload" and window == "downloads":
					win.border()
					win.addstr(0, 3, "< Downloading Transfers >", curses.A_BOLD)
				elif self.transferscroll == "download" and window == "downloads":
					win.attron(self.colors["green"])
					win.border()
					win.addstr(0, 3, "< Downloading Transfers >", curses.A_BOLD|self.colors["green"])
				elif self.transferscroll == "download" and window == "uploads":
					win.border()
					win.addstr(0, 3, "< Uploading Transfers >", curses.A_BOLD)
					

		if self.DisplayMode == "lists":
			if self.display_which_list =="buddies":
				self.Mwin.addstr(0, 3, "< Buddied >",  self.colors["green"] | curses.A_BOLD)
				self.Mwin.addstr(0, 16, "< Banned >", self.colors["green"])
				self.Mwin.addstr(0, 28, "< Ignored >", self.colors["green"])
				self.Mwin.addstr(0, 41, "< Interests >", self.colors["green"])
				self.set_edit_title("Add Buddy:")
			elif self.display_which_list =="banned":
				self.Mwin.addstr(0, 3, "< Buddied >",  self.colors["green"] )
				self.Mwin.addstr(0, 16, "< Banned >", self.colors["green"]| curses.A_BOLD)
				self.Mwin.addstr(0, 28, "< Ignored >", self.colors["green"])
				self.Mwin.addstr(0, 41, "< Interests >", self.colors["green"])
				self.set_edit_title("Ban User:")
			elif self.display_which_list =="ignored":
				self.Mwin.addstr(0, 3, "< Buddied >",  self.colors["green"] )
				self.Mwin.addstr(0, 16, "< Banned >", self.colors["green"])
				self.Mwin.addstr(0, 28, "< Ignored >", self.colors["green"]| curses.A_BOLD)
				self.Mwin.addstr(0, 41, "< Interests >", self.colors["green"])
				self.set_edit_title("Ignore User:")
			elif self.display_which_list =="ignored":
				self.Mwin.addstr(0, 3, "< Buddied >",  self.colors["green"] )
				self.Mwin.addstr(0, 16, "< Banned >", self.colors["green"])
				self.Mwin.addstr(0, 28, "< Ignored >", self.colors["green"])
				self.Mwin.addstr(0, 41, "< Interests >", self.colors["green"]| curses.A_BOLD)
				self.set_edit_title("Add Interest:")
		elif self.DisplayMode == "rooms":
			self.Mwin.addstr(0, 3, "< Room List >",  self.colors["green"] | curses.A_BOLD)
			pos = 3
			sorta = "< "
			sort = "Sort by:"
			sortnaz = " Name A-Z"
			sortnza = " Name Z-A"
			sorts90 =" Size 9-0"
			sorts09 =" Size 0-9"
			quick = mucous_config["mucous"]["rooms_sort"]
			sortnaz_color = sortnza_color = sorts90_color = sorts09_color = curses.A_NORMAL
			if quick == "size":
				sorts90_color = self.colors["green"]
			elif quick == "size-reversed":
				sorts09_color = self.colors["green"]
			elif quick == "alpha-reversed":
				sortnza_color = self.colors["green"]
			elif quick == "alpha":
				sortnaz_color = self.colors["green"]
			self.Mwin.addstr(self.h-6, pos, sorta,  self.colors["green"] | curses.A_BOLD)
			pos += 2
			self.Mwin.addstr(self.h-6, pos, sort,  curses.A_BOLD)
			pos += len(sort)
			self.Mwin.addstr(self.h-6, pos, sortnaz,  sortnaz_color | curses.A_BOLD)
			pos += len(sortnaz)
			self.Mwin.addstr(self.h-6, pos, " |",  self.colors["green"] | curses.A_BOLD)
			pos += 2
			self.Mwin.addstr(self.h-6, pos, sortnza,  sortnza_color | curses.A_BOLD)
			pos += len(sortnza)
			self.Mwin.addstr(self.h-6, pos, " |",  self.colors["green"] | curses.A_BOLD)
			pos += 2
			self.Mwin.addstr(self.h-6, pos, sorts90, sorts90_color | curses.A_BOLD)
			pos += len(sorts90)
			self.Mwin.addstr(self.h-6, pos, " |",  self.colors["green"] | curses.A_BOLD)
			pos += 2
			self.Mwin.addstr(self.h-6, pos, sorts09,  sorts09_color | curses.A_BOLD)
			pos += len(sorts09)
			self.Mwin.addstr(self.h-6, pos, " >",  self.colors["green"] | curses.A_BOLD)
			self.Mwin.addstr(self.h-6, self.w-15, "< Refresh >",  self.colors["green"] | curses.A_BOLD)
			self.set_edit_title("Join a Room")
			
		if self.DisplayMode in ("lists", "rooms"):	
			self.Mwin.noutrefresh()
			self.textwin = self.Mwin.subwin(s["height"], s["width"], s["top"], s["left"])
			self.textwin.scrollok(0)
			self.textwin.idlok(1)
			
		self.Sup = 0
		
		

	def transfer_mode(self):
		self.DisplayMode = "transfer"
		self.showmenu = False
		
		# Draw upload border

		try:
			if mucous_config["mucous"]["transbox"] == "split":
				u = self.window_dimensions["uploads"] = {"height": self.h/2-4, "width": self.w-2, "top": 2, "left": 1}
				d = self.window_dimensions["downloads"] = {"height": self.h-5-u["height"]-4, "width": self.w-2, "top": self.h/2, "left": 1}
				self.process_list_window("uploads")
				self.process_list_window("downloads")
				
			elif mucous_config["mucous"]["transbox"] == "tabbed":
				if self.transferscroll == "upload":
					u = self.window_dimensions["uploads"] = {"height": self.h-7, "width": self.w-2, "top": 2, "left": 1}
					self.process_list_window("uploads")
				else:
					d = self.window_dimensions["downloads"] = {"height": self.h-7, "width": self.w-2, "top": 2, "left": 1}
					self.process_list_window("downloads")
				
			# Draw upload window
			
			if mucous_config["mucous"]["transbox"] == "split":
				
				self.transwin2.refresh()
				self.transwin.refresh()
				
				self.upwin = self.transwin2.subwin( u["height"], u["width"], u["top"], u["left"])
				self.upwin.scrollok(0)
				self.upwin.idlok(1)
				self.upwin.noutrefresh()
				
				self.downwin = self.transwin.subwin(d["height"],d["width"], d["top"],d["left"])
				self.downwin.scrollok(0)
				self.downwin.idlok(1)
				self.downwin.noutrefresh()
				
			elif mucous_config["mucous"]["transbox"] == "tabbed":
				
				if self.transferscroll == "upload":
					self.transwin2.refresh()
					self.upwin = self.transwin2.subwin( u["height"], u["width"], u["top"], u["left"])
					self.upwin.scrollok(0)
					self.upwin.idlok(1)
					self.upwin.noutrefresh()
				elif self.transferscroll == "download":
					self.transwin.refresh()
					# Draw download window
					self.downwin = self.transwin.subwin(d["height"],d["width"], d["top"],d["left"])
					self.downwin.scrollok(0)
					self.downwin.idlok(1)
					self.downwin.noutrefresh()
					
			if self.last_transferscroll != None:
				if self.last_transferscroll != self.transferscroll:
					self.Sup = 0
			else:
				self.Sup = 0
			
		except Exception, e:
			self.Hlog("debug", "transfer mode: " + str(e))
			
		try:
			self.transfer_panel()
						
			self.set_edit_title("Modify Transfers")
			if mucous_config["mucous"]["transbox"] == "split":
				self.upload_manager()
				self.download_manager()
				curses.doupdate()
			else:
				if self.transferscroll == "upload":
					self.upload_manager()
					curses.doupdate()
				if self.transferscroll == "download":
					self.download_manager()
					curses.doupdate()
					
			self.last_transferscroll = self.transferscroll
		except Exception, e:
			self.Hlog("debug", "transfer panel: " + str(e))
			
		self.hotkeys()
		curses.doupdate()
	
	def arrows(self, window, height, pos, string):
		try:
			window.addstr(height, pos, "< ")
			window.addstr(height, pos+2, string.capitalize(), self.colors["green"] | curses.A_BOLD)
			window.addstr(height, pos+2+len(string), " >")
		except Exception, e:
			self.Hlog("debug", "arrows: " + str(e))
	
	def transfer_panel(self):
		if self.transferscroll == "download":
			s = self.window_dimensions["downloads"]
			window = self.transwin
		elif self.transferscroll == "upload":
			s = self.window_dimensions["uploads"]
			window = self.transwin2
		try:
			pos = 2
			 
			self.arrows(window, s["height"]+1, pos, mucous_config["mucous"]["transbox"])
			
			if self.transfer_display_mode == 'all':
				
				pos = 20
				self.arrows(window, s["height"]+1, pos, self.transfer_display_mode)
			else:
				window.addstr(s["height"]+1, 20, "< All >")

			if self.transfer_display_mode == 'active':
				pos = 28
				self.arrows(window, s["height"]+1, pos, self.transfer_display_mode)
			else:
				window.addstr(s["height"]+1, 28, "< "+'Active'+" >")

			if self.transfer_display_mode == 'queued':
				pos = 39
				self.arrows(window, s["height"]+1, pos, self.transfer_display_mode)
			else:
				window.addstr(s["height"]+1, 39, "< "+'Queued'+" >")
			if self.transfer_display_mode == 'finished':
				pos = 50
				self.arrows(window, s["height"]+1, pos, self.transfer_display_mode)
			else:
				window.addstr(s["height"]+1, 50, "< "+'Finished'+" >")
			if self.transfer_display_mode == 'failed':
				pos = 63
				self.arrows(window, s["height"]+1, pos, self.transfer_display_mode)
			else:
				window.addstr(s["height"]+1, 63, "< "+'Failed'+" >")
			window.refresh()
		except:
			pass
		
			
	def browse_mode(self):
		self.DisplayMode = "browse"
		self.showmenu = False
		
		#self.Mwin = curses.newwin(self.h -8, self.w, 4, 0)
		w = self.window_dimensions["browse"] = {"height": self.h-11, "width": self.w-25, "top": 5, "left": 24, "start": 0}
		self.Mwin = curses.newwin(w["height"]+2, w["width"]+2, w["top"]-1, w["left"]-1)
		
		self.dirborderwin = curses.newwin(w["height"]+2, self.w-w["width"]-2, w["top"]-1, 0)
		
		self.browse_redraw()
		
		self.textwin = self.Mwin.subwin(w["height"], w["width"], w["top"], w["left"])
		self.textwin.scrollok(0)
		self.textwin.idlok(1)
		self.textwin.refresh()
		
		d =self.window_dimensions["directories"]= {"height": w["height"], "width": self.w-w["width"]-4, "top": w["top"], "left":1}
		self.dirwin = self.dirborderwin.subwin(d["height"], d["width"], d["top"], d["left"])
		self.dirwin.erase()
		self.dirwin.noutrefresh()

		self.Sup = 0 
		
		# Vars
		self.filesdirs = []
		self.numberfiles=0
		self.from_s = 0
		self.to = 0
		self.files = []
		self.directories = []

		
		self.browse_bar = curses.newwin(1, self.w, w["top"]+w["height"]+1, 0)
		self.browse_bar.erase()
		self.browse_bar.noutrefresh()
		
		#if self.alertwinlog[:6] == "Browse":
		#	self.alert_status("")
		self.check_alert_state()
		self.hotkeys()
		self.browse_display()
		curses.doupdate()
		
	def browse_redraw(self):
		w = self.window_dimensions["browse"]
		if self.browse_scroll == "files":
			self.Mwin.attron(self.colors["green"])
		else:
			self.Mwin.attroff(self.colors["green"])
		self.Mwin.border()

		try:
			if self.browse_scroll == "files":
				attr = self.colors["green"] | curses.A_BOLD
			else:
				attr = curses.A_BOLD
			self.Mwin.addstr(0, 3, "< Browse users >",  attr)
		except:
			pass
		self.Mwin.noutrefresh()
		
		self.dirborderwin.erase()
		if self.browse_scroll == "directories":
			self.dirborderwin.attron(self.colors["green"])
			attr = self.colors["green"] | curses.A_BOLD
		else:
			attr = curses.A_BOLD
		self.dirborderwin.border()
		self.dirborderwin.attroff(self.colors["green"] )
		self.dirborderwin.addstr(0, 4, "< Directories >",  attr)
		self.dirborderwin.noutrefresh()
		
		if self.browse_current == "default__":
			self.dsup = 0
			self.set_edit_title("Choose a user to Browse Shares")
			self.temporary_click_text()
		else:
			self.temporary_click_text()
			#s = "Browse "+self.browse_current+"'s files in "
			#ls = len(s)
			#self.set_edit_title(s  + self.browse_current_dir[:self.w-ls-8] )
			self.set_edit_title( self.browse_current_dir[:self.w-8] )
		
		
	def browse_display(self):
		d =self.window_dimensions["directories"]
		w = self.window_dimensions["browse"] 
		#self.browse_scroll = "directories"
		self.selected = self.browse_current
		if self.browse_current != "default__":
			
			directories = []
			for s in self.browse_list_results[self.browse_current]["dirs"]:
				try:
					directories.append(s)
 				except:
					pass
			directories.sort()
			self.directories = directories
			if self.browse_scroll == "directories":
				clipped_list, self.Sup, self.window_dimensions["directories"]["start"] = self.scrollbox(directories, self.Sup, d["height"])
				self.dsup = self.Sup
			else:
				clipped_list, self.dsup, self.window_dimensions["directories"]["start"] = self.scrollbox(directories, self.dsup, d["height"])
			
			count = 0
			self.dirwin.erase()
			for s in clipped_list:
				try:
					z = s.split("\\")
					string = (" " * (len(z)-2)) + "\\"
					string += self.decode_language(z[-1][:self.w-w["width"]-4-len(string)])
					string += " " * ( (self.w-w["width"]-4) -len(string) )
					if count +d["start"] == self.dsup:
						self.dirwin.addstr(string, self.colors["green"])
					else:
						self.dirwin.addstr(string)
					count += 1
				except Exception, e:
					pass
					#self.Hlog("debug", str(e))
			
			self.browse_current_dir = self.directories[self.dsup] 
			self.set_edit_title(self.browse_current_dir )
			self.browse_file_stats( self.browse_current, self.browse_current_dir)
			self.browse_file_bar()
			
			self.dirwin.noutrefresh()
		
		
		
		elif self.browse_current == "default__":
			self.dirwin.erase()
			self.dirwin.noutrefresh()
			self.textwin.erase()
			count = 0
			
			for lines in self.browselog[self.browse_current]:
			#self.browse_file_stats(self, self.browse_current, self.browse_current_dir):
				try:
					self.display_browse_text(lines, count , self.Sup)
	
				except Exception, e:
					self.Hlog("debug", "Browse mode" + str(e))
		self.textwin.noutrefresh()
		self.select_tab_box(self.browsed, self.browse_current)

	def start_browse(self, user):
		try:
			if user not in self.browse_requested:
				self.browse_requested.append(user)
			self.send(messages.UserShares(user))
		except Exception, e:
			self.Hlog("debug", "start_browse" + str(e))
			
	def browse_log(self, s, user):
		if user not in self.browselog.keys():
			self.browselog[user] = []
		self.browselog[user].append("%s" % s)

		if self.DisplayMode == "browse":
			#self.display_browse_text(count, self.browse_current, s)
			pass
		else:
			self.alert_status("Browse: %s" % user)
			
	def display_browse_text(self,  line, count, sup):
		try:
			w = self.window_dimensions["browse"]
			this_line = self.decode_language( line )
			if len(this_line) > self.window_dimensions["browse"]["width"]:
				crop = len(this_line) - self.window_dimensions["browse"]["width"]
				this_line = this_line[:-crop]
				
			if count + w["start"] == sup:
				attr = self.colors["blafgcyabg"] |curses.A_REVERSE|curses.A_BOLD	
				self.textwin.addstr(this_line, attr)
			else:
				attr = curses.A_NORMAL
				self.textwin.addstr(this_line, attr )
			z = w["width"]-len(this_line)
			space = " " * ( z )
			self.textwin.addstr(space, attr)
			
		except:
			pass
			



	def search_mode(self):
		try:
			self.DisplayMode = "search"
			self.showmenu = False
			
			w = self.window_dimensions["search"] = {"height": self.h-11, "width": self.w-2, "top": 5, "left": 1, "start": 0}
			self.Mwin = curses.newwin(w["height"]+2, w["width"]+2, w["top"]-1, w["left"]-1)
			self.Mwin.attron(self.colors["green"])
			self.Mwin.border()
			self.Mwin.attroff(self.colors["green"])
			try:
				self.Mwin.addstr(0, 3, "< Search >",  self.colors["green"] | curses.A_BOLD)
			except:
				pass
			
			if self.sfilter != None:
				sfilter = "Filter: " +self.sfilter
				
			else:
				sfilter = "Filter: Disabled"
			lfil = len(sfilter)
			self.Mwin.addstr(0,15, "< ", self.colors["green"])
			if self.sfilter != None:
				self.Mwin.addstr(0,17, self.decode_language(sfilter), self.colors["cyan"] | curses.A_BOLD)
			else:
				self.Mwin.addstr(0,17, self.decode_language(sfilter), self.colors["red"] | curses.A_BOLD)
			self.Mwin.addstr(0,17+lfil, " >", self.colors["green"])
			
			self.search_sortbar()
			self.textwin = self.Mwin.subwin(w["height"], w["width"], w["top"], w["left"])
			self.textwin.scrollok(0)
			self.textwin.idlok(1)
			self.Sup = 0
			
			self.statswin = curses.newwin(1, self.w, self.h-5, 0)
			self.statswin.erase()
			self.statswin.noutrefresh()
			
			self.search_display()
			
			
			if self.search_type != None:
				self.set_edit_title("Search (Alt-t) "+self.search_type.capitalize()+" for:")
	
			self.select_tab_box(self.s_query.keys(), self.chosen_search)
			self.selected = self.chosen_search
			if self.chosen_search != "default__":
				self.temporary_click_text()
				self.check_alert_state()
			else:
				self.hotkeys()
			curses.doupdate()
		except Exception,e:
			self.Hlog("debug", "search_mode: "+str(e))
			
	def search_sortbar(self):
		try:
			w = self.window_dimensions[self.DisplayMode]
			ls = ("Num", "User", "Free", "Speed", "Que", "Path", "Size", "File", "Bitrate", "Time")
			self.Mwin.addstr(w["height"]+1, 1, "<    |    |    |     |   |    |    |    |       |     >", self.colors["green"])
			pos  = 0
			for i in ls:
				if i == self.search_format.capitalize():
					self.Mwin.addstr(w["height"]+1, 3+pos, self.search_format.capitalize(), self.colors["green"]| curses.A_BOLD)
				else:
					self.Mwin.addstr(w["height"]+1, 3+pos, i, self.colors["red"] | curses.A_BOLD)
				pos += len(i) + 1
	
			pos = 56
			self.Mwin.addstr(w["height"]+1, pos, "<         >", self.colors["green"])
			pos = 58
			if self.search_reverse:
				
				self.Mwin.addstr(w["height"]+1, pos, "Reverse", self.colors["green"]| curses.A_BOLD)
			else:
				self.Mwin.addstr(w["height"]+1, pos, "Reverse", self.colors["red"]| curses.A_BOLD)
	
			self.Mwin.noutrefresh()
			
		except Exception,e:
			self.Hlog("debug", "search_sortbar: "+str(e))
					
	def search_display(self):
		try:
			
			if self.chosen_search== "default__":
				self.textwin.erase()
				w=self.window_dimensions["search"]
				for lines in self.searchlog[self.chosen_search]:
					try:
						lines, ls = self.string_add_blanks(lines, w)
						self.textwin.addstr(self.decode_language(lines))
					except:
						pass
				self.textwin.noutrefresh()
				
			else:
				try:
					if self.showmenu == True: raise  Exception,  "popup"
					self.Format_Search_Results(self.chosen_search)
				except:
					pass
			
		except Exception,e:
			self.Hlog("debug", "search_display: "+str(e))
			
	def temporary_click_text(self):
		try:
			if self.DisplayMode == "search":
				gi = "Instructions"
			elif self.DisplayMode == "browse":
				gi = "Instructions"
			elif self.DisplayMode == "info":
				gi = "Instructions"
				
				
			w = self.window_dimensions[self.DisplayMode]
			pos = w["width"]-3-len(gi)
			self.Mwin.addstr(0,pos, "< ", self.colors["green"])
			self.Mwin.addstr(0,pos+2, gi, self.colors["cyan"] | curses.A_BOLD)
			self.Mwin.addstr(0,pos+2+len(gi), " >", self.colors["green"])
			vertex = w["height"]+1
			if self.DisplayMode == "search":
				self.Mwin.addstr(vertex,self.w-11, "< ", self.colors["green"])
				self.Mwin.addstr(vertex,self.w-9, "Close ", self.colors["cyan"] | curses.A_BOLD)
				self.Mwin.addstr(vertex,self.w-3, ">", self.colors["green"])
			if self.DisplayMode == "browse":
				if self.browse_current in self.config["encoding.users"]:
					blah = self.config["encoding.users"][self.browse_current]
				else:
					blah = self.config["encoding"]["filesystem"]
				
				self.Mwin.addstr(vertex,w["width"]-17-len(blah)-4, "<" + (" " *( len(blah) +2) )+  ">")
				self.Mwin.addstr(vertex,w["width"]-17-len(blah)-2, blah, self.colors["cyan"] | curses.A_BOLD)
				self.Mwin.addstr(vertex,w["width"]-11, "< ")
				self.Mwin.addstr(vertex,w["width"]-9, "Close ", self.colors["cyan"] | curses.A_BOLD)
				self.Mwin.addstr(vertex,w["width"]-3, ">")
			elif self.DisplayMode == "info":
				self.userinfostatswin.addstr(vertex,3, "< ")
				self.userinfostatswin.addstr(vertex,5, "Close ", self.colors["cyan"] | curses.A_BOLD)
				self.userinfostatswin.addstr(vertex,11, ">")
				self.userinfostatswin.noutrefresh()
			self.Mwin.noutrefresh()
		except Exception, e:
			self.Hlog("debug", "TCT" + str(e))
	
	def select_tab_box(self, tab_box_list, selected_tab):
		if tab_box_list == [None]:
			return
		lang = mucous_config["mucous"]["language"]
		self.tabclearwin = curses.newwin(3, self.w, 1, 0)
		self.tabclearwin.hline(1, 1, curses.ACS_HLINE, self.w-2)
		self.tab_positions= {}
		try:
			self.tabclearwin.addstr(1,0, "<")
			self.tabclearwin.addstr(1,self.w-1, ">")
		
			self.tabclearwin.noutrefresh()
			if tab_box_list != []:
				pos = 1
				for string in tab_box_list:
					
					
					if self.DisplayMode=="search":
						sting = self.s_query[string][:13]
					
					else:
						sting = string[:13]
						
					move = len(sting)+2
					
					sting = self.decode_language(sting)
					self.tab_positions[string] = pos, move+pos
					if pos + move < self.w -2:
						
						self.tabwin = curses.newwin(3, len(sting)+2, 1, pos)
						self.tabwin.border()
						self.tabwin.noutrefresh()
						self.tab1win = self.tabwin.subwin(1,len(sting),2,pos+1)
						
						try:
							
							if self.DisplayMode=="search":
								if string == self.chosen_search:
									self.tab1win.addstr(sting, self.colors["green"] | curses.A_BOLD)
								else:
									self.tab1win.addstr(sting, curses.A_BOLD)
							else:
								username = string
								if string == selected_tab:
									if string in self.user_status:
										if self.user_status[username] == 1:
											self.tab1win.addstr(sting, self.colors["yellow"] | curses.A_BOLD)
										elif self.user_status[username] == 2:
											self.tab1win.addstr(sting, self.colors["green"] | curses.A_BOLD)
										elif self.user_status[username] == 0:
											self.tab1win.addstr(sting, self.colors["red"] | curses.A_BOLD)
									else:
										self.tab1win.addstr(sting, self.colors["red"] | curses.A_BOLD)
								else:
									if string in self.user_status:
										if self.user_status[username] == 1:
											self.tab1win.addstr(sting, self.colors["yellow"] )
										elif self.user_status[username] == 2:
											self.tab1win.addstr(sting)
										elif self.user_status[username] == 0:
											self.tab1win.addstr(sting, self.colors["red"])
									else:
										self.tab1win.addstr(sting, self.colors["red"])  
								
						except:
							pass
						
						self.tab1win.noutrefresh()
						pos += len(sting)+2
						
		except Exception, e:
			self.Hlog("debug", "STB: " +str(Exception)+ str(e))
			
	def info_mode(self):
		self.DisplayMode = "info"
		self.showmenu = False
		
		w = self.window_dimensions["info"] = {"height": self.h-10, "width": self.w-17, "top": 5, "left": 1}
		self.Mwin = curses.newwin(w["height"]+2, w["width"]+2, w["top"]-1, w["left"]-1)
		self.Mwin.attron(self.colors["green"])
		self.Mwin.border()
		self.Mwin.attroff(self.colors["green"])
		try:
			self.Mwin.addstr(0, 3, "< Info Mode >",  self.colors["green"] | curses.A_BOLD)
		except:
			pass
		self.Mwin.refresh()

		self.textwin = self.Mwin.subwin(w["height"], w["width"], w["top"], w["left"])
		self.textwin.scrollok(0)
		self.textwin.idlok(1)
		
		
		self.Sup = -1

		self.set_edit_title("Get info about user:")
		
		#if self.alertwinlog in ("New Userinfo", "New IP", "New Stats"):
		#	self.alert_status("")
		
		self.userinfostatswin = curses.newwin(self.h-8, 15, 4, self.w-15)
		self.userinfostatswin.border()
		
		self.infostatswin = self.userinfostatswin.subwin(self.h-10, 13, 5, self.w-14)
		self.infostatswin.scrollok(1)

		self.Mwin.refresh()
		self.infostatswin.refresh()
		self.userinfostatswin.refresh()
		self.info_display()
		# queue, uploads, speed, downloads, files, directories, freeslots
		self.selected = self.info_user
		self.select_tab_box(self.info_users, self.info_user)
 		self.display_userinfo_log()
		self.check_alert_state()
		curses.doupdate()
		#self.hotkeys()
	
	def info_display(self):
		w = self.window_dimensions["info"] 
		lang = mucous_config["mucous"]["language"]
		
		if self.info_user != None:
			self.temporary_click_text()
			# Display Userinfo & Stats
			clipped_list, self.Sup, w["start"] = self.wrap_n_clip(self.userinfolog[self.info_user][0], w )
			
		else:
			# Display instructions, IP info, and stats
			clipped_list, self.Sup, w["start"] = self.wrap_n_clip( self.infolog, w )

		attrs = curses.A_BOLD; attr = curses.A_NORMAL
		count = 0
		self.textwin.erase()
		for lines in clipped_list:
			try:
				lines, ls = self.string_add_blanks(lines, w)
				if count + w["start"] == self.Sup:
					self.textwin.addstr(self.decode_language(lines), attrs)
				else:
					self.textwin.addstr(self.decode_language(lines), attr)
				count += 1
			except Exception, e:
				pass
		self.textwin.noutrefresh()
		
		
	def help_mode(self):
		
		if self.DisplayMode not in ("help", "debug"):
			self.DisplayMode = "debug"
		if self.DisplayMode == "help":
			logfile = self.helplog
		elif self.DisplayMode == "debug":
			logfile = self.helpdebuglog
		self.showmenu = False
		
		s = self.window_dimensions["help"] = {"height": self.h-7, "width": self.w-2, "top": 2, "left": 1, "start": 0}
		self.Mwin = curses.newwin(s["height"]+2, s["width"]+2, s["top"]-1, s["left"]-1)
		self.Mwin.attron(self.colors["green"])
		self.Mwin.border()
		self.Mwin.attroff(self.colors["green"])
		try:
			if self.DisplayMode == "help":
				self.Mwin.addstr(0, 3, "< Help Mode >",  self.colors["green"] | curses.A_BOLD)
				self.Mwin.addstr(0, 18, "<            >",  self.colors["green"])
				self.Mwin.addstr(0, 20, "Debug Mode",  curses.A_BOLD)
			elif self.DisplayMode == "debug":
				self.Mwin.addstr(0, 3, "<           >",  self.colors["green"] )
				self.Mwin.addstr(0, 5, "Help Mode",  curses.A_BOLD)
				self.Mwin.addstr(0, 18, "< Debug Mode >",  self.colors["green"] | curses.A_BOLD)
		except:
			pass
		self.Mwin.refresh()
		self.textwin = self.Mwin.subwin(s["height"], s["width"], s["top"], s["left"])
		self.textwin.scrollok(0)
		self.textwin.idlok(1)
		
		self.Sup = -1
		self.help_display()
		
		self.set_edit_title("Use /help")
		#if self.alertwinlog in ("New Help", "New Bug", "New Status"):
		#	self.alert_status("")
			
		
		self.check_alert_state()
		curses.doupdate()
			
	def help_display(self):
		try:
			w = self.window_dimensions["help"]
			size = w["height"] * w["width"]
			if self.DisplayMode == "help":
				logfile = self.helplog
			elif self.DisplayMode == "debug":
				logfile = self.helpdebuglog
			# DEBUGGING
			wrapped_lines = []
			for lines in logfile:
				list_of_strings = self.string_cut_width(lines, w)
				for string in list_of_strings:
					wrapped_lines.append(string)
			if self.Sup == -1:
				self.Sup = len(wrapped_lines)
				
			clipped_list, self.Sup, w["start"] = self.scrollbox(wrapped_lines, self.Sup, w["height"])
			del wrapped_lines
			count = 0
			
			blanked_lines = []
			for lines in clipped_list:
				s, ls = self.string_add_blanks(lines, w) 
				blanked_lines.append(s)
				
			clipped_list = blanked_lines
			del blanked_lines
			count = 0
			total_lines = 0
			self.textwin.erase()
			for line in clipped_list:
				try:
					if line is clipped_list[-1]:
						line = line[:-1]
					self.Hlog_display(self.DisplayMode, line, count)
					count += 1
				except Exception, e:
					self.say("Status", self.current_room, 'ERR', str(e) )
			self.textwin.refresh()
			
		except Exception, e:
			self.say("Status", self.current_room, "help_display: ", str(e))
			
	def Hlog(self, htype, s):
		s = str(s)
		
		if htype == "help":
			if "\n" in s:
				lis = s.split("\n")
				for line in lis:
					self.helplog.append("%s" %line )
			else:
				self.helplog.append("%s" %s )
		elif htype in ("status", "debug"):
			if "\n" in s:
				lis = s.split("\n")
				for line in lis:
					self.helpdebuglog.append("%s" % line)
			else:
				self.helpdebuglog.append("%s" %s)
			
		if self.DisplayMode in ( "help", "debug", "status"):
			#self.Hlog_display( htype, s, 0)
			self.Sup = -1
			self.help_display()
			#self.check_alert_state()
		else:
			if htype not in self.alert["HELP"]:
				if htype == "help":
					self.alert["HELP"].append("help")
				elif htype == "status":
					self.alert["HELP"].append("status")
				elif htype == "debug":
					self.alert["HELP"].append("debug")
			
			self.check_alert_state()
			
			
	def string_cut_width(self, s, w):
		s = str(s); ls = len(s)
		list_of_strings = []
		if ls > w["width"]:
			div = (ls/w["width"]) + 1
			# Cut long lines into multiple lines
			for seq in range(div):
				list_of_strings.append(s[:w["width"]])
				s = s[w["width"]:]
		else:
			# Short line added to list
			list_of_strings.append(s)
		return list_of_strings
		
	def string_add_blanks(self, s, w):
		#, total_lines
		# s == string
		# w == window_dimensions dict
		s = str(s); ls = len(s)
		if ls > w["width"]:
			# Add spaces if longer than a single line
			div = (ls/w["width"]) + 1
			length = (w["width"] * div) -  ls 
			if length != 0:
				s += (length * " ")
			#total_lines += div

		else:
			# Add spaces till end of first and only line
			s += " " * (w["width"] - ls)
		return s, ls #, total_lines
		
	def Hlog_display(self, htype, s, count):
		try:
			if self.DisplayMode in ( "help", "debug", "status"):
				w = self.window_dimensions["help"]
				if count + w["start"] == self.Sup:
					attr = curses.A_BOLD
				else:
					attr = curses.A_NORMAL
				
				if self.DisplayMode == "help" and htype == "help":
					self.textwin.addstr(self.decode_language(s), attr)
				elif self.DisplayMode == "debug" and htype in( "status", "debug"):
					self.textwin.addstr(self.decode_language(s), attr)
				else:
					self.alert_status("New Help")
			else:
				self.alert_status("New Help")
		except: # Exception, e:
			#self.say("Status", self.current_room, "Hlog_display: ", str(e))
			pass
		return #total_lines
					
	def interests_mode(self):
		self.display_which_list = "interests"
		self.showmenu = False
		
		self.recw_s = s = self.window_dimensions[self.display_which_list] = {"height": self.h-7, "top": 2, "left": 21, "width": self.w-42}
		self.likew_s = l  = self.window_dimensions[self.display_which_list] = {"height": self.h/2-4, "top": 2, "left": 1, "width": 18}
		self.hatew_s = h = self.window_dimensions[self.display_which_list] = {"height": self.h-7-(l["height"])-2, "top": 4+l["height"], "left": 1, "width": 18}
		self.usersw_s = u = self.window_dimensions[self.display_which_list] = {"height": self.h-7, "top": 2, "left": self.w-19, "width": 18}

		self.create_rex_window(s, "Recommendations")
		self.create_rex_window(l, "Liked")
		self.create_rex_window(h, "Hated")
		self.create_rex_window(u, "Users")
		
		
		self.like_draw()
		self.hate_draw()
		self.recommendations_draw()
		self.similar_draw()
# 		self.buddylist()
# 		self.process_list_window(self.display_which_list)
		
		log = self.interestslog
		self.process_list_log(s, log)
		
		self.hotkeys()
		curses.doupdate()
		
	def recommendations_draw(self):
		try:
			self.recw.erase()
			if self.recommendations_list != {}:
				for item, num in self.recommendations_list.items():
					self.recw.addstr(item + " " * (self.recw_s["width"] - len(item)))
				self.recw.refresh()
		except:
			self.recw.refresh()
	
	def hate_draw(self):
		try:
			self.hatew.erase()
			if "interests.hate" in self.config.keys():
				for item in self.config["interests.hate"]:
					self.hatew.addstr(item + " " * (self.hatew_s["width"] - len(item)))
				self.hatew.refresh()
		except Exception, e:
					
			self.hatew.refresh()
			
	def like_draw(self):
		try:
			self.likew.erase()
			if "interests.like" in self.config.keys():
				for item in self.config["interests.like"]:
					self.likew.addstr(item + " " * (self.likew_s["width"] - len(item)))
			self.likew.refresh()
		except:
			self.likew.refresh()
			
	def similar_draw(self):
		try:
			self.usersw.erase()
			if self.similar_users != {}:
				for item, num in self.similar_users.items():
					if num == 1:
						self.usersw.addstr("* ", self.colors["yellow"])
					elif num == 2:
						self.usersw.addstr("* ", self.colors["green"])
					else:
						self.usersw.addstr("* ")
					self.usersw.addstr(item + " " * (self.usersw_s["width"] - len(item)-2))
				self.usersw.refresh()
		except Exception, e:
			self.Hlog( "debug", "similar_draw" + str(e))
			self.usersw.refresh()
	
	def create_rex_window(self, w, title):
		try:
			win = curses.newwin(w["height"]+2, w["width"]+2, w["top"]-1, w["left"]-1)
			win.attron(self.colors["green"])
			win.border()
			win.addstr(0, 1, "< %s >" % title)
			win.attroff(self.colors["green"])
			win.refresh()
			twin =win.subwin(w["height"], w["width"], w["top"], w["left"])
			
			twin.scrollok(0)
			twin.idlok(1)
			if title == "Recommendations":
				self.recw = twin
			elif title == "Liked":
				self.likew = twin
			elif title == "Hated":
				self.hatew = twin
			elif title == "Users":
				self.usersw = twin
		except Exception, e:
			self.Hlog( "debug", "create_rex_window: " + str(e))
		
	def buddy_mode(self):
		self.display_which_list = "buddies"
		self.showmenu = False
		
		s = self.window_dimensions[self.display_which_list] = {"height": self.h-7, "top": 2, "left": 1, "width": self.w-2}
		self.buddylist()
		self.process_list_window(self.display_which_list)
		
		log = self.buddylog
		self.process_list_log(s, log)
		
		self.hotkeys()
		curses.doupdate()
		
	def ban_mode(self):
		self.display_which_list = "banned"
		self.showmenu = False
		
		s = self.window_dimensions[self.display_which_list] = {"height": self.h-7, "top": 2, "left": 1, "width": self.w-2}
		self.process_list_window(self.display_which_list)
		self.banlist()
		log = self.banlog
		self.process_list_log(s, log)
		self.hotkeys()
		curses.doupdate()
		
	def ignore_mode(self):
		self.display_which_list = "ignored"
		self.showmenu = False
		
		s = self.window_dimensions[self.display_which_list] = {"height": self.h-7, "top": 2, "left": 1, "width": self.w-2}
		self.process_list_window(self.display_which_list)
		
		log = self.ignorelog
		self.process_list_log(s, log)
		self.hotkeys()
		curses.doupdate()
				
	def process_list_log(self, window, log):
		if log != []:
			clipped_list, self.Sup, self.window_dimensions[self.display_which_list]["start"] = self.scrollbox(log, self.Sup, window["height"])
			count =0 
			try:
				self.Mwin.addstr(self.h-6, self.w-18, "< "+str(len(log))+" >", self.colors["green"] | curses.A_BOLD)
				
			except:
				pass
			self.textwin.erase()
			for lines in clipped_list:
				self.display_list_text(lines, count, self.display_which_list)
				count += 1
			self.Mwin.noutrefresh()
			self.textwin.noutrefresh()
			
	def display_lists(self):
		if self.display_which_list=="buddies":
			this_list = self.buddylog
		elif self.display_which_list=="banned":
			this_list = self.banlog
		elif self.display_which_list=="ignored":
			this_list = self.ignorelog
		elif self.display_which_list=="interests":
			this_list = self.interestslog
		clipped_list, self.Sup, self.window_dimensions[self.display_which_list]["start"] = self.scrollbox(this_list, self.Sup, self.h-7)
		count =0 
		self.textwin.erase()
		for lines in clipped_list:
			self.display_list_text(lines, count, self.display_which_list)
			count += 1
		self.textwin.refresh()

	def list_mode(self):
		self.DisplayMode = "lists"
		self.showmenu = False
		if self.display_which_list == "buddies":
			self.buddy_mode()
			
		elif self.display_which_list == "banned":
			self.ban_mode()
			
		elif self.display_which_list == "ignored":
			self.ignore_mode()
			
		elif self.display_which_list == "interests":
			self.interests_mode()	
			
	def rooms_mode(self):
		self.DisplayMode = "rooms"
		self.showmenu = False
		
		s = self.window_dimensions["rooms"] = {"height": self.h-7, "top": 2, "left": 1, "width": self.w-2}
		self.process_list_window("rooms")
		
		self.sizedrooms = []
		alpharooms = []

		if mucous_config["mucous"]["rooms_sort"]  in ("alpha", "alpha-reversed"):
			for rooms in self.all_roomlist.keys():
				alpharooms.append(rooms)
			alpharooms.sort()
			if mucous_config["mucous"]["rooms_sort"] =="alpha-reversed":
				alpharooms.reverse()
				
		elif mucous_config["mucous"]["rooms_sort"] in ("size", "size-reversed"):
			bigsizes = []
			bigsizes=self.sortbyvalue (self.all_roomlist)
			if mucous_config["mucous"]["rooms_sort"] == "size":
				bigsizes.reverse()
			for rooms, sizes in bigsizes:
				alpharooms.append(rooms)
			
		for rooms9 in alpharooms:
			if self.all_roomlist[rooms9] >= mucous_config["mucous"]["roomlistminsize"]:
				self.sizedrooms.append(rooms9)
				
		self.display_room_list_mode()
		
		self.hotkeys()
		curses.doupdate()

		
		
	def display_rooms(self, roomitem, count, start):
		try:
			if count + start == self.Sup:
				attrib =  curses.A_BOLD | curses.A_REVERSE
			else:
				attrib = curses.A_NORMAL
			num = str(self.all_roomlist[roomitem])
			while len(num) < 8:
				num += " "
			string = num + self.decode_language(roomitem)
			if len(string) < self.w-2:
				spaces = " " * (self.w-2 - len(string))
			else:
				string = string[:self.w-2]
				spaces = ''
			self.textwin.addstr(string+spaces, attrib)
			
		except Exception, e:
			#self.Hlog("debug", e)
			pass
			
	def sortbyvalue(self, dict):
		""" Return a list of (key, value) pairs, sorted by value. """
		_swap2 = lambda (x,y): (y,x)
		mdict = map(_swap2, dict.items())
		mdict.sort()
		mdict = map(_swap2, mdict)
		return mdict
	
	def display_room_list_mode(self):
		try:
			self.textwin.erase()
			clipped_list, self.Sup, self.window_dimensions["rooms"]["start"] = self.scrollbox(self.sizedrooms, self.Sup, self.h-7)
			count =0 
			for rooms10 in clipped_list:
				self.display_rooms(rooms10, count, self.window_dimensions["rooms"]["start"])
				count += 1
			self.textwin.refresh()
		except:
			pass
				

		
	def setup_mode(self):
		
		self.DisplayMode = "setup"
		self.showmenu = False
		try:
			self.Mwin = curses.newwin(self.h - 4 -1, self.w, 1, 0)
			self.Mwin.erase()
			self.Mwin.border()
			
			if self.setup_display_mode == "mucous":
				self.set_edit_title("Mucous Setup")
				try:
					self.Mwin.addstr(0, 1, "< Mucous >",  curses.A_BOLD)
					self.Mwin.addstr(0, 15, "< Museek >")
					self.Mwin.addstr(0, 30, "< Shares >")
					self.Mwin.addstr(0, 45, "< Userinfo >")
					self.Mwin.addstr(0, 60, "< Logs >")
				except:
					pass
			elif self.setup_display_mode == "museek":
				try:
					self.Mwin.addstr(0, 1, "< Mucous >")
					self.Mwin.addstr(0, 15, "< Museek >",  curses.A_BOLD)
					self.Mwin.addstr(0, 30, "< Shares >")
					self.Mwin.addstr(0, 45, "< Userinfo >")
					self.Mwin.addstr(0, 60, "< Logs >")
				except:
					pass
			elif self.setup_display_mode == "shares":
				try:
					self.Mwin.addstr(0, 1, "< Mucous >")
					self.Mwin.addstr(0, 15, "< Museek >")
					self.Mwin.addstr(0, 30, "< Shares >",  curses.A_BOLD)
					self.Mwin.addstr(0, 45, "< Userinfo >")
					self.Mwin.addstr(0, 60, "< Logs >")
				except:
					pass
			elif self.setup_display_mode == "userinfo":
				try:
					self.Mwin.addstr(0, 1, "< Mucous >")
					self.Mwin.addstr(0, 15, "< Museek >")
					self.Mwin.addstr(0, 30, "< Shares >")
					self.Mwin.addstr(0, 45, "< Userinfo >",  curses.A_BOLD)
					self.Mwin.addstr(0, 60, "< Logs >")
				except:
					pass
			elif self.setup_display_mode == "logs":
				try:
					self.Mwin.addstr(0, 1, "< Mucous >")
					self.Mwin.addstr(0, 15, "< Museek >")
					self.Mwin.addstr(0, 30, "< Shares >")
					self.Mwin.addstr(0, 45, "< Userinfo >")
					self.Mwin.addstr(0, 60, "< Logs >",  curses.A_BOLD)
				except:
					pass
			if self.setup_input_mode == "default":
				self.set_edit_title("Setup Mode")
			elif self.setup_input_mode == "interface":
				self.set_edit_title("Set Interface")
			elif self.setup_input_mode == "custom-url":
				self.set_edit_title("Set custom URL handler: command$command")
			elif self.setup_input_mode == "interface-password":
				self.set_edit_title("Set Mucous's Interface password")
			elif self.setup_input_mode=="museek-interface-password":
				self.set_edit_title("Set Museek's Interface password")
			elif self.setup_input_mode=="museek-interface-bind":
				self.set_edit_title("Add a Museek Interface")
			elif self.setup_input_mode=="server-host":
				self.set_edit_title("Set Server Address")
			elif self.setup_input_mode=="server-port":
				self.set_edit_title("Set Server Port")
			elif self.setup_input_mode=="soulseek-username":
				self.set_edit_title("Set Soulseek Username")
			elif self.setup_input_mode=="soulseek-password":
				self.set_edit_title("Set Soulseek Password")
			elif self.setup_input_mode=="slots":
				self.set_edit_title("Set Number of Upload Slots to:")
			elif self.setup_input_mode=="download-dir":
				self.set_edit_title("Set completed download directory")
			elif self.setup_input_mode=="incomplete-dir":
				self.set_edit_title("Set incompleted download directory")
			elif self.setup_input_mode=="userinfo":
				self.set_edit_title("Set UserInfo")
			elif self.setup_input_mode=="userimage":
				self.set_edit_title("Set UserImage")
			elif self.setup_input_mode=="adddir":
				self.set_edit_title("Add directory to your shares")
			elif self.setup_input_mode=="rmdir":
				self.set_edit_title("Remove directory from your shares")
			
			self.Mwin.noutrefresh()
			
			if self.setup_display_mode in ("shares"):
	
				# First Row
				self.rescanw = curses.newwin(3,16,3,1)
				self.rescanw.border()
				self.rescanw.addstr(0,1, "<muscan -r -v>")
				self.rescanw.noutrefresh()
				self.inrescanw = self.rescanw.subwin(1,14,4,2)
				self.inrescanw.scrollok(1)
				self.inrescanw.addstr("Rescan Shares", self.colors["cyan"])
				self.inrescanw.noutrefresh()
				
				self.rescaw = curses.newwin(3,16,3,17)
				self.rescaw.border()
				self.rescaw.addstr(0,1, "< muscan -v >")
				self.rescaw.noutrefresh()
				self.inrescaw = self.rescaw.subwin(1,14,4,18)
				self.inrescaw.scrollok(1)
				self.inrescaw.addstr("Update Shares", self.colors["cyan"])
				self.inrescaw.noutrefresh()
				
				self.rescaw = curses.newwin(3,16,3,33)
				self.rescaw.border()
				self.rescaw.addstr(0,1, "<-HUP museekd>")
				self.rescaw.noutrefresh()
				self.inrescaw = self.rescaw.subwin(1,14,4,34)
				self.inrescaw.scrollok(1)
				self.inrescaw.addstr("Reload Shares", self.colors["cyan"])
				self.inrescaw.noutrefresh()				
				
				# Second Row
				
				self.lrescaw = curses.newwin(3,16,6,1)
				self.lrescaw.border()
				self.lrescaw.addstr(0,1, "< muscan -l >")
				self.lrescaw.noutrefresh()
				self.inlrescaw = self.lrescaw.subwin(1,14,7,2)
				self.inlrescaw.scrollok(1)
				self.inlrescaw.addstr("List Shared", self.colors["cyan"])
				self.inlrescaw.noutrefresh()
				
				self.xshare = curses.newwin(3,16,6,17)
				self.xshare.border()
				self.xshare.addstr(0,1, "<muscan -s dir>")
				self.xshare.noutrefresh()
				self.inxshare = self.xshare.subwin(1,14,7,18)
				self.inxshare.scrollok(1)
				self.inxshare.addstr("Add Directory", self.colors["cyan"])
				self.inxshare.noutrefresh()
				
				self.xshare = curses.newwin(3,16,6,33)
				self.xshare.border()
				self.xshare.addstr(0,1, "<muscan -u dir>")
				self.xshare.noutrefresh()
				self.inxshare = self.xshare.subwin(1,14,7,34)
				self.inxshare.scrollok(1)
				self.inxshare.addstr("Remove Dir", self.colors["cyan"])
				self.inxshare.noutrefresh()
				
				self.textshare = curses.newwin(6,48,9,1)
				self.textshare.border()
				self.textshare.addstr(1,1, "Click on the buttons for the local muscan.")
				self.textshare.addstr(2,1, "When you click on Add/Remove Directory,")
				self.textshare.addstr(3,1, "Type in the directory below, and start ")
				self.textshare.addstr(4,1, " with '//' instead of just a '/'")
				self.textshare.noutrefresh()
				
			elif self.setup_display_mode in ("userinfo"):	
				
				self.inputui_w = curses.newwin(self.h-8,self.w-2,2,1)
				self.inputui_w.border()
				self.inputui_w.addstr(0,1, "<Your Userinfo>")
				self.inputui_w.noutrefresh()
				self.ininputui_w = self.inputui_w.subwin(self.h-10,self.w-4,3,2)
				self.ininputui_w.scrollok(1)
				if "text" in self.config["userinfo"]:
					for line in self.config["userinfo"]["text"]:
						try:
							self.ininputui_w.addstr(line.decode(mucous_config["mucous"]["language"], "replace"), self.colors["cyan"])
						except:
							pass
				self.ininputui_w.noutrefresh()
				
				self.inputimage = curses.newwin(1,13,self.h-6,1)
				self.inputimage.erase()
				self.inputimage.addstr( "Your Image: ")
				self.inputimage.noutrefresh()
				
				
				if "image" in self.config["userinfo"]:
					self.inputimage2 = curses.newwin(1,self.w-2-14,self.h-6,14)
					self.inputimage2.erase()
					self.inputimage2.scrollok(1)
					self.inputimage2.addstr( str(self.config["userinfo"]["image"][:self.w-3-14]))
					self.inputimage2.noutrefresh()
					
			elif self.setup_display_mode in ("logs"):
				self.buttonwin = curses.newwin(3,15,2,1)
				self.buttonwin.border()
				self.buttonwin.addstr(0, 1, "< Log Chat? >",  curses.A_BOLD)
				self.buttonwin.noutrefresh()
				self.inbuttonwin = self.buttonwin.subwin(1,13,3,2)
				self.inbuttonwin.scrollok(1)
				self.inbuttonwin.addstr(str(mucous_config["mucous"]["logging"]), self.colors["cyan"] )
				self.inbuttonwin.noutrefresh()
				
				self.bnwin = curses.newwin(3,40,5,1)
				self.bnwin.border()
				self.bnwin.addstr(0, 1, "< Log Directory >",  curses.A_BOLD)
				self.bnwin.noutrefresh()
				self.inbnwin = self.bnwin.subwin(1,38,6,2)
				self.inbnwin.scrollok(1)
				self.inbnwin.addstr(os.path.expanduser(mucous_config["mucous"]["log_dir"])[:37], self.colors["cyan"] )
				self.inbnwin.noutrefresh()
				
			elif self.setup_display_mode == "mucous":
				# Interface
				self.buttonwin = curses.newwin(3,32,2,1)
				self.buttonwin.border()
				self.buttonwin.addstr(0, 1, "< Museek Interface >",  curses.A_BOLD)
				self.buttonwin.noutrefresh()
				self.inbuttonwin = self.buttonwin.subwin(1,30,3,2)
				self.inbuttonwin.scrollok(1)
				if self.host != None:
					self.inbuttonwin.addstr(self.decode_language( mucous_config["connection"]["interface"][:28] ), self.colors["cyan"] )
				self.inbuttonwin.noutrefresh()
				self.buttonwin2 = curses.newwin(3,32,5,1)
				self.buttonwin2.border()
				self.buttonwin2.addstr(0, 1, "< Interface Password >",  curses.A_BOLD)
				self.buttonwin2.noutrefresh()
				self.inbuttonwin2 = self.buttonwin2.subwin(1,30,6,2)
				self.inbuttonwin2.scrollok(1)
				if self.password != None:
					if self.unhide=="true":
						self.inbuttonwin2.addstr(self.decode_language( self.password ), self.colors["cyan"])
					else:
						self.inbuttonwin2.addstr("*********", self.colors["cyan"])
				else:
					self.inbuttonwin2.addstr("NOT set")
				self.inbuttonwin2.noutrefresh()
				
				
				self.bwin = curses.newwin(6,22,2,33)
				self.bwin.border()
				try:
					self.bwin.addstr(0, 1, "< Stats >",  curses.A_BOLD)
				except:
					pass
				self.bwin.noutrefresh()
				self.inbwin1_1 = self.bwin.subwin(1,20,3,34)
				self.inbwin1_2 = self.bwin.subwin(1,20,4,34)
				self.inbwin1_3 = self.bwin.subwin(1,20,5,34)
				self.inbwin1_4 = self.bwin.subwin(1,20,6,34)
				self.inbwin1_1.scrollok(1)
				self.inbwin1_2.scrollok(1)
				self.inbwin1_3.scrollok(1)
				self.inbwin1_4.scrollok(1)
				if self.stats != []:
					try:
						self.inbwin1_1.addstr("Files: "+str(self.stats[3]), self.colors["cyan"] )
						self.inbwin1_2.addstr("Dirs: "+str(self.stats[4]), self.colors["cyan"] )
						self.inbwin1_3.addstr("Downloads: "+str(self.stats[2]), self.colors["cyan"] )
						self.inbwin1_4.addstr("Average speed: "+str(self.stats[1]), self.colors["cyan"] )
						#self.stats = user,  avgspeed, numdownloads, numfiles, numdirs
					except:
						pass
				else:
					if self.username != None:
						self.send(messages.PeerStats(self.username))
				self.inbwin1_1.noutrefresh()
				self.inbwin1_2.noutrefresh()
				self.inbwin1_3.noutrefresh()
				self.inbwin1_4.noutrefresh()
				
				self.buttonwin3 = curses.newwin(3,16,8,1)
				self.buttonwin3.border()
				self.buttonwin3.addstr(0, 1, "<Show Tickers>",  curses.A_BOLD)
				self.buttonwin30 = curses.newwin(3,16,11,1)
				self.buttonwin30.border()
				self.buttonwin30.addstr(0, 1, "<CycleTickers>",  curses.A_BOLD)
			
				self.buttonwin30.noutrefresh()
				self.inbuttonwin30 = self.buttonwin30.subwin(1,14,12,2)
				self.inbuttonwin30.scrollok(1)
			
				self.buttonwin_url = curses.newwin(3,16,11,17)
				self.buttonwin_url.border()
				self.buttonwin_url.addstr(0, 1, "< URL Reader >",  curses.A_BOLD)
				self.buttonwin_url.noutrefresh()
				self.inbuttonwinurl = self.buttonwin_url.subwin(1,14,12,18)
				self.inbuttonwinurl.scrollok(1)
				self.inbuttonwinurl.addstr(self.decode_language(mucous_config["mucous"]["url reader"]), self.colors["cyan"])
				self.inbuttonwinurl.noutrefresh()
				
				self.buttonlanguage = curses.newwin(3,16,11,33)
				self.buttonlanguage.border()
				self.buttonlanguage.addstr(0, 1, "< Encoding >",  curses.A_BOLD)
				self.buttonlanguage.noutrefresh()
				self.inbuttonlanguage = self.buttonlanguage.subwin(1,14,12,34)
				self.inbuttonlanguage.scrollok(1)
				self.inbuttonlanguage.addstr(mucous_config["mucous"]["language"], self.colors["cyan"])
				self.inbuttonlanguage.noutrefresh()
				
				self.autoclearw = curses.newwin(3,16,11,49)
				self.autoclearw.border()
				self.autoclearw.addstr(0, 1, "< Auto-Clear >",  curses.A_BOLD)
				self.autoclearw.noutrefresh()
				self.inautoclearw = self.autoclearw.subwin(1,14,12,50)
				self.inautoclearw.scrollok(1)
				self.inautoclearw.addstr(mucous_config["mucous"]["Auto-Clear"], self.colors["cyan"])
				self.inautoclearw.noutrefresh()
				
				self.autoretryw = curses.newwin(3,16,8,49)
				self.autoretryw.border()
				self.autoretryw.addstr(0, 1, "< Auto-Retry >",  curses.A_BOLD)
				self.autoretryw.noutrefresh()
				self.inautoretryw = self.autoretryw.subwin(1,14,9,50)
				self.inautoretryw.scrollok(1)
				self.inautoretryw.addstr(mucous_config["mucous"]["Auto-Retry"], self.colors["cyan"])
				self.inautoretryw.noutrefresh()
				
				self.beepw = curses.newwin(3,16,14,33)
				self.beepw.border()
				self.beepw.addstr(0, 1, "< Beep >",  curses.A_BOLD)
				self.beepw.noutrefresh()
				self.inbeepw = self.beepw.subwin(1,14,15,34)
				self.inbeepw.scrollok(1)
				if "beep" in mucous_config["mucous"]:
					self.inbeepw.addstr(str(mucous_config["mucous"]["beep"]), self.colors["cyan"])
				self.inbeepw.noutrefresh()
				
				
				
				self.savew = curses.newwin(3,16,14,49)
				self.savew.border()
				self.savew.noutrefresh()
				self.insavew = self.savew.subwin(1,14,15,50)
				self.insavew.scrollok(1)
				self.insavew.addstr(" Save Config", self.colors["cyan"])
				self.insavew.noutrefresh()
								
				self.buttonwin_url_c = curses.newwin(3,32,14,1)
				self.buttonwin_url_c.border()
				self.buttonwin_url_c.addstr(0, 1, "< Custom URL Reader >",  curses.A_BOLD)
				self.buttonwin_url_c.noutrefresh()
				self.inbwinurl_c = self.buttonwin_url_c.subwin(1,30,15,2)
				self.inbwinurl_c.scrollok(1)
				if "url custom prefix" in mucous_config["mucous"] and "url custom suffix" in mucous_config["mucous"]:
					self.inbwinurl_c.addstr(self.decode_language(mucous_config["mucous"]["url custom prefix"])+"$"+self.decode_language(mucous_config["mucous"]["url custom suffix"]), self.colors["cyan"])
					self.inbwinurl_c.noutrefresh()
				self.buttonwin3.noutrefresh()
				self.inbuttonwin3 = self.buttonwin3.subwin(1,15,9,2)
				self.inbuttonwin3.scrollok(1)
				self.inbuttonwin3.addstr(mucous_config["tickers"]["tickers_enabled"], self.colors["cyan"])
				self.inbuttonwin3.noutrefresh()
				self.inbuttonwin30.addstr(mucous_config["tickers"]["ticker_cycle"], self.colors["cyan"])
				self.inbuttonwin30.noutrefresh()
				self.buttonwin4 = curses.newwin(3,16,8,17)
				self.buttonwin4.border()
				self.buttonwin4.addstr(0, 1, "<Min Roomlist>", curses.A_BOLD)
				self.buttonwin4.noutrefresh()
				self.inbuttonwin4 = self.buttonwin4.subwin(1,15,9,18)
				self.inbuttonwin4.scrollok(1)
				self.inbuttonwin4.addstr(" -  "+str(mucous_config["mucous"]["roomlistminsize"]), self.colors["cyan"])
				self.inbuttonwin4.addstr(0, 11, " + ", self.colors["cyan"])
				self.inbuttonwin4.noutrefresh()
				
				self.buttonwin5 = curses.newwin(3,16,8,33)
				self.buttonwin5.border()
				self.buttonwin5.addstr(0, 1, "< Auto-Buddy >",  curses.A_BOLD)
				self.buttonwin5.noutrefresh()
				self.inbuttonwin5 = self.buttonwin5.subwin(1,15,9,34)
				self.inbuttonwin5.scrollok(1)
				if mucous_config["mucous"]["autobuddy"] != None:
					self.inbuttonwin5.addstr(mucous_config["mucous"]["autobuddy"], self.colors["cyan"])
				self.inbuttonwin5.noutrefresh()


			elif self.setup_display_mode == "museek":
				# Server
				self.buttonwin = curses.newwin(3,32,2,1)
				self.buttonwin.border()
				self.buttonwin.addstr(0, 1, "< Server >",  curses.A_BOLD)
					
				self.buttonwin.noutrefresh()
				self.inbuttonwin = self.buttonwin.subwin(1,30,3,2)
				self.inbuttonwin.scrollok(1)
				if "server" in self.config:
					self.inbuttonwin.addstr(self.decode_language( self.config["server"]["host"][:22] )+":"+self.config["server"]["port"], self.colors["cyan"] )
				self.inbuttonwin.noutrefresh()
				
				
				#------------------------
				self.buttonwin2 = curses.newwin(3,32,5,33)
				self.buttonwin2.border()
				self.buttonwin2.addstr(0, 1, "< Soulseek Password >",  curses.A_BOLD)
				self.buttonwin2.noutrefresh()
				self.inbuttonwin2 = self.buttonwin2.subwin(1,30,6,34)
	
				self.buttonwin12 = curses.newwin(3,32,5,1)
				self.buttonwin12.border()
				try:
					self.buttonwin12.addstr(0, 1, "< Museek Interface Password >",  curses.A_BOLD)
				except:
					pass
				self.buttonwin12.noutrefresh()
				self.inbuttonwin12 = self.buttonwin12.subwin(1,30,6,2)
				self.inbuttonwin12.scrollok(1)
				if "interfaces" in self.config:
					if self.unhide=="true":
						self.inbuttonwin12.addstr(self.decode_language( self.config["interfaces"]["password"] ), self.colors["cyan"])
					else:
						self.inbuttonwin12.addstr("*********", self.colors["cyan"])
				self.inbuttonwin12.noutrefresh()
				
				self.inbuttonwin2.scrollok(1)
				if self.password != None:
					if self.unhide=="true":
						if "server" in self.config:
							self.inbuttonwin2.addstr(self.decode_language( self.config["server"]["password"] ), self.colors["cyan"])
					else:
						self.inbuttonwin2.addstr("*********", self.colors["cyan"])
				else:
					self.inbuttonwin2.addstr("NOT set")

				self.inbuttonwin2.noutrefresh()
				
				#------------------------
				self.usernamewin2 = curses.newwin(3,32,2,33)
				self.usernamewin2.border()
				self.usernamewin2.addstr(0, 1, "< Soulseek Username >",  curses.A_BOLD)
				self.usernamewin2.noutrefresh()
				
				self.inusernamewin2 = self.usernamewin2.subwin(1,30,3,34)
				self.inusernamewin2.scrollok(1)
				if "server" in self.config:
					a = self.decode_language(self.config["server"]["username"])
					self.inusernamewin2.addstr(a, self.colors["cyan"])

				self.inusernamewin2.noutrefresh()
				
				self.buttonwin3 = curses.newwin(3,16,8,1)
				self.buttonwin3.border()
				self.buttonwin3.addstr(0, 1, "<Buddies-Only>",  curses.A_BOLD)
				
				self.buttonwin3.noutrefresh()
				self.inbuttonwin3 = self.buttonwin3.subwin(1,15,9,2)
				self.inbuttonwin3.scrollok(1)
				if "transfers" in self.config:
					self.inbuttonwin3.addstr(self.config["transfers"]["only_buddies"], self.colors["cyan"])
					self.inbuttonwin3.noutrefresh()
			
				self.buttonwin4 = curses.newwin(3,16,8,17)
				self.buttonwin4.border()
				self.buttonwin4.addstr(0, 1, "<Buddy Privs>", curses.A_BOLD)
				self.buttonwin4.noutrefresh()
				self.inbuttonwin4 = self.buttonwin4.subwin(1,15,9,18)
				self.inbuttonwin4.scrollok(1)
				if "transfers" in self.config:
					self.inbuttonwin4.addstr(self.config["transfers"]["privilege_buddies"], self.colors["cyan"])
				self.inbuttonwin4.noutrefresh()
			
				self.dirwin = curses.newwin(4,64,11,1)
				self.dirwin.border()
				self.dirwin.addstr(0, 1, "< Download/Incomplete Directories >",  curses.A_BOLD)
				self.dirwin.noutrefresh()
				self.dircompletewin = self.dirwin.subwin(1,61,12,2)
				if "transfers" in self.config:
					self.dircompletewin.addstr(self.decode_language(self.config["transfers"]["download-dir"]), self.colors["cyan"])

				self.dircompletewin.noutrefresh()
				self.dirincompletewin = self.dirwin.subwin(1,61,13,2)
				if "transfers" in self.config:
					self.dirincompletewin.addstr(self.decode_language(self.config["transfers"]["incomplete-dir"]), self.colors["cyan"])
				else:
					self.dirincompletewin.addstr("....", self.colors["cyan"])
				self.dirincompletewin.noutrefresh()
				
				self.buttonwin5 = curses.newwin(3,16,8,33)
				self.buttonwin5.border()
				self.buttonwin5.addstr(0, 1, "<Connections>",  curses.A_BOLD)
				self.buttonwin5.noutrefresh()
				self.inbuttonwin5 = self.buttonwin5.subwin(1,15,9,34)
				self.inbuttonwin5.scrollok(1)
				if "clients" in self.config:
					self.inbuttonwin5.addstr(self.config["clients"]["connectmode"], self.colors["cyan"])
				self.inbuttonwin5.noutrefresh()
				
				self.buttonwin6 = curses.newwin(3,16,8,49)
				self.buttonwin6.border()
				self.buttonwin6.addstr(0, 1, "<Upload Slots>",  curses.A_BOLD)
				self.buttonwin6.noutrefresh()
				
				self.inbuttonwin6 = self.buttonwin6.subwin(1,15,9,50)
				self.inbuttonwin6.scrollok(1)
				if "transfers" in self.config:
					self.inbuttonwin6.addstr(" -  " + self.config["transfers"]["upload_slots"], self.colors["cyan"])
					self.inbuttonwin6.addstr(0, 11, " + ", self.colors["cyan"])
				self.inbuttonwin6.refresh()
		except Exception, e:
			self.Hlog("debug", "setup_mode: " + str(e) )
		#self.topbar_mode()
		self.hotkeys()
		curses.doupdate()
	# TOPBAR MODE
	
	
	def topbar_mode(self):
		try:
			self.topbar =  curses.newwin(1, self.w, 0, 0)
			self.topbar.bkgdset(" ", self.colors["blafgcyabg"]  | curses.A_REVERSE | curses.A_BOLD)
			self.topbar.idlok(1)
			self.topbar.erase()
			self.topbar.refresh()
							
			self.onlinestatus =  curses.newwin(1, 8, 0, 0)
			self.onlinestatus.bkgdset(" ", self.colors["blafgcyabg"]  |curses.A_REVERSE | curses.A_BOLD)
			self.onlinestatus.idlok(1)
			try:
				self.onlinestatus.erase()
				self.onlinestatus.addstr(self.onlinestatuslog,  self.colors["blafgcyabg"] )
			except:
				pass
			self.onlinestatus.refresh()
			
			self.uploadwin = curses.newwin(1, 10, 0, 25)
			self.uploadwin.bkgdset(" ", self.colors["blafgcyabg"]  | curses.A_REVERSE | curses.A_BOLD)
			self.uploadwin.idlok(1)
			try:
				self.uploadwin.erase()
				self.uploadwin.addstr(self.uploadlog,  self.colors["blafgcyabg"] )
			except:
				pass
			self.uploadwin.refresh()
			
			self.downloadwin = curses.newwin(1, 12, 0, 35)
			self.downloadwin.bkgdset(" ", self.colors["blafgcyabg"]  | curses.A_REVERSE | curses.A_BOLD)
			self.downloadwin.idlok(1)
			try:
				self.downloadwin.erase()
				self.downloadwin.addstr(self.downloadlog,  self.colors["blafgcyabg"] )
			except:
				pass
			self.downloadwin.refresh()
			
		
			self.searchwin = curses.newwin(1, 15, 0, 47)
			self.searchwin.bkgdset(" ", self.colors["blafgcyabg"]  | curses.A_REVERSE | curses.A_BOLD)
			self.searchwin.idlok(1)
			try:
				self.searchwin.erase()
				self.searchwin.addstr(self.searchwinlog[0],  self.colors["blafgcyabg"] )
				self.searchwin.addstr(str(self.searchwinlog[1]),  self.colors["blafgcyabg"] )
			except:
				pass
			self.searchwin.refresh()
		
		
			self.alertwin = curses.newwin(1, 15, 0, self.w-15)
			self.alertwin.bkgdset(" ", self.colors["blafgcyabg"]  | curses.A_REVERSE | curses.A_BOLD)
			self.alertwin.idlok(1)
			
			self.alert_status(self.alertwinlog)
		
			self.usernamewin = curses.newwin(1, 16, 0, 9)
			self.usernamewin.idlok(1)
			self.usernamewin.bkgdset(" ", self.colors["blafgcyabg"]  | curses.A_REVERSE | curses.A_BOLD)
			
			if self.username != None:
				try:
					self.usernamewin.erase()
					self.usernamewin.addstr(self.decode_language(self.username[:15]),  self.colors["blafgcyabg"] )
				except:
					pass
			self.usernamewin.refresh()
		
		except Exception,e :
			self.Hlog("debug", "topbar mode" + str(e))

		
	def hotkeys(self):
		self.bottomwin = curses.newwin(1, self.w-1, self.h-1, 0)
		try:
			self.bottomwin.addstr(" 1",  curses.A_BOLD)
			if self.DisplayMode == "chat":
				if self.alert["CHAT"] != {}:
					nick = 0
					for room, status in self.alert["CHAT"].items():
						if status == "nick":
							nick = 1
					if nick == 1:
						self.bottomwin.addstr("Chat", self.colors["red"] |curses.A_BOLD |curses.A_REVERSE )
					else:
						self.bottomwin.addstr("Chat", self.colors["yellow"] |curses.A_BOLD |curses.A_REVERSE )
				else:
					self.bottomwin.addstr("Chat",  curses.A_REVERSE |  self.colors["greenbg"])
			else:
				if self.alert["CHAT"] != {}:
					nick = 0
					for room, status in self.alert["CHAT"].items():
						if status == "nick":
							nick = 1
					if nick == 1:
						self.bottomwin.addstr("Chat", self.colors["red"] | curses.A_REVERSE )
					else:
						self.bottomwin.addstr("Chat", self.colors["yellow"] | curses.A_REVERSE )
				else:
					self.bottomwin.addstr("Chat",  self.colors["cybg"])
			self.bottomwin.addstr(" 2",  curses.A_BOLD)
			if self.DisplayMode == "private":
				if self.alert["PRIVATE"] != []:
					self.bottomwin.addstr("Private", self.colors["yellow"] |curses.A_BOLD |curses.A_REVERSE )
				else:
					self.bottomwin.addstr("Private",curses.A_REVERSE |  self.colors["greenbg"])
			else:
				if self.alert["PRIVATE"] != []:
					self.bottomwin.addstr("Private", self.colors["yellow"] |curses.A_REVERSE )
				else:
					self.bottomwin.addstr("Private", self.colors["cybg"])
			self.bottomwin.addstr(" 3",   curses.A_BOLD)
			if self.DisplayMode == "transfer":
				self.bottomwin.addstr("Transfers",curses.A_REVERSE |  self.colors["greenbg"])
			else:
				self.bottomwin.addstr("Transfers", self.colors["cybg"])
			
			self.bottomwin.addstr(" 4",  curses.A_BOLD)
			if self.DisplayMode == "search":
				if self.alert["SEARCH"] != []:
					self.bottomwin.addstr("Search", self.colors["yellow"] |curses.A_REVERSE |curses.A_BOLD)
				else:
					self.bottomwin.addstr("Search",curses.A_REVERSE |  self.colors["greenbg"])
			else:
				if self.alert["SEARCH"] != []:
					self.bottomwin.addstr("Search", self.colors["yellow"] |curses.A_REVERSE )
				else:
					self.bottomwin.addstr("Search", self.colors["cybg"])
			self.bottomwin.addstr(" 5",  curses.A_BOLD)
			if self.DisplayMode == "info":
				if self.alert["INFO"] != []:
					self.bottomwin.addstr("Info", self.colors["yellow"] |curses.A_REVERSE |curses.A_BOLD)
				else:
					self.bottomwin.addstr("Info",curses.A_REVERSE |  self.colors["greenbg"])
			else:
				if self.alert["INFO"] != []:
					self.bottomwin.addstr("Info", self.colors["yellow"] |curses.A_REVERSE )
				else:
					self.bottomwin.addstr("Info", self.colors["cybg"])
			self.bottomwin.addstr(" 6",  curses.A_BOLD)
			if self.DisplayMode == "browse":
				if self.alert["BROWSE"] != []:
					self.bottomwin.addstr("Browse", self.colors["yellow"] |curses.A_REVERSE |curses.A_BOLD)
				else:
					self.bottomwin.addstr("Browse",curses.A_REVERSE |  self.colors["greenbg"])
			else:
				if self.alert["BROWSE"] != []:
					self.bottomwin.addstr("Browse", self.colors["yellow"] |curses.A_REVERSE)
				else:
					self.bottomwin.addstr("Browse", self.colors["cybg"])
	
			self.bottomwin.addstr(" 7",  curses.A_BOLD)
			if self.DisplayMode == "lists":
				self.bottomwin.addstr("Users",curses.A_REVERSE |  self.colors["greenbg"])
			else:
				self.bottomwin.addstr("Users",  self.colors["cybg"])
	
			self.bottomwin.addstr(" 8",  curses.A_BOLD)
			if self.DisplayMode == "rooms":
				self.bottomwin.addstr("Rooms",curses.A_REVERSE |  self.colors["greenbg"])
			else:
				self.bottomwin.addstr("Rooms", self.colors["cybg"])
	
			self.bottomwin.addstr(" 9",  curses.A_BOLD)
			if self.DisplayMode == "setup":
				self.bottomwin.addstr("Setup",curses.A_REVERSE |  self.colors["greenbg"])
			else:
				self.bottomwin.addstr("Setup",  self.colors["cybg"])
			self.bottomwin.addstr(" 10",  curses.A_BOLD)
			if self.DisplayMode in ("debug", "help", "status"):
				if self.alert["HELP"] != []:
					self.bottomwin.addstr("Help", self.colors["yellow"] |curses.A_BOLD |curses.A_REVERSE )
				else:
					self.bottomwin.addstr("Help",curses.A_REVERSE |  self.colors["greenbg"])
			else:
				if self.alert["HELP"] != []:
					self.bottomwin.addstr("Help", self.colors["yellow"] | curses.A_REVERSE )
				else:
					self.bottomwin.addstr("Help",  self.colors["cybg"])
		except:
			pass
		self.bottomwin.noutrefresh()

	# ---^  MODES ^
		
	# --- TEXT PLACEMENT v
	def log_to_file(self, messagetype, timestamp, place, message):
		if '/' in place:
			place = place.replace("/", "\\")
		path = os.path.join(os.path.expanduser(mucous_config["mucous"]["log_dir"]), messagetype, place)
		dir = os.path.split(path)[0]
		try:
			if not os.path.isdir(dir):
				os.makedirs(dir)
			f = open(path, "a")
			message.replace("\n","\\n")
			f.write("%s %s\n" % (timestamp, message))
			f.close()
		except:
			self.Hlog("status", "Cannot write to file %s, check permissions" % path)
		
	def display_search(self, line):
		if self.DisplayMode == "search":
			try:
				self.textwin.addstr(self.decode_language(line))
			except:
				pass
			

	def start_pm(self, user):
		try:
			self.pm_user = user
			if user not in self.privatelog.keys():
				self.privatelog[user] = []
				if mucous_config["mucous"]["logging"] in (True, "True"):
					self.add_logs_to_private(user)
				
			if self.DisplayMode == 'private':
				self.private_mode()
		except Exception, e:
			self.Hlog("debug", "start_pm: " + str(e))
			
	def private_log(self, pmtype, user, message):
		try:
			timestamp = time.strftime("%H:%M:%S")
			if user not in self.privatelog.keys():
				self.privatelog[user]=['']
	
			if message[:4] == "/me ":
				if pmtype == "outgoing":
					self.privatelog[user].append("%s * %s %s" % (timestamp, self.username,  message[4:]))
				elif pmtype == "incoming":
					self.privatelog[user].append("%s * %s %s" % (timestamp, user,  message[4:]))
			else:
				
				if pmtype == "outgoing":
					self.privatelog[user].append("%s You told %s: %s" % (timestamp, user, message))
				elif pmtype == "incoming":
					self.privatelog[user].append("%s %s said: %s" % (timestamp, user, message))
					
			if self.pm_user == None:
				self.pm_user = user
				if self.DisplayMode == "private":
					self.private_mode()
			elif self.pm_user == user:
				if self.DisplayMode == "private":
					self.private_mode()
			elif self.pm_user != user and self.pm_user != None:
				self.alert_status("PM: "+user)
				
		except Exception, e:
			self.Hlog( "debug", "private_log: " + str(e))
				
	def info_log(self, s):
		s= self.decode_language(s)
		if "\n" in s:
			lis = s.split("\n")
			for line in lis:
				self.infolog.append("%s" % line)
		else:
			self.infolog.append("%s" % s)
		if self.DisplayMode == "info" and self.info_user == None:
			self.info_display()
			
	def buddy_log(self, mtype, user, note):
		self.buddylog.append([mtype, user, note])

	def ban_log(self, mtype, user, note):
		self.banlog.append([mtype, user, note])

	def ignore_log(self, mtype, user, note):
		self.ignorelog.append([mtype, user, note])

	def log_window(self, user, room, did, what):
		yes = 0
		if did == "ticker" and what != '':
			if user in self.rooms[room]:
				#self.statuslogs[room].append("\n%s %s set ticker to %s" % (time.strftime("%H:%M:%S"), user, what))
				if room == self.current_room:
					yes =1
					
		elif did == "join":
			self.statuslogs[room].append("\n%s %s joined" % (time.strftime("%H:%M:%S"), user))
			if room == self.current_room:
				yes =1
				
		elif did == "left":
			self.statuslogs[room].append("\n%s %s left" % (time.strftime("%H:%M:%S"), user))
			if room == self.current_room:
				yes =1
		elif did == "change":
			for rooms11 in self.rooms.keys():
				if user in self.rooms[rooms11]:
					string = "\n%s %s is %s" % (time.strftime("%H:%M:%S"), user, what)
					if self.statuslogs[rooms11] == []:
						self.statuslogs[rooms11].append(string)
						if rooms11 == self.current_room:
							yes =1
					elif string[10:] != self.statuslogs[rooms11][-1][10:]:
						self.statuslogs[rooms11].append(string)
						if rooms11 == self.current_room:
							yes = 1
							
		
		if self.DisplayMode == "chat":
			try:
				if self.chatdisplaymode not in ("chat-only", "nostatuslog") and yes == 1:
					if self.showmenu == True: raise  Exception,  "popup"
					if self.statuslogs[self.current_room][-1] is self.statuslogs[self.current_room][0]:
						self.logwin.addstr(self.decode_language( self.statuslogs[self.current_room][-1][1:] ))
					else:
						self.logwin.addstr(self.decode_language( self.statuslogs[self.current_room][-1] ))
					
					self.logwin.refresh()
			except Exception, e:
				pass
				#self.Hlog("debug", e)
			
			
	def uptransfer_log(self, s):
		self.uptransferlog.append("\n%s" % s)

		if self.DisplayMode == "transfer":
			try:
				if self.transferscroll=="upload":
					self.upwin.addstr(self.decode_language( self.uptransferlog[-1] ))
					self.upwin.refresh()
			except:
				pass
			
			
	def downtransfer_log(self, s):
		self.downtransferlog.append("\n%s" % s)

		if self.DisplayMode == "transfer":
			try:
				if self.transferscroll=="download":
					self.downwin.erase()
					self.downwin.addstr(self.decode_language( self.downtransferlog[-1] ))
					self.downwin.refresh()
			except:
				pass
			
			
	def search_status(self, s):
		if self.searchwinlog == ["Results: ", s]:
			pass
		else:
			self.searchwinlog = "Results: ", s
			try:
				self.searchwin.erase()
				self.searchwin.addstr(self.searchwinlog[0],  self.colors["blafgcyabg"] )
				self.searchwin.addstr(str(self.searchwinlog[1]),  self.colors["blafgcyabg"] )
				self.searchwin.refresh()
			except Exception, e:
				self.Hlog( "debug", "Search Status: " + str(e))
		
		
	def upload_status(self, s):
		if self.uploadlog == "Up: %s" %str(s):
			pass
		else:
			self.uploadlog = "Up: %s" %str(s)
			try:
				self.uploadwin.erase()
				self.uploadwin.addstr(self.uploadlog, self.colors["blafgcyabg"] )
				self.uploadwin.refresh()
			except Exception, e:
				self.Hlog( "debug", "Upload Status: " + str(e))
		
		
	def download_status(self, s):	
		if self.downloadlog == "Down: %s" %str(s):
			pass
		else:
			self.downloadlog = "Down: %s" %str(s)
			try:
				self.downloadwin.erase()
				self.downloadwin.addstr(self.downloadlog, self.colors["blafgcyabg"] )
				self.downloadwin.refresh()
			except Exception, e:
				self.Hlog( "debug", "Download Status: " + str(e))

	def check_alert_state(self):
		if self.DisplayMode == "chat":
			if self.current_room in self.alert["CHAT"].keys():
				del self.alert["CHAT"][self.current_room]
		elif self.DisplayMode == "private":
			if self.pm_user in self.alert["PRIVATE"]:
				self.alert["PRIVATE"].remove(self.pm_user)
		elif self.DisplayMode == "browse":
			if self.browse_current in self.alert["BROWSE"] and self.browse_current != "__default":
				self.alert["BROWSE"].remove(self.browse_current)
		elif self.DisplayMode == "search":
			if self.chosen_search in self.alert["SEARCH"]:
				self.alert["SEARCH"].remove(self.chosen_search)
		elif self.DisplayMode == "info":
			if self.info_user in self.alert["INFO"]:
				self.alert["INFO"].remove(self.info_user)
		elif self.DisplayMode in ("help", "debug", "status"):
			#if ("debug", "help", "status") in self.alert["HELP"]:
			self.alert["HELP"] = []
		self.alert_next()
		self.hotkeys()


	def alert_next(self):
		try:
			if self.DisplayMode ==  "search":
				if self.alert[self.DisplayMode.upper()] != []:
					for s in self.alert[self.DisplayMode.upper()]:
						self.alert_status(self.s_query[s])
						return
				else:
					self.alert_pick()
			if self.DisplayMode in ("info", "private",  "browse"):
			#if self.DisplayMode.upper() in ("PRIVATE", "TRANSFERS",  "SEARCH", "INFO", "BROWSE"):
			
				if self.alert[self.DisplayMode.upper()] != []:
					for s in self.alert[self.DisplayMode.upper()]:
						self.alert_status(s)
						return
				else:
					self.alert_pick()
			elif self.DisplayMode.upper()  == "CHAT":
				if self.alert[self.DisplayMode.upper()] != {}:
					for m, l in self.alert["CHAT"].items():
						self.alert_status(m)
						return
					self.alert_status("")
				else:
					self.alert_pick()
			elif self.DisplayMode in ("help", "debug", "status"):
				for s in self.alert["HELP"]:
					if s == "help":
						self.alert_status("New Help")
					elif s == "debug":
						self.alert_status("New Bug")
					elif s == "status":	
						self.alert_status("New Status")
					break
				else:
					self.alert_pick()
			else:
				self.alert_pick()
		except Exception, e:
			self.Hlog( "debug", "alert_next: " + str(e))
			
	def alert_pick(self):
		try:
			for mode, lists in self.alert.items():
				#self.helplog.append(str(mode)+" " +str(l))
				if lists == []:
					continue
				elif lists == {}:
					continue
				
				if mode == "HELP":
					for s in self.alert["HELP"]:
						if s == "help":
							self.alert_status("New Help")
						elif s == "debug":
							self.alert_status("New Bug")
						elif s == "status":	
							self.alert_status("New Status")
						break
					return
				elif mode == "SEARCH":
					for s in self.alert["SEARCH"]:
						self.alert_status(self.s_query[s])
						return

				for i in lists:
					if i != "":
						self.alert_status(i)
						return
			self.alert_status("")
		except Exception, e:
			self.Hlog( "debug", "alert_pick: " + str(e))
			
	def alert_status(self, s):
		try:
			self.alertwinlog = s
			self.alertwin.erase()
			
			if len(self.alertwinlog[:14]) < 13 and len(self.alertwinlog[:14]) > 0:
				line = " "+self.decode_language( self.alertwinlog[:14] )+" "
			else:
				line = self.decode_language( self.alertwinlog[:14] )
			self.alertwin.addstr(line, self.colors["yellow"] )
			self.alertwin.refresh()
		except Exception, e:
			self.Hlog( "debug", "Alert Status: " + str(e))
				
				
	def shutdown(self):
		# Quit		
		self.timer.cancel()
		self.ticker_timer.cancel()
		self.muscan_timer.cancel()
		self.retry_timer.cancel()
		self.clear_timer.cancel()
		self.get_shares_timer.cancel()

		self.stdscr.keypad(0)
		curses.nocbreak()
		curses.echo()
		curses.endwin()
	
		os._exit(1)
	# --- TEXT PLACEMENT ^
try:
	curses.wrapper(mucous())
except Exception, e:
	print e