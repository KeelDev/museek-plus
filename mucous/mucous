#! /usr/bin/python
#-*- coding: utf-8 -*-
 
##########################################################################
# Mucous - a Python/Curses client for Museek                             #
##########################################################################
#
# Majority of code (C) 2005-2006 daelstorm <daelstorm@gmail.com>
#
# Based on Museekchat
# Copyright (C) 2003-2004 Hyriand <hyriand@thegraveyard.org>
# Config-parsing code modified from Nicotine's config.py
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

import sys
try:
	import mucipher
except:
	print "WARNING: The Mucipher Module for Python wasn't found. This is absolutely necessary to allow Mucous to connect to the Museek Daemon.\nDownload it here: http://thegraveyard.org/files/pymucipher-0.0.1.tar.gz\nExtract the tarball, and as Root or sudo, run:\npython setup.py install\nYou'll need GCC, Python and SWIG."
	sys.exit()
try:
	import messages, driver
except:
	try:
		from museek import messages, driver
	except:
		print "WARNING: The Museek Message-Parsing modules, messages.py and/or driver.py  were not found. Please install them into your '/usr/lib/python2.X/site-packages/museek' directory, or place them in a 'museek' subdirectory of the directory that contains the mucous python script."
		sys.exit()
	
import signal, time, os, commands, getopt, threading, select, string, re, ConfigParser
import curses.wrapper, curses.ascii

from time import sleep

from UserDict import UserDict

subprocess_fail=0
geoip_fail=0

try:
	import subprocess
except ImportError:
	subprocess_fail=1
try:
	import GeoIP
	gi = GeoIP.new(GeoIP.GEOIP_MEMORY_CACHE)
except ImportError:
	geoip_fail=1
	print "Optional Python Module GeoIP not found, you can safely disregard this message."

config_dir = str(os.path.expanduser("~/.mucous/"))
log_dir = None #str(os.path.expanduser("~/.mucous/logs/"))
config_file = config_dir+"config"
try:
	from pymucous.utils import Version
except:
	print "WARNING: can't find pymucous.utils, setting version to be unknown."
	Version = "unknown"
## Command Options
def usage():
	print ("""Mucous is a client for Museek, the P2P Soulseek Daemon
Author: Daelstorm
Credit: Hyriand
Version: %s
	Default options: none
	-c,	--config <file>	Use a different config file
	-l,	--log <dir>	Use a different logging directory
	-v,	--version	Display version and quit

	-h,	--help		Display this help and exit
	""" %Version)
	sys.exit(2)
	
try:
	opts, args = getopt.getopt(sys.argv[1:], "hc:vl:p", ["profile", "help", "config=", "version", "log="])
except getopt.GetoptError:
	usage()
	sys.exit(2)
profile = 0
for opts, args in opts:

	if opts in ("-p", "--profile"):
		profile = 1
	elif opts in ("-h", "--help"):
		usage()
		sys.exit()
	if opts in ("-c", "--config"):
		config_file=str(os.path.expanduser(args))
	if opts in ("-l", "--log"):
		log_dir=str(os.path.expanduser(args))
	if opts in ("-v", "--version"):
		print "Mucous version: %s" % Version
		sys.exit(2)
		

# default config
mucous_config = {"connection":{"interface":'localhost:2240', "passw":None}, \
	"mucous":{"autobuddy": "no", "roomlistminsize": 5, "rooms_sort": "size", \
	"roombox": "big", "log_dir": "~/.mucous/logs/", "now-playing": "default", \
	"now-playing-prefix": None, "browse_display_mode": "filesystem", "browse_width": 25, \
	"url reader": "firefox", "url custom prefix": "", "url custom suffix": "", \
	"transbox" : "split", "language": "iso-8859-1", "beep": "yes", "autoaway": "yes", \
	"auto-retry": "yes", "auto-clear": "no", "logging": "yes", "extra_requests": "Yes"}, \
	"tickers":{'tickers_enabled': 'yes', "ticker_cycle": "no", "rooms":{}, "ticker_scroll": "yes", "scrolltime": "0.3", "cycletime": "3.0"}, \
	"aliases": {"mucous":"Mucous is a Curses client for the Museek Soulseek Daemon. Website: http://thegraveyard.org/daelstorm/mucous.php", "museek":"Museek+ is a Soulseek Daemon/Client. The website is http://museek-plus.org/"},\
	"rooms": {"default_room":"museek"}\
	}
		

## Dictionary that's sorted alphabetically
# @param UserDict dictionary to be alphabetized	
class SortedDict(UserDict):
	## Constructor
	# @param self SortedDict
	def __init__(self):
		self.__keys__ = []
		self.__sorted__ = True
		UserDict.__init__(self)
		
	## Set key
	# @param self SortedDict
	# @param key dict key
	# @param value dict value
	def __setitem__(self, key, value):
		if not self.__dict__.has_key(key):
			self.__keys__.append(key) 
			self.__sorted__ = False   
		UserDict.__setitem__(self, key, value)
	## Delete key
	# @param self SortedDict
	# @param key dict key
	def __delitem__(self, key):
		self.__keys__.remove(key)
		UserDict.__delitem__(self, key)
	## Get keys
	# @param self SortedDict
	# @return __keys__ 
	def keys(self):
		if not self.__sorted__:
			self.__keys__.sort()
			self.__sorted__ = True
		return self.__keys__
	## Get items
	# @param self SortedDict
	# @return list of keys and items
	def items(self):
		if not self.__sorted__:
			self.__keys__.sort()     
			self.__sorted__ = True
		for key in self.__keys__:
			yield key, self[key]		
alpha_list  = SortedDict()

## Modify and read the Mucous Config
#
class ConfigManager:
	## Constructor
	# @param self ConfigManager
	def __init__(self):
		## @var parser
		# ConfigParser instance
		self.parser = ConfigParser.ConfigParser()
		
	## Create config dict from config file
	# @param self ConfigManager
	def create_config(self):
	
		self.parser.read([config_file])
	
		mucous_config_file = file(config_file, 'w')
		
		for i in mucous_config.keys():
			if not self.parser.has_section(i):
				self.parser.add_section(i)
			for j in mucous_config[i].keys():
				if j not in ["nonexisting", "hated", "options"]:
					self.parser.set(i,j, mucous_config[i][j])
				else:
					self.parser.remove_option(i,j)
		self.parser.write(mucous_config_file)
		mucous_config_file.close()	
	
	## Create config file and parse options
	# @param self ConfigManager
	def read_config(self):
		
		self.parser.read([config_file])
		for i in self.parser.sections():
			for j in self.parser.options(i):
				val = self.parser.get(i,j, raw = 1)
	
				if j in ['login','passw','interface', 'roombox', 'tickers_enabled', "ticker_cycle", "ticker_scroll", "scrolltime", "cycletime", 'default_room', "autobuddy", "now-playing", "log_dir", "aliases" "now-playing-prefix", "browse_display_mode", "url reader", "url custom prefix", "url custom suffix", "transbox", "autoaway", "rooms_sort", "logging", "beep", "auto-clear", "auto-retry", "extra_requests"] :
					if val != "None":
						mucous_config[i][j] = val
				elif i == 'aliases':
					if val != "None":
						mucous_config[i][j] = val
				else:
					try:
						mucous_config[i][j] = eval(val, {})
					except:
						mucous_config[i][j] = None
	
	## Write config file to disk
	# @param self ConfigManager
	def update_config(self):
		mucous_config_file = file(config_file, 'w')
		for i in mucous_config.keys():
			if not self.parser.has_section(i):
				self.parser.add_section(i)
			for j in mucous_config[i].keys():
				if j not in ["somethingwrong"]:
					self.parser.set(i,j, mucous_config[i][j])
				else:
					self.parser.remove_option(i,j)
		self.parser.write(mucous_config_file)
		mucous_config_file.close()
	
	## Check the filesystem for the existance of the config file
	# Create it if it doesn't exist
	# Read it if it does exist 
	# @param self ConfigManager
	def check_path(self):
		if os.path.exists(config_dir):
			if os.path.exists(config_file) and os.stat(config_file)[6] > 0:
				self.read_config()
			else:
				self.create_config()
				
		else:
			os.mkdir(config_dir, 0700)
			create_config()
			
config_manager = ConfigManager()
config_manager.check_path()

# Config corrections
if log_dir != None and log_dir != "":
	mucous_config["mucous"]["log_dir"] = str(os.path.expanduser(log_dir))
	
elif "log_dir" in mucous_config["mucous"]:
	if mucous_config["mucous"]["log_dir"] in ("", None, "None"):
		mucous_config["mucous"]["log_dir"] = str(os.path.expanduser("~/.mucous/logs/"))

if str(mucous_config["mucous"]["logging"]) == "True":
	mucous_config["mucous"]["logging"] = "yes"

		
## Input line 
# :: Here we detect which keys have been pressed
class CharacterParse(threading.Thread):
	## Constructor
	# @param self is CharacterParse
	# @param mucous is the Mucous class
	def __init__(self, mucous):
		threading.Thread.__init__(self)
		## @var mucous
		# Mucous (Class)
		self.mucous = mucous
		## @var win
		# Input line curses instance 
		self.win = mucous.windows["input"]
		## @var h
		# height of input window
		## @var w
		# width of input window
		self.h, self.w = self.win.getmaxyx()
		## @var scroll
		# cursor position
		self.scroll = 0
		## @var line
		# string containing the inputed data
		self.line = mucous.line
		## @var length
		# length of line
		self.length = len(self.line)
		## @var escape
		# was an escape key (Alt/Meta/Escape) pressed? (True/False)
		self.escape = False
		## @var word
		# last word in line
		self.word = None
		## @var listline
		# line split up into a list
		self.listline = mucous.listline
		## @var firsttab
		# was the tab pressed before? (True/False)
		self.firsttab = 0
		
		self.fixpos()
		
	## Add normal characters to the line, or respond to escaped characters or mouse presses
	# @param self CharacterParse
	# @param c the character recieved by getkey
	# @return (True/False)
	def process(self, c):
		try:
			pos = self.length + self.scroll
			
			# debugging: display keypress
			#self.mucous.Help.Log("debug", c )
			
			# Toggle online ONLY if inactivity timeout was met
			if self.mucous.timedout == True:
				self.mucous.ToggleAwayStatus()
				self.mucous.timedout = False
			if self.mucous.Spl["status"] == 0 and mucous_config["mucous"]["autoaway"] == "yes":
				# Restart inactivity timeout for every key or mousepress if not away, currently
				self.mucous.timeout_timer.cancel()
				self.mucous.timeout_timer = threading.Timer(self.mucous.timeout_time, self.mucous.AwayTimeout)
				self.mucous.timeout_timer.start()
			else:
				self.mucous.timeout_timer.cancel()

	
			if c != chr(9) and c !="KEY_MOUSE":  # Clear self.word if tab wasn't pressed
				self.word = None
				self.firsttab = 0
				self.listline = []
			elif c not in ("KEY_UP", "KEY_DOWN"):
				self.mucous.Spl["history_count"] = -1

			if c == "KEY_MOUSE":
				error = 'mouse'
				if not self.escape:
					line = self.mucous.InputFunctions(c, self.line)
					if line != None:
						self.line = line
						self.length = len(self.line)
			elif c == "KEY_LEFT" or c == chr(2):
				error = 'left'
				if self.escape:
					self.mucous.InputFunctions(c, self.line)
				else:
					self.length -= 1
			
			elif c == "KEY_RIGHT" or c == chr(6):
				error = 'right'
				if self.escape:
					self.mucous.InputFunctions(c, self.line)
				else:
					self.length += 1
			elif c in ("KEY_F(1)", "KEY_F(2)", "KEY_F(3)", "KEY_F(4)", "KEY_F(5)", "KEY_F(6)", "KEY_F(7)", "KEY_F(8)", "KEY_F(9)", "KEY_F(10)"):
				if not self.escape:
					self.mucous.InputFunctions(c, self.line)
				
			elif c in ("KEY_UP", "KEY_DOWN"):
				# Scrolling
				if not self.escape:
					line = self.mucous.InputFunctions(c, self.line)
					if line != None:
						self.line = line
						self.length = len(self.line)
					
				elif self.escape:
					# Alt+Up/Down
					line, self.mucous.Spl["history_count"] = self.mucous.InputHistory(c, self.line, self.mucous.Spl["history_count"])
					if line is not None:
						self.line = line
						self.length = len(self.line)
			elif c in ("KEY_SELECT", "KEY_FIND", "KEY_PPAGE", "KEY_NPAGE", "KEY_HOME", "KEY_END"): 
				# Scrolling
				if c == "KEY_SELECT":
					c = "KEY_NPAGE"
				elif c == "KEY_FIND":
					c = "KEY_PPAGE"
				if not self.escape:
					line = self.mucous.InputFunctions(c, self.line)
					if line != None:
						self.line = line
						self.length = len(self.line)
			elif c == "KEY_IC": # Insert
				self.mucous.InputFunctions(c, self.line)
			
			elif c in ("t", "T", "p", "P", "d", "D", "x", "X"):
				if self.escape:
					if c in ("t", "T"):
						self.mucous.InputFunctions("switch", self.line)
					elif c in ("d", "D"):
						self.mucous.InputFunctions("delete", self.line)
					elif c in ("p", "P"):
						self.mucous.InputFunctions("popup", self.line)
					elif c in ("x", "X"):
						self.mucous.InputFunctions("collapse", self.line)
				else:
					self.line = self.line[:pos] + c + self.line[pos:]
					self.length += 1
			elif c == chr(1): 
				# Ctrl-A
				self.length = self.scroll = 0
			elif c == chr(5):
				# Ctrl-E
				self.length = len(self.line)
			# elif c == chr(32):
				#self.mucous.Help.Log("debug", "space")
			# elif c == chr(13):
				#pass
				#self.mucous.Help.Log("debug", "carriage")
			elif c == "KEY_ENTER" or c == chr(10):
				# Keypad Enter, Normal Enter, or Newline pasted from another app
				if self.mucous.PopupMenu.show == True:
					self.mucous.PopupMenu.Enter()
				else:
					self.escape = False
					self.mucous.InputFunctions(c, self.line)
					return True
			
			
			elif c == chr(9): 
				# Tab
				if self.word == None:
					#self.length
					#w = self.line.split(' ')
					#self.word = w[-1]
					w = self.line[:self.length].split(' ')
					
					self.word = w[-1]
					self.listline = self.line.split(" ")
				w = self.line[:self.length].split(' ')
				lw = len(w)
				cpos = lw - 1
				currentword = w[cpos]
				if self.firsttab == None:
					self.firsttab = 0
				# if a space is in currentword, it won't be in the listline, so match it with a multi-space word
				#self.mucous.Help.Log("debug", self.word)
				if currentword not in self.listline:
					for word in self.listline:
						if word.upper().endswith(currentword.upper()):
							currentword = word
							cpos = self.listline.index(currentword)
							
				self.listline, self.firsttab, self.word, xpos = self.mucous.InputTabCompletion(self.line, self.word, self.firsttab, self.listline, cpos)
				if self.listline == []:
					return False
				self.line = ''
				# position in listline
				posx = 0
				# segments in listline
				ll = len(self.listline) -1
				# put line back together
				for r in self.listline:
					
					if posx != ll:
						self.line += r +' '
						# place cursor at end of current word
						if posx == xpos:
							self.length = len(self.line)-1
					elif posx == ll:
						self.line +=r
						# Place cursor at end of line
						if posx == xpos:
							self.length = len(self.line)
					posx += 1
				
				#self.length = len(self.line)
				#return False
			elif c == chr(11): 
				# Ctrl-K
				# Delete everything after cursor position
				self.line = self.line[:pos]
				self.length = len(self.line)
				self.scroll = 0
			elif c == chr(21): 
				# Ctrl-U
				# Delete line
				self.line = ''
				self.length = 0
			elif c == chr(23): 
				# Ctrl-W
				# Delete word before cursor
				z = self.line.split(' ')
	
				if len(z) >1:
					if z[-1] != ' ' and z[-1] != '':
						self.line = ''
						for s in z:
							if s is not z[-1]:
								self.line = self.line + s +" "
							elif s is z[-1]:
								self.line = self.line
								break
					else:
						self.line = ''
						for s in z:
							if s not in (z[-1], z[-2]):
								self.line = self.line + s +" "
							elif s is z[-2]:
								self.line = self.line
								break
				else:
					self.line = ''
				self.length = len(self.line)
			elif c == chr(27):
				# Escape ^[
				if self.mucous.PopupMenu.show == True:
					self.mucous.PopupMenu.Clear()
				else:
					self.escape = True
					return False
			elif c == chr(93) or c == chr(91) or c == chr(60) or c == chr(62):
				# ], [, <, >
				if self.escape:
					self.mucous.InputFunctions(c, self.line)
				else:
					self.line = self.line[:pos] + c + self.line[pos:]
					self.length += 1
			elif c == "KEY_DC"  or c == chr(4):
				# Delete
				# Delete letter after cursor
				self.line = self.line[:pos] + self.line[pos+1:]
			elif c == "KEY_BACKSPACE" or c == chr(8) or c == chr(127):
				# Backspace, Ctrl-H
				# Delete letter before cursor
				if pos > 0:
					self.line = self.line[:pos-1] + self.line[pos:]
					self.length -= 1
	
			elif len(c) == 1 and ord(c[0]) >= 32 and ord(c[0]) < 127:
				# ASCII letters 
				self.line = self.line[:pos] + c + self.line[pos:]
				self.length += 1
			elif len(c) == 1 and ord(c[0]) > 127 and ord(c[0]) < 256:
				# ISO8859-* characters
				self.line = self.line[:pos] + c + self.line[pos:]
				self.length += 1
	
			self.fixpos()
			self.mucous.line = self.line
			self.escape = False
			return False
		except Exception, e:
			self.mucous.Help.Log("debug", "CharacterParse process: \""+str(self.line)+"\" "+ str(e))
			
	## Allow for horizontal scrolling of line
	# @param self CharacterParse
	def fixpos(self):
		try:
			while self.scroll + self.length > len(self.line):
				self.length -= 1
				
			while self.length >= self.w:
				self.scroll += 1
				
				self.length -= 1
			if self.length < 0:
				self.scroll += self.length
				
				self.length = 0
	
			if self.scroll < 0:
				self.scroll = 0
	
			self.win.erase()
	
			try:
				self.win.addstr(self.line[self.scroll:self.scroll+self.w-1])
			except Exception, e:
				self.mucous.Help.Log("debug", "Editwin: "+ str(e))
			self.win.refresh()
		except Exception, e:
			self.mucous.Help.Log("debug", "fixpos: \""+str(self.line)+"\" "+ str(e))
			
	## Delete contents of line
	# @param self CharacterParse
	def reset(self):
		try:
			self.length = self.scroll = 0
			self.mucous.line = self.line = ""
	
			self.win.erase()
			self.win.refresh()
		except Exception, e:
			self.mucous.Help.Log("debug", "reset: \""+str(self.line)+"\" "+ str(e))
			
## Create, Display and do things with Popup menus
#
class PopupMenu:
	## Constructor
	# @param self PopupMenu
	# @param mucous mucous (parent)
	def __init__(self, mucous):
		## @var mucous 
		# Mucous (Class)
		self.mucous = mucous
		## @var show
		# menu is redrawn after a refresh_windows
		self.show = False
		## @var current
		# current menu
		self.current = None
		## @var position
		# Vertical position in menu 
		self.position = 0
		## @var menus
		# Menu dict of dicts for each menu with coordinates, 3 windows, and a list of items
		# subdicts' keys are: window, scroll, shadow, name, items, top, width, height, left
		self.menus = {}
		
	
	## Redraw Windows and (maybe) Menu
	# @param self PopupMenu
	def Refresh(self):
		try:
			self.mucous.refresh_windows()
		except Exception, e:
			self.mucous.Help.Log("debug", "PopupMenu.Refresh: " + str(e))
			
	## Redraw Windows and close Menu
	# @param self PopupMenu
	def Clear(self):
		try:
			self.show = False
			self.current = None
			self.Refresh()
		except Exception, e:
			self.mucous.Help.Log("debug", "PopupMenu.Clear: " + str(e))
			
	## Return the correct list for the current menu
	# @param self PopupMenu
	# @return list 
	def List(self):
		try:
			mode = self.mucous.mode 
			if self.current == "encoding":
				return [""]
			if mode == "chat":
				this_list = self.mucous.ChatRooms.logs["roombox"][self.mucous.ChatRooms.current]
			elif mode  == "lists":
				this_list = self.mucous.UsersLists.logs[self.mucous.UsersLists.current]
			elif mode == "transfer":
				this_list = self.mucous.Transfers.get_transfers_list()
			elif mode == "search":
				this_list = self.mucous.Search.viewing
			elif mode  == "browse":
				if self.mucous.BrowseShares.current != None:
					if self.mucous.BrowseShares.selected == "files":
						this_list = self.mucous.BrowseShares.files
					elif self.mucous.BrowseShares.selected == "directories":
						this_list = self.mucous.BrowseShares.dirs
				
			return this_list
		except Exception, e:
			self.mucous.Help.Log("debug", "PopupMenu.List " +str(e))
			
	## Map mouse-clicks to events
	# @param self PopupMenu
	# @param x vertical
	# @param y horizontal
	# @param event is the mouse event (button, doubleclick, etc) represented by a number
	def Mouse(self, x, y, event):
		try:
			menu = self.menus[self.current]
			width = menu["width"]
			top = menu["top"]
			height = menu["height"]
			left = menu["left"]
			
			if x >= left and x < width + left and y >= top and y < top + height:
				if y > top and y < top + height -1:
					y -= top+1
					#self.error_bar("y"+str(y) + " x"+ str(x))
					self.position = y
					self.Draw()
					if event in (2, 8, 16384):
						
						s = self.Execute()
						if s == 0:
							self.mucous.refresh_windows()
							self.show = False
							self.current = None
						elif s == 3:
							self.show = False
							self.current = None
			else:
				self.show = False
				self.current = None
				self.Refresh()
		except Exception, e:
			self.mucous.Help.Log("debug", "PopupMenu.Mouse: " + str(e))
			
	## Run function associated with current menu position
	# @param self PopupMenu
	def Enter(self):
		try:
			s = self.Execute()
			if s == 0:
				self.mucous.refresh_windows()
				self.show = False
				self.current = None
			elif s == 3:
				self.show = False
				self.current = None
			else:
				self.Draw()
			#self.menu()
		except Exception, e:
			self.mucous.Help.Log("debug", "PopupMenu.Enter: " + str(e))

	## Build Current Menu and display it
	# @param self PopupMenu
	def Draw(self):
		try:
			menu = self.current
			self.menus[menu]["scroll"].erase()
			y = 0

			clipped_list, self.position, start = self.mucous.FormatData.scrollbox(self.menus[menu]["items"], self.position, self.menus[menu]["height"]-2)
			#for z in self.menus[menu]["items"]:
			for z in clipped_list:
				try:
					username = self.menus[menu]["name"]
					x = 0
					## Color asterixs in from of user list toggles
					if z[1] in ("banned", "ignored", "buddies", "trusted"):
						r = 0
						if self.mucous.config[z[1]].has_key(username):
							r = 1

						if r == 1:
							self.menus[menu]["scroll"].addstr(y, x, "* ", self.mucous.colors["green"])
						else:
							self.menus[menu]["scroll"].addstr(y, x, "* ", self.mucous.colors["red"])
						x = 2
						spaces = " " * (self.menus[menu]["width"]-2 - len(z[1]) -2)
						line = z[1].capitalize()+spaces
					## Draw a Horizontal line
					elif z[1] == "line":
						line =" "  * (self.menus[menu]["width"]-2)
						
						self.menus[menu]["window"].addch(y+1, 0, curses.ACS_LTEE, self.mucous.colors["green"])
						self.menus[menu]["window"].addch(y+1, self.menus[menu]["width"]-1, curses.ACS_RTEE, self.mucous.colors["green"])
						
						if self.position == y + start:
							self.menus[menu]["scroll"].hline(y, x,  curses.ACS_HLINE, self.menus[menu]["width"]-2, self.mucous.colors["green"])
						else:
							self.menus[menu]["scroll"].hline(y, x, curses.ACS_HLINE, self.menus[menu]["width"]-2)
						y += 1
						continue
					
					else:
						## Padd line with spaces
						spaces = " " * (self.menus[menu]["width"]-2 - len(z[0]) )
						line = z[0] + spaces
					## remove last character from last item in line
					if z is clipped_list[-1]:
						line = line[:-1]
					if self.position == y + start:
						self.menus[menu]["scroll"].addstr(y, x, line, self.mucous.colors["green"])
					else:
						self.menus[menu]["scroll"].addstr(y, x, line)
				except Exception, e:
					self.mucous.Help.Log("debug", "PopupMenu.Draw " +str(e))
					pass
				y += 1
			self.menus[menu]["window"].noutrefresh()
			self.menus[menu]["scroll"].noutrefresh()
			curses.doupdate()
		except Exception, e:
			self.mucous.Help.Log("debug", "PopupMenu.Draw " +str(e))
	
	## Create Package menu
	# @param self PopupMenu
	# @param menu New Current Menu
	# @param position vertical position of menu item
	# @param show Show this menu
	def Create(self, menu=None, position=0, show=None):
		try:
			if menu:
				self.current = menu
			else:
				menu = self.current 
			self.position = position
			
			if show:
				self.show = True
			
			
			title = None
			number = None
			
			this_list = self.List()
			if this_list == []:
				return
			
			if menu == "roombox":
				mode = "roombox"
				if self.mucous.ChatRooms.shape == "rightlist":
					left = self.mucous.ChatRooms.dimensions["roombox"]["left"] - 22
				else:
					left = self.mucous.ChatRooms.dimensions["roombox"]["left"]+self.mucous.ChatRooms.dimensions["roombox"]["width"]+1
				top = 2; width = 20
				title = "%s" % (self.mucous.ChatRooms.logs["roombox"][self.mucous.ChatRooms.current][self.mucous.ChatRooms.scrolling[mode]])[:16]
				user = name = self.mucous.ChatRooms.logs["roombox"][self.mucous.ChatRooms.current][self.mucous.ChatRooms.scrolling[mode]]
				if user in self.mucous.user["statistics"].keys():
					number = str(self.mucous.user["statistics"][user][2]) + " Files"
				items = [["Private Message", "all"], ["Userinfo", "all"], ["IP Address", "all"], ["Browse", "all"], ["", "line"], ["Buddy", "buddies"], ["Ban", "banned"], ["Ignore", "ignored"], ["Trusted", "trusted"], ["Give Privileges", "giveprivs"]  ]
				height = len(items) + 2	
			elif menu == "lists":
				mode = self.mucous.UsersLists.current
				left = 25; top = 2; width = 20
				title = "%s" % (this_list[self.mucous.UsersLists.scrolling[mode]])[1][:16]
				name = this_list[self.mucous.UsersLists.scrolling[mode]][1]
				number = self.mucous.UsersLists.scrolling[mode] +1
				
				items = [["Private Message", "all"], ["Userinfo", "all"], ["IP Address", "all"], ["Browse", "all"], ["", "line"], ["Buddy", "buddies"], ["Ban", "banned"], ["Ignore", "ignored"], ["Trusted", "trusted"], ["Give Privileges", "giveprivs"]  ]
				height = len(items) + 2
				
			elif menu == "transfers":
				mode = self.mucous.Transfers.current
				left = 25; top = 1; width = 20
				
				title = "%s" % this_list[self.mucous.Transfers.scrolling[mode]][1][:16]
				name = this_list[self.mucous.Transfers.scrolling[mode]][1]
				
				number = self.mucous.Transfers.get_transfer_number(this_list)
				if self.mucous.Transfers.current == "downloads":
					items = [["Retry", "transfers"], ["Retry All", "transfers"],["Abort", "transfers"], ["Abort User", "transfers"], ["Clear", "transfers"], ["Clear Finished", "transfers"], ["Clear User", "transfers"], ["", "line"], ["Private Message", "all"], ["Userinfo", "all"], ["IP Address", "all"], ["Browse", "all"], ["", "line"], ["Buddy", "buddies"], ["Ban", "banned"], ["Ignore", "ignored"], ["Trusted", "trusted"], ["Give Privileges", "giveprivs"],  ["Get Queue Place", "getplace"] ]
				else:
					items = [["Retry", "transfers"], ["Retry All", "transfers"],["Abort", "transfers"], ["Abort User", "transfers"], ["Clear", "transfers"], ["Clear Finished", "transfers"], ["Clear User", "transfers"], ["", "line"], ["Private Message", "all"], ["Userinfo", "all"], ["IP Address", "all"], ["Browse", "all"], ["", "line"], ["Buddy", "buddies"], ["Ban", "banned"], ["Ignore", "ignored"], ["Trusted", "trusted"], ["Give Privileges", "giveprivs"]  ]
				height = len(items) + 2	
			elif menu == "search":
				mode = "search"
				left = 25; top = 5; width = 20
				number = this_list[self.mucous.Search.scrolling-self.mucous.Search.dimensions["start"]]
				name, path = self.mucous.Search.GetDownloadFromNum(number)
				title = "%s" % name[:14]
				#name = self.mucous.Search.results[self.mucous.Search.current][number][1]
				
				items = [ ["Download", "download"], ["Download Dir", "downdir"], ["Display Full Path", "displaypath"], ["", "line"], ["Private Message", "all"], ["Userinfo", "all"], ["IP Address", "all"], ["Browse", "all"], ["", "line"], ["Buddy", "buddies"], ["Ban", "banned"], ["Ignore", "ignored"], ["Trusted", "trusted"], ["Give Privileges", "giveprivs"]]
				height = len(items) + 2	
			elif menu == "browse-dirs":
				mode = "directories"
				left = 23; top = 5; width = 20
				#number = this_list[self.scrolling[mode]-self.windows["dimensions"]["directories"]["start"]]
				title = "Directory" 
				name = self.mucous.BrowseShares.current
				
				items = [ ["Download Dir", "downdir"], ["Display Full Path", "displaypath"], ["", "line"], ["Private Message", "all"], ["Userinfo", "all"], ["IP Address", "all"], ["Refresh Shares", "all"], ["", "line"], ["Buddy", "buddies"], ["Ban", "banned"], ["Ignore", "ignored"], ["Trusted", "trusted"],  ["Give Privileges", "giveprivs"]]
				height = len(items) + 2	
			elif menu == "browse-files":	
				mode = "files"
				left = 2; top = 5; width = 20
				number = self.mucous.BrowseShares.scrolling[mode] + 1 
				title = " File "
				name = self.mucous.BrowseShares.current
				dir = self.mucous.BrowseShares.current_dir
				#print self.mucous.BrowseShares.files[number-1]
				#title = self.mucous.BrowseShares.files[number -1]
				
				items = [ ["Download", "download"], ["Download Dir", "downdir"], ["Display Full Path", "displaypath"], ["", "line"], ["Private Message", "all"], ["Userinfo", "all"], ["IP Address", "all"], ["Browse", "all"], ["", "line"], ["Buddy", "buddies"], ["Ban", "banned"], ["Ignore", "ignored"], ["Trusted", "trusted"], ["Give Privileges", "giveprivs"]]
				height = len(items) + 2	
			elif menu == "encoding":
				left = self.mucous.w-27; top = 2; width = 20
				number =  None
				title = "Encoding"
				
				if self.mucous.mode == "browse":
					if self.mucous.BrowseShares.current != None:
						name = self.mucous.BrowseShares.current
					else:
						name = "Filesystem"
				elif self.mucous.mode == "chat":
					name = self.mucous.ChatRooms.current
				elif self.mucous.mode == "private":
					name = self.mucous.PrivateChat.current
					
				items = [ ["UTF-8", ""], ["iso-8859-1", ""], ["iso-8859-2", ""], ["iso-8859-3", ""], ["iso-8859-4", ""], ["iso-8859-5", ""], ["iso-8859-6", ""], ["iso-8859-7", ""], ["iso-8859-8", ""], ["iso-8859-9", ""], ["iso-8859-10", ""], ["iso-8859-11", ""], ["iso-8859-13", ""],["iso-8859-14", ""],["iso-8859-15", ""], ["iso-8859-16", ""],["KIO8-R", ""], ["CP1250", ""], ["CP1251", ""],["CP1252", ""],["CP1253", ""],["CP1254", ""],["CP1255", ""],["CP1256", ""],["CP1257", ""],["CP1258", ""],["CP874", ""] ]
				if  len(items)+2 > self.mucous.h-9:
					height = self.mucous.h-9
				else:
					height = len(items)+2
			# Cleanup stale windows
			if menu in self.menus:
				if "scroll" in self.menus[menu]:
					del self.menus[menu]["scroll"]
				if "shadow" in self.menus[menu]:
					del self.menus[menu]["shadow"]
				if "window" in self.menus[menu]:
					del self.menus[menu]["window"]
			shadow = curses.newwin(height+1, width+1, top, left)
			shadow.erase()
			shadow.noutrefresh()
			win = curses.newwin(height, width, top, left)
			win.attron(self.mucous.colors["green"] | curses.A_BOLD)
# 			win.bkgdset(" ", self.colors["green"])
			win.erase()
			win.border()
			if title != None:
				win.addstr(0, 1,  "<%s>" % title)
			if number != None:
				win.addstr(height-1, 1,  "< %s >" % number)
			win.attroff(self.mucous.colors["green"] | curses.A_BOLD)
			win.noutrefresh()
			scroll = win.subwin(height-2, width-2, top+1, left+1)
# 			scroll.erase()
			scroll.scrollok(0)
# 			scroll.noutrefresh()
			self.menus[menu] = {"window": win, "shadow": shadow, "scroll": scroll, "name": name, "items": items, "top": top, "width": width, "height": height, "left": left}
			self.Draw()
			curses.doupdate()
			#sleep(1)
		except Exception, e:
			self.mucous.Help.Log("debug", "PopupMenu.Create " +str(e))
			
	## Select new encoding based on position
	# @param self PopupMenu
	# @return 0
	def ExecuteEncodingsMenu(self):
		if self.position == 0: coding = "UTF-8"
		elif self.position == 1: coding = "iso-8859-1"  
		elif self.position == 2: coding = "iso-8859-2"  
		elif self.position == 3: coding = "iso-8859-3"  
		elif self.position == 4: coding = "iso-8859-4"  
		elif self.position == 5: coding = "iso-8859-5"  
		elif self.position == 6: coding = "iso-8859-6"  
		elif self.position == 7: coding = "iso-8859-7" 
		elif self.position == 8: coding = "iso-8859-8"  
		elif self.position == 9: coding = "iso-8859-9"  
		elif self.position == 10: coding = "iso-8859-10"  
		elif self.position == 11: coding = "iso-8859-11"  
		elif self.position == 12: coding = "iso-8859-13" 
		elif self.position == 13: coding = "iso-8859-14" 
		elif self.position == 14: coding = "iso-8859-15"  
		elif self.position == 15: coding = "iso-8859-16" 
		elif self.position == 16: coding = "KIO8-R" 
		elif self.position == 17: coding = "CP1250" 
		elif self.position == 18: coding = "CP1251" 
		elif self.position == 19: coding = "CP1252" 
		elif self.position == 20: coding = "CP1253" 
		elif self.position == 21: coding = "CP1254" 
		elif self.position == 22: coding = "CP1255" 
		elif self.position == 23: coding = "CP1256" 
		elif self.position == 24: coding = "CP1257" 
		elif self.position == 25: coding = "CP1258"
		elif self.position == 26: coding = "CP874" 
		#self.Help.Log("debug", coding)
		if self.mucous.mode == "chat":
			self.mucous.SendMessage(messages.ConfigSet("encoding.rooms", self.mucous.ChatRooms.current, coding))
		elif self.mucous.mode == "private":
			self.mucous.SendMessage(messages.ConfigSet("encoding.users", self.mucous.PrivateChat.current, coding))
		elif self.mucous.mode == "browse":
			if self.mucous.BrowseShares.current != None:
				self.mucous.SendMessage(messages.ConfigSet("encoding.users", self.mucous.BrowseShares.current, coding))
			else:
				self.mucous.SendMessage(messages.ConfigSet("encoding", "filesystem", coding))
		return 0
	
	## Do an action to the selected transfer
	# @param self PopupMenu
	# @return 1 / 0
	def ExecuteTransfers(self):
		try:
			mode = self.mucous.Transfers.current
			the_list = self.List()
			item_num = self.mucous.Transfers.scrolling[mode]
			username = the_list[item_num][1] 
			
			path = the_list[item_num][2]
			userpath = (username, path)
			transfer = self.mucous.Transfers.get_transfer_number(the_list)
			if transfer == None:
				return 1
			if self.position == 0:
				# RETRY DOWNLOAD
				
				if self.mucous.Transfers.current != "downloads":
					return 1
				if transfer in self.mucous.Transfers.downloads.keys():
					for username, path in self.mucous.Transfers.downloads[transfer].items():
						self.mucous.Help.Log("status", "Retrying download: [%s] %s" % (username, path))
						self.mucous.SendMessage(messages.DownloadFile(username, path))
				else:
					self.mucous.Help.Log("status", "No such transfer #" + str(transfer))
				return 0
			elif self.position == 1:
				# RETRY ALL DOWNLOADS
				if self.mucous.Transfers.current != "downloads":
					return 1
				for user_path, transfer  in self.mucous.Transfers.transfers["downloads"].items():
					if int(transfer[3]) in (10, 11, 12, 13, 14):
						self.mucous.SendMessage(messages.DownloadFile(transfer[1], transfer[2]))
				return 0
			elif self.position == 2:
				# ABORT TRANSFER
				if self.mucous.Transfers.current == "downloads":
					if transfer in self.mucous.Transfers.downloads.keys():
						for username, path in self.mucous.Transfers.downloads[transfer].items():
							self.mucous.Help.Log("status", "Aborting download: [%s] %s" % (username, path))
							self.mucous.SendMessage(messages.TransferAbort(0, username, path))
					else:
						self.mucous.Help.Log("status", "No such transfer #" + str(transfer))
				elif self.mucous.Transfers.current == "uploads":
					if transfer in self.mucous.Transfers.uploads.keys():
						for username, path in self.mucous.Transfers.uploads[transfer].items():
							self.mucous.Help.Log("status", "Aborting upload: [%s] %s" % (username, path))
							self.mucous.SendMessage(messages.TransferAbort(1, username, path))
					else:
						self.mucous.Help.Log("status", "No such transfer #" + str(transfer))
				return 0
			elif self.position == 3:
				# ABORT USER's TRANSFER(s)
				if self.mucous.Transfers.current == "downloads":
					for userpath, values in self.mucous.Transfers.transfers["downloads"].items():
						if userpath[0] == username:
							self.mucous.Help.Log("status", "Aborting download: [%s] %s" % (username, values[2]))
							self.mucous.SendMessage(messages.TransferAbort(0, username, values[2]))
	
				elif self.mucous.Transfers.current == "uploads":
					for userpath, values in self.mucous.Transfers.transfers["uploads"].items():
						if userpath[0] == username:
							self.mucous.Help.Log("status", "Aborting upload: [%s] %s" % (username, values[2]))
							self.mucous.SendMessage(messages.TransferAbort(1, username, values[2]))
	
				return 0
			elif self.position == 4:
				# Clear
				if self.mucous.Transfers.current == "downloads":
					if transfer in self.mucous.Transfers.downloads.keys():
						for username, path in self.mucous.Transfers.downloads[transfer].items():
							self.mucous.Help.Log("status", "Removing download: [%s] %s" % (username, path))
							self.mucous.SendMessage(messages.TransferRemove(0, username, path))
					else:
						self.mucous.Help.Log("status", "No such transfer #" + str(transfer))
					
				elif self.mucous.Transfers.current == "uploads":
					if transfer in self.mucous.Transfers.uploads.keys():
						for username, path in self.mucous.Transfers.uploads[transfer].items():
							self.mucous.Help.Log("status", "Removing upload: [%s] %s" % (username, path))
							self.mucous.SendMessage(messages.TransferRemove(1, username, path))
					else:
						self.mucous.Help.Log("status", "No such transfer #" + str(transfer))
				return 0
			elif self.position == 5:
				# Clear ALL FINISHED/FAILED
				if self.mucous.Transfers.current == "downloads":
					for userpath, values in self.mucous.Transfers.transfers["downloads"].items():
						if values[3] == 0:
							self.mucous.SendMessage(messages.TransferRemove(0, values[1], values[2]))
				elif self.mucous.Transfers.current == "uploads":
					for userpath, values in self.mucous.Transfers.transfers["uploads"].items():
						if values[3] in (0, 10, 11, 12, 13, 14):
							self.mucous.SendMessage(messages.TransferRemove(1, values[1], values[2]))
				return 0
			elif self.position == 6:
				# Clear USER's Transfers
				if self.mucous.Transfers.current == "downloads":
					for userpath, values in self.mucous.Transfers.transfers["downloads"].items():
						if userpath[0] == username:
							self.mucous.SendMessage(messages.TransferRemove(0, values[1], values[2]))
				elif self.mucous.Transfers.current == "uploads":
					for userpath, values in self.mucous.Transfers.transfers["uploads"].items():
						if userpath[0] == username:
							self.mucous.SendMessage(messages.TransferRemove(1, values[1], values[2]))
				return 0
			elif self.position == 7:
				return 1
			else:
				self.position -=8
				return username
			
		except Exception, e:
			self.mucous.Help.Log("debug", "PopupMenu.ExecuteTransfers " +str(e))
	
	## Do an action to the selected file or directory
	# @param self PopupMenu
	# @return 1 /0
	def ExecuteBrowse(self):
		try:
			the_list = self.List()
			#username = self.mucous.BrowseShares.current
			user, path = self.mucous.BrowseShares.CurrentFile()
			mode = self.mucous.BrowseShares.selected
			if mode == "directories":
				
				number = self.mucous.BrowseShares.scrolling[mode]-self.mucous.BrowseShares.dimensions["directories"]["start"]
				if self.position == 0:
					# Download
					self.mucous.Transfers.FolderDownload(user, path)
					return 0
				elif self.position == 1:
					user, path = self.mucous.BrowseShares.CurrentDir()
					self.mucous.Help.Log("status", "[%d] %s" % (number, path))
					return 0
				else:
					self.position -= 2
			elif mode == "files":
				#user, path = self.mucous.BrowseShares.CurrentFile()
				mode = "files"
				number = self.mucous.BrowseShares.scrolling[mode]
				if self.position == 0:
					# Download
					self.mucous.Transfers.RetryDownload(user, path)
					return 0
				elif self.position == 1:
					# Download Dir
					self.mucous.Transfers.FolderDownload(user, path)
					return 0
			
				elif self.position == 2:
					self.mucous.Help.Log("status", "[%d] %s" % (number+1, path))
					return 0
				else:
					self.position -= 3

			if self.position == 0:
				return 1
			else:
				self.position -=1
				return user
		except Exception, e:
			self.mucous.Help.Log("debug", "PopupMenu.ExecuteBrowse " +str(e))			
			
	## Call functions associated with the menu item and the list item the menu is connected to
	# @param self PopupMenu
	# @return 1 /0
	def Execute(self):
		try:
			## ENCODINGS
			if self.current == "encoding":
				return self.ExecuteEncodingsMenu()
					
			## The rest of the popup menus
			
			if self.current not in ("roombox", "lists", "transfers", "search", "browse-dirs", "browse-files"):
				return 0
			if self.current == "roombox":
				mode = "roombox"
				username = self.mucous.ChatRooms.logs["roombox"][self.mucous.ChatRooms.current][self.mucous.ChatRooms.scrolling[mode]]
			elif self.current == "lists":
				mode = self.mucous.UsersLists.current
				username = self.List()[self.mucous.UsersLists.scrolling[mode]][1]
			elif self.current == "transfers":
				a  = self.ExecuteTransfers()
				if a in (0, 1):
					return a
				else:
					username = a 
			elif self.current == "search":
				the_list = self.List()
				mode = "search"
				number = the_list[self.mucous.Search.scrolling-self.mucous.Search.dimensions["start"]]
				username, path = self.mucous.Search.GetDownloadFromNum(number)
								
				userpath = (username, path)
				
				if self.position == 0:
					# Download

					self.mucous.Search.DownloadSearch(username, path)
					return 0
				elif self.position == 1:
					# Download Dir
					self.mucous.Search.DownloadSearch(username, path, True)
					return 0
				elif self.position == 2:
					self.mucous.Help.Log("status", "[%d] %s" % (number, path))
					return 0
				elif self.position == 3:
					# Line
					return 1
				else:
					self.position -= 4
					
			elif self.current in ("browse-dirs", "browse-files"):
				a = self.ExecuteBrowse()
				if a in (0, 1):
					return a
				else: username = a 
			if self.position == 0:
				self.mucous.PrivateChat.Start(username)
				self.mucous.PrivateChat.Mode()
			elif self.position == 1:
				self.mucous.Userinfo.Get(username)

				self.mucous.Userinfo.Mode()
			elif self.position == 2:
				self.mucous.requests["ip"].append(username)
				self.mucous.SendMessage(messages.PeerAddress(username))
				self.mucous.Userinfo.Mode()
			elif self.position == 3:
				self.mucous.BrowseShares.Get(username)
			elif self.position == 4:
				return 1
			elif self.position == 5:
				if username not in self.mucous.config["buddies"].keys():
					self.mucous.ModifyConfig("buddy", username, '')
				else:
					self.mucous.ModifyConfig("unbuddy", username, '')
				return 1
			elif self.position == 6:
				if username not in self.mucous.config["banned"].keys():
					self.mucous.ModifyConfig("ban", username, '')
				else:
					self.mucous.ModifyConfig("unban", username, '')
				return 1
			elif self.position == 7:
				if username not in self.mucous.config["ignored"].keys():
					self.mucous.ModifyConfig("ignore", username, '')
				else:
					self.mucous.ModifyConfig("unignore", username, '')
				return 1
			elif self.position == 8:
				if username not in self.mucous.config["trusted"].keys():
					self.mucous.ModifyConfig("trust", username, '')
				else:
					self.mucous.ModifyConfig("distrust", username, '')
				return 1
			elif self.position == 9:
				self.mucous.usernames["privileges"] = username
				self.mucous.set_edit_title( "% Give Privileges to " + self.mucous.usernames["privileges"])
			elif self.position == 10:
				self.mucous.SendMessage(messages.TransferUpdate(username, path) )
			return 0
		except Exception, e:
			self.mucous.Help.Log("debug", "PopupMenu.Execute " +str(e))
## Help logs and windows
#
class Help:
	
	## Constructor
	# @param self Help (Class)
	# @param mucous Mucous (Class)
	def __init__(self, mucous):
		## @var mucous
		# Mucous (Class)
		self.mucous = mucous
		## @var scrolling
		# dict of vertical scroll positions for help, debug
		self.scrolling = {"help":0, "debug":0}
		## @var dimensions
		# Window placement
		self.dimensions = {}
		## @var windows
		# Curses Window instances
		self.windows = {}
		## @var log
		# dict containing help log lists
		self.log = {}
		self.log["private"] = ["Global Private Messaging commands:",\
"To start a Private Message:",\
"1) Type in the username you wish to PM below",\
"2) Press <Enter>",\
"3) Type your messages",
"Use the commands below:",\
"/pm      <user>        (Start PM or switch to user)",\
"/close   <user>        (Close user's PM) ",\
"/close                 (Close current PM)",\
"/ip                    (Get the IP of current user)",\
"/msg <message>         (Send message to previous chosen user)"]
		
		self.log["userinfo"] = ["Global User Information commands:",\
"/userinfo <user>",\
"/stat     <user>",\
"/ip       <user>",\
"Or type the user name that you wish get recieve userinfo from, below.", "--"]
		self.log["chat"] = ["----[Chat Commands]----", \
"/join <room>   /part <room>  /leave <room>",\
"/j <room>      /talk <room>  /say <room> <message>",\
"/users <room>          (lists of users in room)",\
"/autojoin <room>       (Toggle Autojoining room)",\
"/roomlistrefresh       (redownload roomlist from server)",\
"/inrooms               (list of joined rooms)",\
"/clearroom <room>      (clear <room>, or current room)",\
"/pm <user>             (Private Message user)",\
"/msg <message>         (send message to last user)",\
"/url          /urlcustom (command$command)    (Requires X11)",\
"/urlreader (lynx|links|elinks|firefox|custom) (Requires X11)",\
"/np                    (XMMS/BMP Now playing script)",\
"/npcheck               (display Now playing script command)",\
"/npset <command>       (Set Now playing script to command)",\
"/npprefix <text>       (set to np: or /me is now playing:)",\
"/alias <alias> <text>  /unalias <alias>"]
		self.log["tickers"] = ["----<Ticker Commands>---- ",\
"/showtickers           (Hide/Show tickers)",\
"/tickers               (Scroll or Cycle through tickers)",\
"/listtick <room>       (List tickers in the Info mode)",\
"/tickroom <room>       (Choose room for setting tickers)",\
"/settick <message>     (Set ticker to message, and save it)",\
"/defaulttick <message> (Set & save default ticker)",\
"/settemptick <message> (Set ticker only for this session)"]
		self.log["connect"] = ["Connection Configuration",\
"/interface </tmp/museekd.[username]> or <host:port>",\
"/password <interface password>",\
"/connect               (Attempts to connect to Museekd)",\
"/disconnect            (Disconnects from Museekd)",\
"/login                 (Login to Soulseek Server)",\
"/logout                (Logout from Soulseek Server)",\
"/save                  (Writes settings to config)"]

		self.log["setup"] = ["Setup",\
"/autobuddy    (Auto-buddy users you download from)",\
"/autoclear    (auto-clear finished uploads)",\
"/autoretry    (auto-retry failed/errored transfers)",\
"/password     (Mucous' Interface password)",\
"/privbuddy    (Toggle Privileging buddies)",\
"/onlybuddy    (Toggle Only sharing to buddies)",\
"/slots <num>  (Set upload slots)",\
"/unhide       (Toggle showing password)",\
"/rescan       (Rescan Normal Shares)",\
"/rescanbuddy  (Rescan Buddy-only Shares)",\
"/reload       (Reload Shares - make changes take effect)",\
"/extra        (Auto-Send Version info via PM if requested)",\
"/logdir /path (Set Logs Directory)",\
"/logging      (Toggle Logging)"]

		self.log["user"] = ["----[User Commands]---- ",\
"/buddy    <user>    /unbuddy   <user>",\
"/ban      <user>    /unban     <user> (Cannot access your files)",\
"/ignore   <user>    /unignore  <user> (No messages in chat)",\
"/nuke     <user>    /unnuke    <user> (Ban+Ignore)",\
"/trust    <user>    /distrust  <user> (Can Upload to you)",\
"/stat     <user>    /ip        <user>",\
"/userinfo <user>    /giveprivs <user> (Input days next)",\
"/away (Toggle your Online/Away Status)",\
"/autoaway (Go away after 900 seconds of inactivity)"]

		self.log["transfer"] = ["----[Transfer Commands]---- ",\
"/abortu  <num> /abortup    <num> (Abort Upload)",\
"/abortd  <num> /abortdown  <num> (Abort Download)",\
"/removeu <num> /removeup   <num> (Remove Upload)",\
"/removed <num> /removedown <num> (Remove Download)",\
"/retry   <num>                   (Retry Download)",\
"/retryall                        (Retry all Downloads)",\
"/clearup                         (Clear failed/finished Uploads)",\
"/cleardown                       (Clear finished Download)",\
"/percent                         (Toggle Percent/Speed",\
"/transbox                        (Toggle Split/Tabbed Mode))"]
		self.log["modes"] = ["----[Mode Commands]---- ",\
"/chat          (Chat Mode)",\
"/transfer      (Transfer Mode)",\
"/info          (Info Mode)",\
"/browse        (Browse Mode)",\
"/private       (Private Message Mode)",\
"/search        (Search Mode)",\
"/buddylist     (Buddylist Mode)",\
"/banlist       (Banlist Mode)",\
"/ignorelist    (Ignorelist Mode)",\
"/roomlist      (Roomlist Mode)",\
"/setup         (Setup Mode)",\
"/help /debug   (Help & Debug Mode)"]

		self.log["helpcommands"] = ["----<Help Commands>---- ",\
"/help          (This Message)",\
"/help connect  (Connection Commands)",\
"/help setup    (Setup Commands)",\
"/help mode     (Mode Commands)",\
"/help chat     (Chatroom Commands)",\
"/help ticker   (Ticker Commands)",\
"/help user     (User Commands)",\
"/help transfer (Transfer Commands)",\
"/help browse   (Browse Commands)",\
"/help search   (Search Commands)",\
"/help download (Download Commands)",\
"/help keys     (Special Keys)",\
"/quit          (Close Mucous)"]
		
		
		self.log["search"] = [\
"/search                (Switch to Search Mode)",\
"/searchfor   <query>   (Global Search)",\
"/searchbuddy <query>   (Buddy Search)",\
"/searchroom  <query>   (Room Search)",\
"/searchuser  <user>    (Search only one user's shares)",\
"/download <number>     (Download File with number)",\
"/downdir  <number>     (Download directory of File)",\
"/close                 (Close current search)",\
"/clearsearchs          (Removes all searches)",\
"/filter <string>       (limit displayed files)",\
"Mouse: Right-Click     (popup menu)",\
"Press Insert to toggle sorting methods.",\
"Press Alt-T to toggle Global/Buddy/Room searches",\
"Press Insert to toggle sorting methods."]

		self.log["search"] = ["----<Search Commands>----"] + self.log["search"]
		
		self.log["browse"] = ["----<Browse Commands>----",\
"/browse                (Switch to Browse Mode)",\
"/buser    <user>       (Browse User)",\
"/bsearch  <query>      (Search thru Shares)",\
"/download <number>     (Download file with this number)",\
"/close                 (close current shares)",\
"Press Insert to toggle between shares.",\
"Alt-X                  (Expand/Collapse directory)",\
"/browsewidth <number>  (Resize Directories window)",\
"--File System browsing commands--",\
"cd (change dir) get, getdir (download)",\
"First, type in the user you wish to browse, below.", \
"Right-click on directories or files to display the popup menu."]

		
		self.log["download"] = ["----<Manual Download Commands>----",\
"/downuser <user>    (Set download user)",\
"/downpath <path>    (Download file from user)",\
"/downpathdir <path> (Download dir from user)"]

		self.log["keys"] =["------<Keys>------ ",\
"No guarantees that these HotKeyBar work with your terminal",\
"ESC or Alt + [, ], <-, ->  (Change Room / Transfer display mode)",\
"Insert                     (Same as above)",\
"Tab                        (Completes nicks)",\
"Home/End                   (switches Upload & Download scrolling)",\
"Up, PageUp                 (Scroll Up a line, a page)",\
"Down, PageDown             (Scroll Down a line, a page)",\
"F1->Chat Rooms           F6->Browse Users",\
"F2->Private Messages     F7->User Lists/Interests",\
"F3->Transfers            F8->Rooms List",\
"F4->Search               F9->Setup",\
"F5->Info                 F10->Help"]
		self.log["debug"] = []
		self.log["help"] =[\
"  _____  __ __   ____  ____  __ __  ______",\
" /     \|  |  \_/ ___\/  _ \|  |  \/  ___/",\
"|  Y Y  \  |  /\  \__(  <_> )  |  /\___ \ ",\
"|__|_|  /____/  \___  >____/|____//____  >",\
"      \/            \/                 \/",\
"/help          (This Message)         /quit          (Shut down Mucous)",\
"/help connect  (Connection Commands)  /help setup    (Setup Commands)",\
"/help mode     (Mode Commands)        /help user     (User Commands)",\
"/help chat     (Chatroom Commands)    /help ticker   (Ticker Commands)",\
"/help transfer (Transfer Commands)    /help download (Download Commands)",\
"/help browse   (Browse Commands)      /help search   (Search Commands)",\
"/help keys     (Special Keys)"]


	## Create window, draw title, 
	# call Help.Format
	# call Mucous.set_edit_title
	# call Mucous.Alert.Check
	# @param self Help (Class)
	def Mode(self):
		try:
			# Cleanup stale windows
			if "text" in self.windows:
				del self.windows["text"]
			if "border" in self.windows:
				del self.windows["border"]
				
			if self.mucous.mode not in ("help", "debug"):
				self.mucous.mode = "debug"
			if self.mucous.mode == "help":
				logfile = self.log["help"]
			elif self.mucous.mode == "debug":
				logfile = self.log["debug"]
			self.mucous.PopupMenu.show = False
			
			s = self.dimensions["help"] = {"height": self.mucous.h-7, "width": self.mucous.w-2, "top": 2, "left": 1, "start": 0}
			mw = self.windows["border"] = curses.newwin(s["height"]+2, s["width"]+2, s["top"]-1, s["left"]-1)
			mw.attron(self.mucous.colors["green"])
			mw.border()
			mw.attroff(self.mucous.colors["green"])
			try:
				if self.mucous.mode == "help":
					mw.addstr(0, 3, "< Help Mode >",  self.mucous.colors["green"] | curses.A_BOLD)
					mw.addstr(0, 18, "<            >",  self.mucous.colors["green"])
					mw.addstr(0, 20, "Debug Mode",  curses.A_BOLD)
				elif self.mucous.mode == "debug":
					mw.addstr(0, 3, "<           >",  self.mucous.colors["green"] )
					mw.addstr(0, 5, "Help Mode",  curses.A_BOLD)
					mw.addstr(0, 18, "< Debug Mode >",  self.mucous.colors["green"] | curses.A_BOLD)
			except:
				pass
			mw.refresh()
			tw = self.windows["text"]  = mw.subwin(s["height"], s["width"], s["top"], s["left"])
			tw.scrollok(0)
			tw.idlok(1)
			
			self.scrolling["help"] = -1
			self.scrolling["debug"] = -1
			self.Format()
			
			self.mucous.set_edit_title("Use /help")
			#if self.Alerts.log in ("New Help", "New Bug", "New Status"):
			#	self.Alerts.setStatus("")
				
			
			self.mucous.Alerts.Check()
			curses.doupdate()
		except Exception, e:
# 			self.Log("debug", ": " + str(e))
			self.mucous.ChatRooms.AppendChat("Status", self.mucous.ChatRooms.current, "Format: ", str(e))
			pass
	## Format lines and then
	# Call Draw for each line
	# @param self Help (Class)
	def Format(self):
		try:
			w = self.dimensions["help"]
			tw = self.windows["text"]
			size = w["height"] * w["width"]
			if self.mucous.mode == "help":
				logfile = self.log["help"]
			elif self.mucous.mode == "debug":
				logfile = self.log["debug"]
			# DEBUGGING
			wrapped_lines = []
			for lines in logfile:
				list_of_strings = self.mucous.FormatData.StringCutWidth(lines, w)
				for string in list_of_strings:
					wrapped_lines.append(string)
			if self.scrolling[self.mucous.mode] == -1:
				self.scrolling[self.mucous.mode] = len(wrapped_lines)
				
			clipped_list, self.scrolling[self.mucous.mode], w["start"] = self.mucous.FormatData.scrollbox(wrapped_lines, self.scrolling[self.mucous.mode], w["height"])
			del wrapped_lines
			count = 0
			
			blanked_lines = []
			for lines in clipped_list:
				s, ls = self.mucous.FormatData.StringAddBlanks(lines, w) 
				blanked_lines.append(s)
				
			clipped_list = blanked_lines
			del blanked_lines
			count = 0
			total_lines = 0
			tw.erase()
			for line in clipped_list:
				try:
					if line is clipped_list[-1]:
						line = line[:-1]
					self.Draw(self.mucous.mode, line, count)
					count += 1
				except Exception, e:
					self.mucous.ChatRooms.AppendChat("Status", self.mucous.ChatRooms.current, 'ERR', str(e) )
			tw.refresh()
	
		except Exception, e:
			self.mucous.ChatRooms.AppendChat("Status", self.mucous.ChatRooms.current, "Format: ", str(e))
			
	## Append anything to the Log (converted to string)
	# @param self Help (Class)
	# @param htype Help type (help, status, debug)
	# @param s data to be appended to the log
	def Log(self, htype, s):
		try:
			s = str(s)
			
			if htype == "help":
				if "\n" in s:
					lis = s.split("\n")
					for line in lis:
						self.log["help"].append("%s" %line )
				else:
					self.log["help"].append("%s" %s )
			elif htype in ("status", "debug"):
				timestamp = time.strftime("%H:%M:%S")
				if htype == "status":
					ex = ''
				else: ex = "BUG " 
				if "\n" in s:
					lis = s.split("\n")
					for line in lis:
						if line is lis[0]:
							self.log["debug"].append("%s %s%s" % (timestamp,ex,line))
						else:
							self.log["debug"].append("%s%s" % (ex,line))
				
				else:
					self.log["debug"].append("%s %s%s" %(timestamp, ex,s))
				if htype == "debug":
					import traceback
					ex = "BUG "
					tb = traceback.extract_tb(sys.exc_info()[2])
					for line in tb:
						if line is tb[0]:
							self.log["debug"].append("%s %s%s" % (timestamp,ex,line))
						else: self.log["debug"].append("%s%s" % (ex,line))
				
			if self.mucous.mode in ( "help", "debug", "status"):
				#self.Draw( htype, s, 0)
				
				self.scrolling[self.mucous.mode] = -1
				self.Format()
				self.mucous.Alerts.Check()
				curses.doupdate()
			else:
	
				if htype not in self.mucous.Alerts.alert["HELP"]:
					if htype == "help":
						self.mucous.Alerts.alert["HELP"].append("help")
					elif htype == "status":
						self.mucous.Alerts.alert["HELP"].append("status")
					elif htype == "debug":
						self.mucous.Alerts.alert["HELP"].append("debug")
				
				self.mucous.Alerts.Check()
		except Exception, e:
						
			pass
	
	## Draw a line in the Help log 
	# @param self Help (Class)
	# @param htype Help type (help, status, debug)
	# @param s data to be drawn
	# @param count scroll position
	def Draw(self, htype, s, count):
		try:
			
			if self.mucous.mode in ( "help", "debug", "status"):
				tw = self.windows["text"]
				w = self.dimensions["help"]
				if count + w["start"] == self.scrolling[self.mucous.mode]:
					attr = curses.A_BOLD
				else:
					attr = curses.A_NORMAL
				
				if self.mucous.mode == "help" and htype == "help":
					tw.addstr(self.mucous.dlang(s), attr)
				elif self.mucous.mode == "debug" and htype in( "status", "debug"):
					tw.addstr(self.mucous.dlang(s), attr)
				else:
					self.mucous.Alerts.setStatus("New Help")
			else:
				self.mucous.Alerts.setStatus("New Help")
		except: # Exception, e:
			
			#self.ChatRooms.AppendChat("Status", self.ChatRooms.current, "Draw: ", str(e))
			pass
		
				
## Alerts (messages in top-right of terminal)
#
class Alerts:
	## Constructor
	# @param self Alerts (class)
	# @param mucous Mucous (Class)
	def __init__(self, mucous):
		## @var mucous
		# Mucous (Class)
		self.mucous = mucous
		## @var alert
		# dict containing all the alert messages
		self.alert = { "CHAT": {}, "PRIVATE": [], "TRANSFERS" : [],  "SEARCH": [], "INFO": [], "BROWSE": [],  "HELP": [] }
		## @var log
		# log string containing current alert
		self.log = ""
		## @var windows
		# dict containing instances of curses windows
		self.windows = {}
		
	## Create and Draw alert box	
	# @param self Alerts (class)
	def Mode(self):
		try:
			if "border" in self.windows:
				del self.windows["border"]
			aw = self.windows["border"] = curses.newwin(1, 15, 0, self.mucous.w-15)
			aw.bkgdset(" ", self.mucous.colors["blafgcyabg"]  | curses.A_REVERSE | curses.A_BOLD)
			aw.idlok(1)
			
			self.setStatus(self.log)
		except:
			pass
			
	## Remove Alert from place	
	# @param self Alerts (class)
	# @param string alert text
	# @param place where the alert is stored
	def Remove(self, string, place):
		if place in self.alert:
			if string in self.alert[place]:
				self.alert[place].remove(string)
	## Add Alert to place
	# @param self Alerts (Class)
	# @param string alert text
	# @param place where the alert is stored
	def Add(self, string, place):
		if place in self.alert:
			if string not in self.alert[place]:
				self.alert[place].append(string)
			else:
				self.alert[place].remove(string)
				self.alert[place].append(string)
			self.Check()
			
	## Check alerts, remove old ones, and call Next
	# @param self Alerts (class)
	def Check(self):
		try:
			if self.mucous.mode == "chat":
				if self.mucous.ChatRooms.current in self.alert["CHAT"].keys():
					del self.alert["CHAT"][self.mucous.ChatRooms.current]
			elif self.mucous.mode == "private":
				if self.mucous.PrivateChat.current in self.alert["PRIVATE"]:
					self.alert["PRIVATE"].remove(self.mucous.PrivateChat.current)
			elif self.mucous.mode == "browse":
				if self.mucous.BrowseShares.current in self.alert["BROWSE"] and self.mucous.BrowseShares.current != "__default":
					self.alert["BROWSE"].remove(self.mucous.BrowseShares.current)
			elif self.mucous.mode == "search":
				if self.mucous.Search.current in self.alert["SEARCH"]:
					self.alert["SEARCH"].remove(self.mucous.Search.current)
			elif self.mucous.mode == "info":
				if self.mucous.Userinfo.current in self.alert["INFO"]:
					self.alert["INFO"].remove(self.mucous.Userinfo.current)
			elif self.mucous.mode in ("help", "debug", "status"):
				#if ("debug", "help", "status") in self.alert["HELP"]:
				self.alert["HELP"] = []
			self.Next()
			self.mucous.HotKeyBar()
		except Exception, e:
			self.mucous.Help.Log("debug", "Alert.Check: " + str(e))
			
	## Display old alerts
	# @param self Alerts (class)
	def Next(self):
		try:
			if self.mucous.mode ==  "search":
				if self.alert["SEARCH"] != []:
					for s in self.alert["SEARCH"]:
						self.setStatus(self.mucous.Search.tickets[s])
						return
				else:
					self.Pick()
			if self.mucous.mode in ("info", "private",  "browse"):
			#if self.mode.upper() in ("PRIVATE", "TRANSFERS",  "SEARCH", "INFO", "BROWSE"):
			
				if self.alert[self.mucous.mode.upper()] != []:
					for s in self.alert[self.mucous.mode.upper()]:
						self.setStatus(s)
						return
				else:
					self.Pick()
			elif self.mucous.mode.upper()  == "CHAT":
				if self.alert[self.mucous.mode.upper()] != {}:
					for m, l in self.alert["CHAT"].items():
						self.setStatus(m)
						return
					self.setStatus("")
				else:
					self.Pick()
			elif self.mucous.mode in ("help", "debug", "status"):
				for s in self.alert["HELP"]:
					if s == "help":
						self.setStatus("New Help")
					elif s == "debug":
						self.setStatus("New Bug")
					elif s == "status":	
						self.setStatus("New Status")
					break
				else:
					self.Pick()
			else:
				self.Pick()
		except Exception, e:
			self.mucous.Help.Log( "debug", "Alert.Next: " + str(e))
			
	## Display old alerts
	# @param self Alerts (class)
	def Pick(self):
		try:
			for mode, lists in self.alert.items():
				#self.log["help"].append(str(mode)+" " +str(l))
				if lists == []:
					continue
				elif lists == {}:
					continue
				
				if mode == "HELP":
					for s in self.alert["HELP"]:
						if s == "help":
							self.setStatus("New Help")
						elif s == "debug":
							self.setStatus("New Bug")
						elif s == "status":	
							self.setStatus("New Status")
						break
					return
				elif mode == "SEARCH":
					for s in self.alert["SEARCH"]:
	
						self.setStatus(self.mucous.Search.tickets[s])
						return

				for i in lists:
					if i != "":
						self.setStatus(i)
						return
			self.setStatus("")
		except Exception, e:
			self.mucous.Help.Log( "debug", "Pick: " + str(e))
			
	## Change Alert contents directly
	# shrunk to 14 characters
	# @param self Alerts (class)
	# @param s string
	def setStatus(self, s):
		try:
			self.log = s
			aw = self.windows["border"]
			aw.erase()
			
			if len(self.log[:14]) < 13 and len(self.log[:14]) > 0:
				line = " "+self.mucous.dlang( self.log[:14] )+" "
			else:
				line = self.mucous.dlang( self.log[:14] )
			aw.addstr(line, self.mucous.colors["yellow"] )
			aw.refresh()
		except Exception, e:
			self.mucous.Help.Log( "debug", "Alert.setStatus: " + str(e))
				
				
## Parse data and reformat it to fit inside the constraints of its window
#
class FormatData:
	## Constructor
	# @param self FormatData (class)
	# @param mucous Mucous (Class)
	def __init__(self, mucous):
		## @var mucous 
		# Mucous (Class)
		self.mucous = mucous

	## Determine Line number and list size to height
	# We assume that this list has already been wrapped
	# @param self FormatData (class)
	# @param current_list list to be shrunk
	# @param hightlight_position where our vertical scroll position is
	# @param height how many lines are in the window
	# @return list, scrolling position, start position
	def scrollbox(self, current_list, hightlight_position, height):
		# Limit text to what fits inside the window
		try:
			length = len(current_list)
			if hightlight_position < 0:
				hightlight_position = 0
			elif hightlight_position > length -1:
				hightlight_position = length-1
			
			start = hightlight_position-height/2
			
			if start  < 0:
				to = hightlight_position + (height-height/2)-start
				start  = 0
				
			else:
				to = hightlight_position + (height-height/2)
				
			if to >= length:
				start = abs(to - length - start)
				to =length
				
			if length < height:
				start =0
			#self.Help.Log("debug", "s%se%su%s"%(start,to,hightlight_position) )
			if current_list[start:to] != [None]:
				clipped_list = current_list[start:to]
			else:
				clipped_list = []
			return clipped_list, hightlight_position, start
		except Exception, e:
			self.mucous.Help.Log("debug", "scrollbox: " + str(e))
			
	## Convert a number into a human-readable string
	# Formats are: 0GB, 0MB, 0KB, 0B
	# @param self FormatData
	# @param filesize can be integer in a string or an integer
	# @return formatted size (string)
	def byte_format(self, filesize):
		try:
			filesize =  int(filesize)
			if filesize >= 1073741824:
				filefrmt = str(filesize/1024/1024/1024) +"GB"
			elif filesize >= 1048576 and filesize <= 1073741824:
				filefrmt = str(filesize/1024/1024) +"MB"
			elif filesize < 1048576 and filesize >= 1024:
				filefrmt = str(filesize/1024) +"KB"
			elif filesize < 1024 and filesize > 0:
				filefrmt = str(filesize) +" B"	
			elif filesize == 0:
				filefrmt = '0'
			return filefrmt
		except Exception, e:
			self.mucous.Help.Log("debug", "byte_format: " + str(e))
        
	## Another int-to-string Conversion
	# Formats are: 0.0GB, 0.0MB, 0.0KB, 0 
	# @param self FormatData
	# @param size filesize can be integer in a string or an integer
	# @return formatted size (string)
	def Humanize(self, size):
		if size is None:
			return None
		try:
			s = int(size)
			if s >= 1000*1024*1024:
				r = "%.1fGB" % ((float(s) / (1024.0*1024.0*1024.0)))
			elif s >= 1000*1024:
				r = "%.1fMB" % ((float(s) / (1024.0*1024.0)))
			elif s >= 1000:
				r = "%.1fKB" % ((float(s) / 1024.0))
			else:
				r = str(size)
			return r
		except Exception, e:
			return size
			
	## Sort a dict by values
	# Return the sorted dict
	# @param self FormatData (class)
	# @param dict the dict
	def sortbyvalue(self, dict):
		try:
			""" Return a list of (key, value) pairs, sorted by value. """
			_swap2 = lambda (x,y): (y,x)
			mdict = map(_swap2, dict.items())
			mdict.sort()
			mdict = map(_swap2, mdict)
			return mdict
		except Exception, e:
			self.mucous.Help.Log("debug", "sortbyvalue: " + str(e))
			
	## Pad string to fill width of window
	# @param self FormatData (class) 
	# @param s string
	# @param w window_dimensions dict
	# @return padded string, length of string
	def StringAddBlanks(self, s, w):
		try:
			#, total_lines
			
			s = str(s); ls = len(s)
			if ls > w["width"]:
				# Add spaces if longer than a single line
				div = (ls/w["width"]) + 1
				length = (w["width"] * div) -  ls 
				if length != 0:
					s += (length * " ")
				#total_lines += div
	
			else:
				# Add spaces till end of first and only line
				s += " " * (w["width"] - ls)
			return s, ls #, total_lines
		except Exception, e:
			self.mucous.Help.Log("debug", "StringAddBlanks: " + str(e))
			
	## Select an item in the list one place away
	# @param self FormatData (class)
	# @param direction (left or right)
	# @param _list the list
	# @param place current position in list
	# @param sort do we alphabetically sort this list? (true/false)
	# @return new or old place 
	def RotateList(self, direction, _list, place, sort):
		try:
			if not _list:
				return place
			if sort == "yes":
				_list.sort(key=str.lower)
			if not place in _list:
				if direction == "left":
					ix = -1
				elif direction == "right":
					ix = 0
				

			else:
				ix = _list.index(place)
				if direction == "left":
					ix -= 1
				elif direction == "right":
					ix += 1
				
				if ix < 0:
					ix = -1
				elif ix >= len(_list):
					ix = 0
			if ix != None:
				place = _list[ix]
			return place
		except Exception, e:
			self.mucous.Help.Log("debug", "RotateList: " +str(e) )
					
	## Break a long string into a list of strings that each fit inside the required width
	# @param self FormatData (class)
	# @param string our long string
	# @param w the window dimensions dict contains "width"
	# @return list
	def StringCutWidth(self, string, w):
		try:
			s = str(string) 
			ls = len(s)
			list_of_strings = []
			if ls > w["width"]:
				div = (ls/w["width"]) + 1
				# Cut long lines into multiple lines
				for seq in range(div):
					list_of_strings.append(s[:w["width"]])
					s = s[w["width"]:]
			else:
				# Short line added to list
				list_of_strings.append(s)
			return list_of_strings
		except Exception, e:
			self.mucous.Help.Log("debug", ": " + str(e))

	## Break a list apart and wrap each line in it to the required width and clip it so only the lines that fit are 
	# @param self FormatData (class)
	# @param the_list list of strings
	# @param scroll scrolling position
	# @param w the window dimensions dict contains "width" and "start"
	# @return clipped_list, numlines, start
	# @return list, scroll position, start position
	def wrap_n_clip(self, the_list, scroll, w):
		try:
			wrapped_lines = []
			for lines in the_list:
				#lines = str(lines)
				lines1 = ""
				for a in lines:
					if curses.ascii.isctrl(a):
						a = curses.ascii.unctrl(a)
					lines1 += a
				list_of_strings = self.StringCutWidth(lines1, w)
				for string in list_of_strings:
					wrapped_lines.append(string)
			if scroll == -1 or scroll > len(wrapped_lines):
				scroll = len(wrapped_lines)
			clipped_list, numlines, w["start"] = self.scrollbox(wrapped_lines, scroll, w["height"])
			return clipped_list, scroll, w["start"]
		except Exception, e:
			self.mucous.Help.Log("debug", "wrap_n_clip " +str(e))


## Muscan commands, threads
#
class Muscan:
	## Constructor
	# Launch a local muscan process with special options from the setup buttons,
	# Or from /commands
	## @author daelstorm
	# @param self Muscan (Class)
	# @param mucous Mucous (Class)
	def __init__(self, mucous):
		## @var mucous
		# Mucous (Class)
		self.mucous = mucous
		## @var timer
		# threading timer that calls ThreadMuscan
		self.timer = threading.Timer(1.0, self.ThreadMuscan)
		## @var command
		# once set, a list of command options for subprocess
		self.command = []

	## Clear timer and restart it in one second
	# @param self Muscan (Class)
	def RestartTimer(self):
		self.timer.cancel()
		self.timer = threading.Timer(1.0, self.ThreadMuscan)
		self.timer.start()

	## Set command and call RestartTimer
	# @param self Muscan (Class)
	# @param command List of command options for subprocess
	def Command(self, command):
		self.command = command
		self.RestartTimer()

	## Spawn Subprocess and accept stdout and stderr
	# @param self Muscan (Class)
	def ThreadMuscan(self):
		try:
			self.timer.cancel()
			if subprocess_fail:
				self.mucous.Help.Log("status", "This feature requires Python 2.4")
				return
			if mucous_config["connection"]["interface"][:9] in ("localhost", "/tmp/muse") and self.command != [] :
				p = "/usr/bin/muscan"
				if os.path.exists(p):
				
					z = subprocess.Popen( self.command, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
					stdout_text, stderr_text = z.communicate()
					z.wait()
					
					stdout_text = stdout_text.split('\n')
					stderr_text = stderr_text.split('\n')
					for line in stdout_text:
						if line.isspace() or line == '':
							pass
						else:
							self.mucous.Help.Log("status", line)
					for line in stderr_text:
						if line.isspace() or line == '':
							pass
						else:
							self.mucous.Help.Log("status", line)
					self.mucous.Help.Log("status", "Finished with shares.")
			else:
				self.mucous.Help.Log("status", "Your Museekd is either running remotely or already running a command, cancelling.")
		
			self.command = []
		except Exception,e:
			self.mucous.Help.Log("debug", "ThreadMuscan: " + str(e))

	## Change setup input mode, so directory paths can be inputted
	# @param self Muscan (Class)
	# @param inputmode string that is set as Spl["setup_input"] variable
	def ChangeInput(self, inputmode):
		self.mucous.Setup.input = inputmode
		self.mucous.Setup.Mode()

	## Output list of Normal shared directories to debug log
	# @param self Muscan (Class)
	def ListNormal(self):
		self.command = ["muscan", "-c", self.mucous.Spl["museekconfigfile"], "-l"]
		self.RestartTimer()
		self.mucous.Help.Log("status", "Listing normal shares with muscan.")

	## Output list of Buddy-only shared directories to debug log
	# @param self Muscan (Class)
	def ListBuddy(self):
		self.command = ["muscan", "-c", self.mucous.Spl["museekconfigfile"], "-b", "-l"]
		self.RestartTimer()
		self.mucous.Help.Log("status", "Listing buddy shares with muscan.")

	## Rescan Buddy-only Shares (rebuilds shares from scratch)
	# @param self Muscan (Class)
	def RescanBuddy(self):
		self.command = ["muscan", "-c", self.mucous.Spl["museekconfigfile"], "-v", "-b", "-r"]
		self.RestartTimer()
		self.mucous.Help.Log("status", "Rescanning buddy shares with muscan, don't forget to Reload them.")

	## Update Buddy-only Shares (checks mtimes and updates only newer dirs/files)
	# @param self Muscan (Class)
	def UpdateBuddy(self):
		self.command = ["muscan", "-c", self.mucous.Spl["museekconfigfile"], "-v", "-b"]
		self.RestartTimer()
		self.mucous.Help.Log("status", "Updating buddy shares with muscan, don't forget to Reload them.")

	## Update Normal Shares (checks mtimes and updates only new dirs) 
	# @param self Muscan (Class)
	def UpdateNormal(self):
		self.command = ["muscan", "-c", self.mucous.Spl["museekconfigfile"], "-v"]
		self.RestartTimer()
		self.mucous.Help.Log("status", "Updating shares with muscan, don't forget to Reload them.")

	## Rescan Normal Shares (rebuilds shares from scratch)
	# @param self Muscan (Class)
	def RescanNormal(self):
		self.command = ["muscan", "-c", self.mucous.Spl["museekconfigfile"], "-v", "-r"]
		self.RestartTimer()
		self.mucous.Help.Log("status", "Rescanning shares with muscan, don't forget to Reload them.")
		
## Userinfo text and user statistics
# Tabbed buttons display along the top
# Left window contains userinfo description
# Right window contains statistics
class Userinfo:
	## Constructor
	# @param self Userinfo (class)
	# @param mucous Mucous (class)
	def __init__(self, mucous):
		## @var mucous 
		# Mucous (Class)
		self.mucous = mucous
		## @var requests 
		# Users whose info we've requested (Discard other requests)
		self.requests = []
		## @var current
		# Currently shown user's info
		self.current = None
		## @var users 
		# Users whose info we have
		self.users = []
		## @var logs
		# dict containing descriptions and stats of users
		self.logs = {}
		## @var windows
		# dict containing instances of curses windows
		self.windows = {}
		## @var dimensions
		# dict containing placement data for windows
		self.dimensions = {}
		## @var scrolling
		# dict of users contain vertical position in their user info
		self.scrolling =  {}
		## @var scrolling_status
		# int of scroll position in instructions 
		self.scrolling_status = 0  
		
	## Request userinfo from a user
	# @param self Userinfo (class)
	# @param user the Username
	def Get(self, user):
		if user not in self.requests:
			self.requests.append(user)
		self.mucous.SendMessage(messages.UserInfo(user))
		
	## Recieved userinfo
	# If a picture is included, save it to disk as username.image
	# @param self Userinfo (class)
	# @param user the Username
	# @param info the description
	# @param picture the image, if it exists
	# @param uploads number of uploads slots
	# @param queue Length of queue
	# @param slotsfree has free slots?
	def Recieved(self, user, info, picture, uploads, queue, slotsfree):
		if user not in self.requests:
			return
		self.requests.remove(user)
		self.scrolling[user] = 0
		message = info.split('\n')
		pic = False
		if picture != '':
			r = file(config_dir+str(user)+".image", 'w')
			print >> r, str(picture)
			r.close()
			self.StatsLog( "Saved UserImage as: "+ str(user)+".image")
			pic = True
		self.Log(user, message, uploads, queue, slotsfree, pic)
		
		if self.mucous.mode != "info":
			#self.mucous.Alerts.setStatus("New Userinfo")
			#self.mucous.Alerts.alert["INFO"].append(user)
			self.mucous.Alerts.Add(user, "INFO")
			self.mucous.HotKeyBar()
	## Draw windows
	# @param self Userinfo (class)
	def Mode(self):
		try:
			self.mucous.mode = "info"
			self.mucous.PopupMenu.show = False
			# Cleanup stale windows
			if "text" in self.windows:
				del self.windows["text"]
			if "border" in self.windows: 
				del self.windows["border"]
			if "infostats" in self.windows:	
				del self.windows["infostats"]
			if "statsborder" in self.windows:
				del self.windows["statsborder"]
			
			w = self.dimensions["info"] = {"height": self.mucous.h-10, "width": self.mucous.w-20, "top": 5, "left": 1}
			mw = self.windows["border"] = curses.newwin(w["height"]+2, w["width"]+2, w["top"]-1, w["left"]-1)
			mw.attron(self.mucous.colors["green"])
			mw.border()
			mw.attroff(self.mucous.colors["green"])
			try:
				mw.addstr(0, 3, "< Info Mode >",  self.mucous.colors["green"] | curses.A_BOLD)
			except:
				pass
	
			tw =  self.windows["info"] = mw.subwin(w["height"], w["width"], w["top"], w["left"])
			tw.scrollok(0)
			tw.idlok(1)
			
			#self.scrolling = -1
	
			self.mucous.set_edit_title("Get info about user:")
			
			sw = self.dimensions["infostats"]= {"height": self.mucous.h-10, "width": 16, "top": 5, "left": self.mucous.w-17}
			isw = self.windows["statsborder"] = curses.newwin(sw["height"]+2, sw["width"]+2, sw["top"]-1, sw["left"]-1)
			isw.border()
			isw.addstr(0, 2, "< Stats >")
			isw.noutrefresh()
			itw = self.windows["infostats"] = isw.subwin(sw["height"], sw["width"], sw["top"], sw["left"])
			itw.scrollok(1)
	
			mw.noutrefresh()
			
			self.DrawText()
			itw.noutrefresh()
			# queue, uploads, speed, downloads, files, directories, freeslots

			self.mucous.DrawTabs(self.users, self.current)
			self.DrawStats()
			self.mucous.Alerts.Check()
			curses.doupdate()
			#self.HotKeyBar()
		except Exception, e:
			self.mucous.Help.Log("debug", "Userinfo.Mode: " + str(e))
			
	## Select another user
	# @param self Userinfo (class)
	# @param direction left/right list scrolling
	def Select(self, direction):
		try:
			if self.current == None:
				self.current = self.users[0]
				self.Mode()
				return
			place = self.mucous.FormatData.RotateList(direction, self.users, self.current, "yes" )
			if self.current != place:
				self.current = place
				self.Mode()
		except Exception, e:
			self.mucous.Help.Log("debug", "Userinfo.Select: " + str(e))
	
	## Draw text in text window
	# @param self Userinfo (class)
	def DrawText(self):
		try:
			scrolltext = "info"
			w = self.dimensions["info"] 
			lang = mucous_config["mucous"]["language"]
			tw = self.windows["info"]
			if self.current != None:
				self.mucous.DrawInstructionsButtons()
				# Display Userinfo & Stats
				clipped_list, self.scrolling[self.current], w["start"] = self.mucous.FormatData.wrap_n_clip(self.logs[self.current][0], self.scrolling[self.current], w)
				
			else:
				# Display instructions, IP info, and stats
				clipped_list, self.scrolling_status, w["start"] = self.mucous.FormatData.wrap_n_clip( self.mucous.Help.log["userinfo"], self.scrolling_status, w)
				
	
			attrs = curses.A_BOLD; attr = curses.A_NORMAL
			count = 0
			tw.erase()
			if self.current == None:
				scroll = self.scrolling_status
			else:
				scroll = self.scrolling[self.current]
			
			for lines in clipped_list:
				try:
					lines, ls = self.mucous.FormatData.StringAddBlanks(lines, w)
					if count + w["start"] == scroll:
						tw.addstr(self.mucous.dlang(lines), attrs)
					else:
						tw.addstr(self.mucous.dlang(lines), attr)
					count += 1
				except Exception, e:
					pass
			tw.noutrefresh()
		except Exception, e:
			self.mucous.Help.Log("debug", "Userinfo.DrawText: " + str(e))

					
	## Draw statistics in info stats windo
	# @param self Userinfo (class)
	def DrawStats(self):
		try:
			itw = self.windows["infostats"]
			itw.erase()
			if self.current != None and self.mucous.mode=="info":
				userinfo = self.logs[self.current]
				if int(userinfo[1][2]):
					slots = "Yes"
				else:
					slots = "No"
				if userinfo[1][3]:
					image = "Yes"
				else:
					image = "No"
				itw.addstr('Slots: %s' % str(userinfo[1][0]) + \
                                          '\nQueue: %s' % str(userinfo[1][1]) + \
                                          '\nFree: %s' % slots +\
					  '\nImage: %s' % image)

				if self.current in self.mucous.user["statistics"].keys():
					try:
                                                stats = self.mucous.user["statistics"][self.current]
						itw.addstr('\nSpeed: %.2fKB' % (stats[0]/1024.0))
						itw.addstr('\nDown: %s' % str(stats[1]))
						itw.addstr('\nFiles: %s' % str(stats[2]))
						itw.addstr('\nDirs: %s' % str(stats[3]))
					except:
						pass
			itw.noutrefresh()
		except Exception, e:
			self.mucous.Help.Log("debug", "Userinfo.DrawStats: " + str(e))
			
	## Mouse Coordinates in the User Info Mode
	# @param self is Userinfo (class)
	# @param x is the horizontal position from the left
	# @param y is the vertical postion from the top
	# @param z is unimportant
	# @param event is the mouse event (button, doubleclick, etc) represented by a number
	def Mouse(self, x,y,z,event):
		try:
			if y in (2, 3, 4):
				if len(self.users) >= 1:
					
					if self.current == None:
						self.current = self.users[0]
					self.current, match = self.mucous.MouseClickTab(x, self.current)
					if match == None:
						s = self.users.index(self.current)
						self.current = self.users[s-1]
					#self.DrawStats()
					self.Mode()
					
			if self.current != None:
				if y  in (5,6):
					if x >=self.mucous.w-19-2-16 and x < self.mucous.w-12:
						self.current=None
						self.Mode()
				elif y in ( self.mucous.h-3, self.mucous.h-4, self.mucous.h-5):
					if x >=self.mucous.w-10 and x < self.mucous.w-1:
						self.Close(self.current)
		except Exception, e:
			self.mucous.Help.Log("debug", "MouseUserInfo: " +str(e) )
			
	## Close userinfo
	# @param self Userinfo (class)
	# @param user the Username
	def Close(self, user):
		try:
			if user in self.users:
				self.users.remove(user)
			if self.users != []:
				for users in self.users:
					self.current = users
					break
			else:
				self.current = None
			if user in self.mucous.Alerts.alert["INFO"]:
				self.mucous.Alerts.alert["INFO"].remove(user)
			if self.mucous.mode == 'info':
				self.Mode()
		except Exception, e:
			self.mucous.Help.Log("debug", "UserInfo.Close: " + str(e))
	
	## Append stats to text log
	# @param self Userinfo (class)
	# @param s string
	def StatsLog(self, s):
		try:
			s= self.mucous.dlang(s)
			if "\n" in s:
				lis = s.split("\n")
				for line in lis:
					self.mucous.Help.log["userinfo"].append("%s" % line)
			else:
				self.mucous.Help.log["userinfo"].append("%s" % s)
			if self.mucous.mode == "info" and self.current == None:
				self.DrawText()
		except Exception, e:
			self.mucous.Help.Log("debug", "StatsLog: " + str(e))
			
	## Store Userinfo, stats in Log
	# @param self Userinfo (class)
	# @param user username
	# @param description user's info/description
	# @param user username
	# @param uploads number of uploads slots
	# @param queue Length of queue
	# @param slotsfree has free slots (True/False)
	# @param pic has a picture (True/False)
	def Log(self, user, description, uploads, queue, slotsfree, pic):
		try:
			if self.current == None:
				self.current = user
			if user not in self.logs:
				self.logs[user] = []
			if user not in self.users:
				self.users.append(user)
			self.logs[user] = description, [uploads, queue, slotsfree, pic]
			if user not in self.mucous.user["statistics"].keys():
				self.mucous.SendMessage(messages.PeerStats(user))
			if self.mucous.mode == 'info':
				self.Mode()
		except Exception, e:
			self.mucous.Help.Log("debug", "Userinfo.Log: " + str(e))
			
## Chat Rooms
#			
class ChatRooms:
	## Constructor
	# @param self ChatRooms (class)
	# @param mucous Mucous (class)
	def __init__(self, mucous):
		## @var mucous 
		# Mucous (Class)
		self.mucous = mucous
		## @var shape
		# Layout of windows
		self.shape = mucous_config["mucous"]["roombox"]
		## @var dimensions
		# Window placement
		self.dimensions = {}
		## @var windows
		# Curses Window instances
		self.windows = {"text": {}, "border": {} }
		## @var scrolling
		# dict containing vertical scroll position for chatroom, roombox and roomstatus
		self.scrolling = {"chatroom": -1, "roombox": 0, "roomstatus": -1 }
		## @var current
		# current room
		self.current = None
		## @var selected
		# selected window
		self.selected = "chatroom"
		## @var logs
		# dict containing logs for chatroom, roombox and roomstatus 
		self.logs = {"rooms": {},"roombox": {} , "roomstatus": {} }
		## @var rooms
		# dict of users in rooms
		self.rooms = {}
		## @var numticker
		# position of ticker
		self.numticker = 0
		## @var tickers
		# dict of rooms containing lists of tickers 
		self.tickers = {}
		## @var ticker_timer
		# Timer instance for displaying tickers
		self.ticker_timer = threading.Timer(time, self.DrawTicker)
		
	## Create and draw current chat room's window and contents 
	# Cleanup stale windows first
	# Calls: set_room
	def Mode(self):
		try:
			self.mucous.mode = "chat"
			self.mucous.PopupMenu.show = False
			
			# Arrangements: 
			cs = None
			if "roomstatus" in self.windows["text"]:
				del self.windows["text"]["roomstatus"]
			if "roomstatus" in self.windows["border"]:
				del self.windows["border"]["roomstatus"]
			
			if "chat" in self.windows["text"]:
				del self.windows["text"]["chat"]
			if "chat" in self.windows["border"]:
				del self.windows["border"]["chat"]
				
			if self.shape == "big":
				w = self.dimensions["chat"] = {"height": self.mucous.h-13, "width": self.mucous.w-15, "top": 8, "left": 16}
				cs = self.dimensions["roomstatus"] = {"height": 4, "width": w["width"]-2, "top": 2, "left": w["left"]}
			elif self.shape == "widelist":
				w = self.dimensions["chat"] = {"height": self.mucous.h-13, "width": self.mucous.w-25, "top": 8, "left": 26}
				cs = self.dimensions["roomstatus"] ={"height": 4, "width": w["width"]-2, "top": 2, "left": w["left"]}
			elif self.shape in ("noroombox", "small"):
				w = self.dimensions["chat"] = {"height": self.mucous.h-13, "width": self.mucous.w, "top": 8, "left": 1}
				if self.shape in ("noroombox"):
					cs = self.dimensions["roomstatus"] = {"height": 4, "width": w["width"]-2, "top": 2, "left": 1}
					#cs["height"]-2, cs["width"]-1, cs["top"]+1,cs["left"]+1
				elif self.shape in ("small"):
					cs = self.dimensions["roomstatus"] = {"height": 4, "width": w["width"]-15-2, "top": 2, "left": 16}
			elif self.shape == "rightlist":
				w = self.dimensions["chat"] = {"height": self.mucous.h-13, "width": self.mucous.w-15, "top": 8, "left": 1}
				cs = self.dimensions["roomstatus"] = {"height": 4, "width": w["width"]-2, "top": 2, "left": 1}
			elif self.shape == "nostatuslog":
				w = self.dimensions["chat"] = {"height": self.mucous.h-7, "width": self.mucous.w-15, "top": 2, "left": 16}
			elif self.shape == "chat-only":
				w = self.dimensions["chat"] = {"height": self.mucous.h-7, "width": self.mucous.w, "top": 2, "left": 1}
			
			if cs != None:
				brw = self.windows["border"]["roomstatus"] = curses.newwin(cs["height"]+2, cs["width"]+2, cs["top"]-1, cs["left"]-1)
				btw= self.windows["text"]["roomstatus"] = brw.subwin(cs["height"], cs["width"], cs["top"],cs["left"])
				btw.scrollok(0)
					
			self.dimensions["chat"]["start"] = 0
			try:
				mw = self.windows["border"]["chat"] = curses.newwin(w["height"]+2, w["width"], w["top"]-1, w["left"]-1)
				if self.mucous.username == None:
					#mw.border()
					mw.noutrefresh()
					
				tw =self.windows["text"]["chat"] = self.windows["border"]["chat"].subwin(w["height"], w["width"], w["top"], w["left"]-1)
			except Exception, e:
				self.mucous.Help.Log("debug", "Chat Mode: " + str(e))

			tw.scrollok(0)
			tw.idlok(1)

			if self.mucous.Alerts.log in ( "New Chat", "Nick Mention"):
				self.mucous.Alerts.setStatus("")	

			self.set_room(self.current)

			
			curses.doupdate()
		except Exception, e:
			self.mucous.Help.Log("debug", "ChatRooms.Mode: " + str(e))
			
	## Joined a room
	# 
	def Joined(self, name, users, tickers=None):
		try:
			if name not in self.logs["rooms"]:
				self.logs["rooms"][name] = []
				self.logs["roomstatus"][name] = []
				self.OldLogs(name)
						
				
				for user in users:
					self.mucous.user["status"][user] = users[user][0]
					self.mucous.user["statistics"][user] = users[user][1], users[user][2 ], users[user][3], users[user][4]
					
				self.rooms[name] = users.keys()
					#avgspeed, numdownloads, numfiles, numdirs
	
				# tickers == (rooms, [(user1: message1), (user2: message2),] )
				# a string and then a dictionary

				if tickers:
					self.tickers[name] = tickers
				
		except Exception, e:
			self.mucous.Help.Log("debug", "ChatRooms.Joined: " + str(e))
			
	## Leave a room or current room
	# @param self ChatRooms (class)
	# @param room Chat room to be left
	def Leave(self, room=None):
		if room:
			if room in self.rooms:
				self.SendMessage(messages.LeaveRoom(room))
			return
		if self.current:
			self.SendMessage(messages.LeaveRoom(self.ChatRooms.current))
			
	## Left a room
	# @param self ChatRooms (class)
	# @param room room that was left
	def Left(self, room):
		
		del self.rooms[room]
		joined = self.rooms.keys()
		joined.sort(key=str.lower)
		
		if room == self.current:
			if len(joined) == 1:
				self.Change(None)
			else:
				ix = joined.index(room)
				if ix > 0:
					ix -= 1
				elif ix == 0:
					ix = -1
				self.Change(joined[ix])
				self.AppendChat("Status", joined[ix], '!!!!', "Left room %s" % room)
		joined.remove(room)
		del self.rooms[room]
		del self.tickers[room]
		del self.logs["roomstatus"][room]
		if joined == []:
			self.Change(None)
			self.DrawChatWin()
			self.windows["text"]["chat"].noutrefresh()
		else:
			joined.sort(key=str.lower)
		if room in self.Alerts.alert["CHAT"]:
			del self.Alerts.alert["CHAT"][room]
		curses.doupdate()
		if self.Alerts.log == "%s" % room[:14]:
			self.Alerts.setStatus("")
			
	## Say message In Chat room or current room
	# :: Split \n (newlines) into seperate messages
	# @param self ChatRooms (class)
	# @param room Chat room
	# @param message test
	def SayInChat(self, room, message):
		try:
			
			message = self.mucous.dencode_language(message)
			if room == None or message == None:
				return
			if '\\n' in message:
				
				splited =  message.split('\\n')
				
				if len(splited) > 5:
					
					for i in range(5):
						self.mucous.SendMessage(messages.SayRoom(room, splited[i]))
					self.mucous.Help.Log("debug", "Your chat message was really long, so it was cut to keep you from getting muted.")
				else:
					for i in range(len(splited)):
						self.mucous.SendMessage(messages.SayRoom(room, splited[i]))
				
			else:
				self.mucous.SendMessage(messages.SayRoom(room, message))
					
		except Exception, e:
			self.mucous.Help.Log("debug", "SayInChat: " + str(e))

				

	## Append status change to log
	# @param self ChatRooms (Class)
	# @param user Username
	# @param room Chat room
	# @param did Is one of [ticker, join, part, change]
	# @param what contains (the ticker if did is ticker) or (away, offline, online if change)
	def AppendStatus(self, user, room, did, what):
		try:

			yes = 0
			if room not in self.logs["roomstatus"]:
				self.logs["roomstatus"][room] = []
			oldlen = len(self.logs["roomstatus"][room])
			if did == "ticker" and what != '':
				if user in self.rooms[room]:
					if room == self.current:
						yes =1
						
			elif did == "join":
				self.logs["roomstatus"][room].append("%s %s joined" % (time.strftime("%H:%M:%S"), user))
				if room == self.current:
					yes =1
					
			elif did == "left":
				self.logs["roomstatus"][room].append("%s %s left" % (time.strftime("%H:%M:%S"), user))
				if room == self.current:
					yes =1
			elif did == "change":
				for rooms11 in self.rooms.keys():
					if user in self.rooms[rooms11]:
						string = "%s %s is %s" % (time.strftime("%H:%M:%S"), user, what)
						if self.logs["roomstatus"][rooms11] == []:
							self.logs["roomstatus"][rooms11].append(string)
							if rooms11 == self.current:
								yes =1
						elif string[10:] != self.logs["roomstatus"][rooms11][-1][10:]:
							self.logs["roomstatus"][rooms11].append(string)
							if rooms11 == self.current:
								yes = 1
								
			if "roomstatus" not in self.windows["text"]:
				return			
			tw = self.windows["text"]["roomstatus"]
			if self.mucous.mode == "chat" and yes == 1:
				if self.scrolling["roomstatus"] >= oldlen -1:
					if len(self.logs["roomstatus"][room]) > 305:
						del self.logs["roomstatus"][room][0]
					self.scrolling["roomstatus"] = -1
					self.DrawStatusText()

		except Exception, e:
			self.mucous.Help.Log("debug", "AppendStatus: " + str(e))
	## Join a room
	# @param self is ChatRooms (Class)
	# @param room is a text string
	def JoinRoom(self, room):
		try:
			self.mucous.SendMessage(messages.JoinRoom( self.mucous.dlang( room ) ))
		except Exception,e:
			self.mucous.Help.Log("debug", "JoinRoom: " + str(e))
			
	## Loop and Draw the tickers in one of two ways (scrolling, cycling)
	# :: Scrolling shows the entire ticker, while Cycling shows only the part that fits in the viewable area
	# @param self is ChatRooms (Class)
	def DrawTicker(self):
		try:
			if self.mucous.mode != "chat" or self.current not in self.tickers or mucous_config["tickers"]["tickers_enabled"] != 'yes':
				return
			ticks = self.tickers[self.current]
			ttickers = ticks.keys()
			if ttickers == []:
				self.ticker_timer.cancel()
				try:
					self.DrawStatusWin()
					self.DrawStatusText()
					curses.doupdate()
				except:
					pass
			else:
				ttickers.sort(key=str.lower)
				if mucous_config["tickers"]["ticker_scroll"] == "yes":
					if self.mucous.PopupMenu.show == True:
						self.ticker_timer.cancel()
						self.ticker_timer = threading.Timer(float(mucous_config["tickers"]["scrolltime"]), self.DrawTicker)
						self.ticker_timer.start()
						return
					longstring = ""
					for user in ttickers:
						longstring += "[%s] %s " % (user, ticks[user])
					if self.shape in ("nostatuslog", "chat-only"):
						bw = self.windows["border"]["chat"]
						s = self.dimensions["chat"]
						padd = -3; posy = 0; posx = 2
					else:
						 
						bw = self.windows["border"]["roomstatus"]
						s = self.dimensions["roomstatus"]
						padd = 0; posy = 5; posx = 1
					
					if self.numticker >= len(longstring):
						self.numticker = 0
					part = longstring[self.numticker:self.numticker+s["width"]-2+padd]
					while len(part) < s["width"]-2 +padd:
						part += longstring[:(s["width"]-2+padd - len(part))] 
					fill = (s["width"]-2 - len(part) +padd) * " "
					bw.addstr(posy, posx, "<%s%s>" %(part, fill))
					bw.refresh()
					self.numticker += 1
					#if self.numticker >= len(ttickers):
						#self.numticker = 0
					self.ticker_timer.cancel()
					self.ticker_timer = threading.Timer(float(mucous_config["tickers"]["scrolltime"]), self.DrawTicker)
					self.ticker_timer.start()
					return
			
				
				if self.numticker >= len(ttickers):
					self.numticker = 0
				names = ttickers[self.numticker]
				n = len(names)
				try:
					if self.mucous.PopupMenu.show == True: raise Exception,  "Noticker"
					if self.shape not in ("nostatuslog", "chat-only"):
						if "roomstatus" not in self.windows["border"]:
							return
						bw = self.windows["border"]["roomstatus"]
						s = self.dimensions["roomstatus"]
						tick = str(ticks[names][:s["width"]-7-n])
						fill = (s["width"]-6-len(tick)-len(names)) * " "
						string = "< [%s] %s%s>" % (names, tick, fill)
						bw.addstr(5, 1, self.mucous.dlang( string ))
						bw.refresh()
						
					elif self.shape in ("nostatuslog", "chat-only"):
						mw = self.windows["border"]["chat"]
						s = self.dimensions["chat"]
						tick = str(ticks[names][:s["width"]-25-n])
						fill = (s["width"]-25-len(tick)-len(names)) * " "
						string = "< [%s] %s%s>" %(names, tick, fill)
						mw.addstr(0, 18, self.mucous.dlang( string ))
						mw.refresh()
				except:
					pass
				

				self.numticker += 1

				self.ticker_timer.cancel()
				self.ticker_timer = threading.Timer(float(mucous_config["tickers"]["cycletime"]), self.DrawTicker)
				self.ticker_timer.start()
				
				
		except Exception,e:
			self.mucous.Help.Log("debug", "DrawTicker: " + str(e))
			
	## Draw the chat window's border
	# @param self is ChatRooms (Class)
	def DrawChatWin(self):
		try:
			s = self.dimensions["chat"]
			mw = self.windows["border"]["chat"]
			if self.selected == "chatroom":
				mw.attron(self.mucous.colors["green"])
				mw.hline(0, 0, curses.ACS_HLINE, s["width"]-1)
				mw.hline(s["height"]+1, 0, curses.ACS_HLINE, s["width"]-1)
				mw.addstr(0, 0, "Oo",  self.mucous.colors["green"] | curses.A_BOLD)
				mw.addstr(0, 3, "< Chat Rooms >",  self.mucous.colors["green"] | curses.A_BOLD)
				mw.addstr(0, s["width"]-1, "^",  self.mucous.colors["green"] | curses.A_BOLD)
				try:
					mw.addstr(s["height"]+1, s["width"]-1, "v",  self.mucous.colors["green"] | curses.A_BOLD)
				except: pass
				mw.addstr(s["height"]+1, 2, "< "+str(abs(self.scrolling["chatroom"]))+" >", self.mucous.colors["green"] | curses.A_BOLD)
				if self.current != None:
					if len(self.logs["rooms"][self.current]) -1 <= abs(self.scrolling["chatroom"]):
						mw.addstr(s["height"]+1, 10, "< AutoScrolling >", self.mucous.colors["green"] | curses.A_BOLD)
				
			else:
				mw.hline(0, 0, curses.ACS_HLINE, s["width"]-1)
				mw.hline(s["height"]+1, 0, curses.ACS_HLINE, s["width"]-1)
				mw.addstr(0, 0, "Oo", curses.A_BOLD)
				mw.addstr(0, 3, "< Chat Rooms >",   curses.A_BOLD)
				mw.addstr(0, s["width"]-1, "^",  curses.A_BOLD)
				try:
					mw.addstr(s["height"]+1, s["width"]-1, "v",  curses.A_BOLD)
				except: pass
# 				mw.addstr(s["height"]+1, 2, "< "+str(abs(self.scrolling["chatroom"]))+" >", curses.A_BOLD)
			mw.noutrefresh()
			
		except Exception,e :
			self.mucous.Help.Log("debug", "ChatRooms.DrawChatWin: " + str(e))

	## Mouse Coordinates in the Chat Rooms Mode
	# @param self is ChatRooms (class)
	# @param x is the horizontal position from the left
	# @param y is the vertical postion from the top
	# @param z is unimportant
	# @param event is the mouse event (button, doubleclick, etc) represented by a number
	def MouseChat(self, x, y, z, event):
		try:
			w = self.dimensions["chat"]
			if y == w["top"]-1 and x >= w["left"]-1 and x < w["left"]+3:
				self.ChatLayout()
				return
			# Clickable room switch
			
			if "roombox" in self.dimensions and self.shape not in ( "noroombox", "chat-only"):
				roombox = self.dimensions["roombox"]
				if y >= roombox["top"]-1 and y < roombox["top"] + roombox["height"] and x < roombox["width"] + roombox["left"] and x > roombox["left"]:
					if self.selected != "roombox":
						self.selected = "roombox"
						self.Mode()
					y -= roombox["top"]
					if "start" not in roombox:
						return
					if y  + roombox["start"] in range(len(self.logs["roombox"][self.current])):
						
						sup = y  + roombox["start"]
						if event in ( 4096, 16384):
							if sup != self.scrolling["roombox"]:
								self.scrolling["roombox"] = sup
							self.DrawBox()
							
							self.mucous.PopupMenu.Create("roombox", 0, True)
							curses.doupdate()
						else:
							if sup != self.scrolling["roombox"]:
								self.scrolling["roombox"] = sup
								self.DrawBox()
								curses.doupdate()
					return
				elif y == roombox["top"] + roombox["height"] and x < roombox["width"] + roombox["left"] and x > roombox["left"]:
					self.ModifyConfig("autojoin", self.current, '')
						
			if y == self.mucous.h-3 or y == self.mucous.h-4:
				if x>= self.mucous.w-27 and x < self.mucous.w-18:
					self.mucous.PopupMenu.Create("encoding", 0, True)
				
				elif x >= self.mucous.w-17 and x < self.mucous.w-1:
					joined = self.rooms.keys()
					joined.sort(key=str.lower)
					if not self.current in joined:
						ix = 0
					else:
						ix = joined.index(self.current)
						
						if x >= self.mucous.w-9 and x < self.mucous.w-1:
							# Next Button
							ix += 1
						elif x <= self.mucous.w-10 and x >= self.mucous.w-17:
							# Prev Button
							ix -= 1
						else:
							return
						if ix < 0:
							ix = -1
						elif ix >= len(joined):
							ix = 0
					self.Change(joined[ix])
					
			elif y  in (w["top"] + w["height"], w["top"] + w["height"]-1) and x >= w["left"] + w["width"]-5 and x <= w["left"] + w["width"]:
				self.mucous.key = "KEY_NPAGE"
				self.mucous.ScrollText()
				
			elif y in ( w["top"], w["top"]+1)  and x >= w["left"] + w["width"]-5 and x <= w["left"] + w["width"]:
				self.mucous.key = "KEY_PPAGE"
				self.mucous.ScrollText()
			else:
				if y >= w["top"]-1 and y < w["top"] + w["height"] +1 and x >= w["left"] -1 and x < w["left"] +w["width"]+1:
					if self.selected != "chatroom":
						self.selected = "chatroom"
						self.Mode()
				if "roomstatus" in self.dimensions and self.shape not in ( "nostatuslog", "chat-only") and self.selected != "roomstatus":
					w =  self.dimensions["roomstatus"]
					if y >= w["top"]-1 and y < w["top"] + w["height"] +1 and x >= w["left"] -1 and x < w["left"] +w["width"]+1:
						self.selected = "roomstatus"
						self.Mode()
		except Exception, e:
			self.mucous.Help.Log("debug", "MouseChat: " +str(e) )
			
	## Read Old Chat Room Logs from Disk
	# @param self is ChatRooms (class)
	# @param room room's name used to get log file
	def OldLogs(self, room):
		try:
			# Read from Chat Room Logs
			if "\\" in room: room = room.replace("/", "\\")
			if os.path.exists(os.path.expanduser(mucous_config["mucous"]["log_dir"])+"/rooms/"+room):
				path = os.path.expanduser(mucous_config["mucous"]["log_dir"])+"/rooms/"+room
				f = open(path, "r")
				a = f.read()
				f.close()
				lines = a.split("\n" )
				numlines = -30
				if len(lines) <= abs(numlines):
					numlines = 0
				for line in lines[numlines:]:
					if line == "":
						continue
					timex = line[12:20]
					if line[21] == "[":
						user = line[22:]
						if line.find("\t") == -1:
						# old format
							user = user[:user.find("]")]
							message = line[21+len(user)+3:]
						else:
							# new format with Tab
							user = user[:user.find("\t")-1]
							message = line[line.find("\t")+1:]
					else:
						user = line[21:]
						user = user[:user.find(" ")]
						message = line[21+len(user)+1:]
						
					
					if message[:4] == "/me ": 
						full_message = ["Me", timex, user, message[4:]]
					else:
						full_message = ["Normal", timex, user, message]
					self.logs["rooms"][room].append(full_message)
				self.logs["rooms"][room].append(["Status", "--------", "!!!!", "Connected to Museek"])
			
		except Exception,e:
			self.mucous.Help.Log("debug", "OldLogs: " +str( e) )
			
	## Draw Status Window Text
	# @param self is ChatRooms (class)
	def DrawStatusText(self):
		try:
			if self.shape in ("nostatuslog", "chat-only"):
				return
			if self.mucous.PopupMenu.show == True:
				return
			if self.mucous.mode != "chat":
				return
			s = self.dimensions["chat"]
			tw = self.windows["text"]["roomstatus"]
			w = self.dimensions["roomstatus"]
			
			tw.erase()
			tw.idlok(1)
	
			if self.current == None or self.logs["roomstatus"][self.current] == []:
				tw.noutrefresh()
				return
				
		
			if self.scrolling["roomstatus"] == -1:
				self.scrolling["roomstatus"] = len(self.logs["roomstatus"][self.current])

			clipped_list, self.scrolling["roomstatus"], self.dimensions["roomstatus"]["start"] = self.mucous.FormatData.scrollbox(self.logs["roomstatus"][self.current], self.scrolling["roomstatus"], self.dimensions["roomstatus"]["height"])
			count = 0
			try:
				for line in clipped_list:
					#self.mucous.Help.Log("debug", line +str(self.scrolling["roomstatus"]))
					if len(line) > w["width"]:
						line = line [:w["width"] -len(line) ]
					else:
						line += " " * (w["width"] -len(line))
					if count + self.dimensions["roomstatus"]["start"] == self.scrolling["roomstatus"]:
						tw.addstr(self.mucous.dlang( line) , curses.A_BOLD)
					else:
						tw.addstr(self.mucous.dlang( line ))
					count += 1

			except Exception, e:
				pass

			
			tw.noutrefresh()
		except Exception, e:
			self.mucous.Help.Log("debug", "DrawStatusText: " + str(e))
					
	## Draw the contents of the user-box
	# A status asterix (*) followed by a username
	# @param self is ChatRooms (class)
	# @param user User's name
	# @param start Position to indicate highlight status
	def DrawBoxUsers(self, user, start):
		# RoomBox List Display
		try:
			w = self.dimensions["roombox"]
			mw = self.windows["border"]["roombox"]
			tw = self.windows["text"]["roombox"]
			if self.current == None or self.logs["roombox"][self.current] == []:
				tw.addstr("No one")
				return
			try:
				if user in self.mucous.user["status"]:
					if self.mucous.user["status"][user] == 1:
						tw.addstr('* ', self.mucous.colors["yellow"]|curses.A_BOLD)
					elif  self.mucous.user["status"][user] == 2:
						tw.addstr('* ', self.mucous.colors["green"]|curses.A_BOLD)
					elif self.mucous.user["status"][user] == 0:
						tw.addstr('* ', self.mucous.colors["red"]|curses.A_BOLD)
				else:
					tw.addstr('* ', curses.A_BOLD)
					
				if user in self.mucous.config["banned"].keys():
					if self.scrolling["roombox"] == self.logs["roombox"][self.current].index(user):
						attrib = curses.A_BOLD | curses.A_REVERSE | self.mucous.colors["red"]
					else: attrib = self.mucous.colors["red"]| curses.A_BOLD 
					
				elif user in self.mucous.config["ignored"].keys():
					if self.scrolling["roombox"] == self.logs["roombox"][self.current].index(user):
						attrib = curses.A_BOLD | curses.A_REVERSE | self.mucous.colors["yellow"]
					else: attrib = self.mucous.colors["yellow"]| curses.A_BOLD 
					
				elif user in self.mucous.config["trusted"].keys():
					if self.scrolling["roombox"] == self.logs["roombox"][self.current].index(user):
						attrib = curses.A_BOLD | curses.A_REVERSE | self.mucous.colors["cyan"]
					else:
						attrib = self.mucous.colors["cyan"] | curses.A_BOLD 
							
				elif user in self.mucous.config["buddies"].keys():
					if self.scrolling["roombox"] == self.logs["roombox"][self.current].index(user):
						attrib = curses.A_BOLD | curses.A_REVERSE | self.mucous.colors["green"]
					else:
						attrib = self.mucous.colors["green"]| curses.A_BOLD 
					
				else:
					if self.scrolling["roombox"] == self.logs["roombox"][self.current].index(user):
						attrib = curses.A_BOLD | curses.A_REVERSE 
					else:
						attrib = curses.A_NORMAL
				if len(user[:w["twidth"]-2]) < w["twidth"]-2:
					space = " " * ( w["twidth"]-2 - len(user[:w["twidth"]-2]))
				else: space =''
				tw.addstr(self.mucous.dlang(user[:w["twidth"]-2])+space, attrib)	
				
			except:
				pass
		except Exception, e:
			self.mucous.Help.Log("debug", "DrawBoxUsers " +str(e))	
			
	## Create the window and border of the user-box
	# @param self is ChatRooms (class)
	def DrawBox(self):
		# RoomBox Shape Display
		try:
			
			if self.mucous.mode != 'chat' or self.shape == "noroombox":
				return
			# Cleanup stale windows
			if "roombox" in self.windows["text"]:
				del self.windows["text"]["roombox"]
			if "roombox" in self.windows["border"]:
				del self.windows["border"]["roombox"]
			
			if self.shape in ("big", "nostatuslog", "widelist", "rightlist"):
				w = self.dimensions["chat"]
				if self.shape == "rightlist":
					s = self.dimensions["roombox"] = {"height": self.mucous.h-7, "top": 2, "left": (w["width"]), "width": self.mucous.w-w["width"], "start": -1 }
				else:
					s = self.dimensions["roombox"] = {"height": self.mucous.h-7, "top": 2, "left": 0, "width": self.mucous.w-w["width"], "start": -1 }
				# Create wi
				mw = self.windows["border"]["roombox"]  = curses.newwin(s["height"]+2, s["width"], s["top"]-1, s["left"])
				if self.selected == "roombox":
					mw.attron(self.mucous.colors["green"])

				mw.attroff(self.mucous.colors["green"])
				if self.shape == "rightlist":
					self.dimensions["roombox"]["twidth"] = s["width"]-1
					self.dimensions["roombox"]["tleft"] = s["left"]+1
				else:
					self.dimensions["roombox"]["twidth"] = s["width"]-1
					self.dimensions["roombox"]["tleft"] = s["left"]
				tw = self.windows["text"]["roombox"] = mw.subwin(s["height"], s["twidth"], s["top"], s["tleft"])
				
			elif self.shape == "small":
				s = self.dimensions["roombox"] = {"height": 4, "top": 2, "left": 0,  "width": 15}
				
				mw = self.windows["border"]["roombox"] = curses.newwin(s["height"]+2, s["width"], s["top"]-1, s["left"])
				if self.selected == "roombox":
					mw.attron(self.mucous.colors["green"])

				mw.attroff(self.mucous.colors["green"])
				self.dimensions["roombox"]["twidth"] = s["width"] -1
				tw = self.windows["text"]["roombox"] = mw.subwin(s["height"], s["twidth"], s["top"], s["left"])
				
			if self.shape in ("big", "small", "nostatuslog", "widelist", "rightlist"):
				tw.scrollok(0)
				tw.idlok(1)
			

				if self.current != None:
					try:
						if self.selected == "roombox":
							mw.addstr(0, 0, "Users: "+str(len(self.rooms[self.current])), self.mucous.colors["green"]|curses.A_BOLD)
						else:

							mw.addstr(0, 0, "Users: "+str(len(self.rooms[self.current])),  curses.A_BOLD)
						
					except:
						pass
					if "autojoin" in self.mucous.config:
						try:
							if self.selected == "roombox":
								cs  = self.mucous.colors["green"] |curses.A_BOLD
							else:
								cs  = curses.A_BOLD
							if self.current in self.mucous.config["autojoin"].keys():
								
								mw.addstr(self.dimensions["roombox"]["height"]+1, 0, "[x] AutoJoined",  cs)
							else:
								mw.addstr(self.dimensions["roombox"]["height"]+1, 0, "[ ] AutoJoined",  cs)
						except Exception, e:
							self.mucous.Help.Log("debug", "AutoJoined: " + str(e))
							
				mw.noutrefresh()
			
				if self.current != None:
					self.logs["roombox"][self.current] = []
					if len( self.rooms[self.current] ) > 0:
						self.logs["roombox"][self.current] = self.rooms[self.current]
						self.logs["roombox"][self.current].sort(key=str.lower)
				
					try:
						if self.logs["roombox"][self.current] != []:
							clipped_list, self.scrolling["roombox"], self.dimensions["roombox"]["start"] = self.mucous.FormatData.scrollbox(self.logs["roombox"][self.current], self.scrolling["roombox"], self.dimensions["roombox"]["height"])
							# Draw users
							self.FormatBox()
						else:
							tw.addstr("* Empty")
							tw.noutrefresh()
					except Exception, e:
						self.mucous.Help.Log("debug", "RSB: " + str(e))
			#curses.doupdate()
		except Exception, e:
			self.mucous.Help.Log("debug", "DrawBox " +str(e))
			
			
	## Start displaying tickets in one second
	# @param self is ChatRooms (class)
	def TickersStartTimer(self):
		try:
			if self.mucous.mode == "chat":

				if self.rooms.keys() != []:
					self.numticker = 0
					self.ticker_timer.cancel()
					self.ticker_timer = threading.Timer(1.0, self.DrawTicker)
					self.ticker_timer.start()
		except Exception, e:
			self.mucous.Help.Log("debug", "TickersStartTimer: " + str(e))
	## Toggle whether tickers are displayed or not 
	# @param self is ChatRooms (class)
	def ToggleTickersDisplay(self):
		try:
			if str(mucous_config["tickers"]["tickers_enabled"]) == 'no':
				mucous_config["tickers"]["tickers_enabled"] = 'yes'
				
			elif str(mucous_config["tickers"]["tickers_enabled"]) == 'yes':
				mucous_config["tickers"]["tickers_enabled"] = 'no'
			if self.mucous.mode=="setup":
				self.mucous.Setup.Mode()
		except Exception, e:
			self.mucous.Help.Log("debug", "ToggleTickersDisplay: "+str(e))
			
	## Toggle the way Tickers are displayed (Scrolling, Cycling) 
	# @param self is ChatRooms (class)
	def ToggleTickers(self):
		try:
			if mucous_config["tickers"]["ticker_cycle"] == 'no':
				mucous_config["tickers"]["ticker_cycle"] = 'yes'
				if str(mucous_config["tickers"]["ticker_scroll"]) == 'yes':
					mucous_config["tickers"]["ticker_scroll"] = 'no'
				
			elif mucous_config["tickers"]["ticker_cycle"] == 'yes':
				mucous_config["tickers"]["ticker_cycle"] = 'no'
				if str(mucous_config["tickers"]["ticker_scroll"]) == 'no':
					mucous_config["tickers"]["ticker_scroll"] = 'yes'
				
				
			#self.ticker_timer.cancel()
			if self.mucous.mode=="chat":
				self.DrawStatusWin()
				self.DrawStatusText()
				curses.doupdate()
			elif self.mucous.mode=="setup":
				self.mucous.Setup.Mode()
		except Exception, e:
			self.mucous.Help.Log("debug", "ToggleTickers: "+str(e))
			
	## Interator for Chat Room User List
	# Clears, and starts drawing from the scroll position
	def FormatBox(self):
		try:
			w = self.dimensions["roombox"]
			lol = self.logs["roombox"][self.current]
			mw = self.windows["border"]["roombox"]
			tw = self.windows["text"]["roombox"]
			tw.erase()
			clipped_list, self.scrolling["roombox"], self.dimensions["roombox"]["start"] = self.mucous.FormatData.scrollbox(lol, self.scrolling["roombox"], w["height"])
			for lines in clipped_list:
				self.DrawBoxUsers(lines, w["start"])
			tw.noutrefresh()
		except Exception, e:
			self.mucous.Help.Log("debug", "FormatBox: " + str(e))
			
	## Format Current Chat Room
	# @param self is ChatRooms (class)
	def FormatChatText(self):
		try:
			if self.current != None:
				w = self.dimensions["chat"]
				selected_log = self.logs["rooms"][self.current]
				lol = self.LineWrap(selected_log, w)
				
				if self.scrolling["chatroom"] == -1:
					self.scrolling["chatroom"] = len(lol)
	
				clipped_list, self.scrolling["chatroom"], self.dimensions["chat"]["start"] = self.mucous.FormatData.scrollbox(lol, self.scrolling["chatroom"], w["height"])
				
				self.windows["text"]["chat"].erase()
				for lines in clipped_list:
					self.DrawChatText(lines)
	
			self.DrawChatWin()
			self.windows["text"]["chat"].noutrefresh()
		except Exception, e:
			self.mucous.Help.Log("debug", "FormatChatText: " + str(e))
			
	## Insanely complex line wraping for chat messages
	# Needed for proper scrolling
	# @param self is ChatRooms (class)
	# @param the_list self.logs["rooms"][self.current]
	# @param w self.dimensions["chat"]
	# @return cut_list
	def LineWrap(self, the_list, w):
		# we wrap text here so that scrolling works properly... 
		try:
			pos = 0
			cut_list = []
			for mtype, timestamp, username, message in the_list:
				length = 0
				message = self.mucous.dlang(message)
				#mtype, timestamp, username, message = line[0], line[1], line[2], line[3]
				if mtype == "Me":
					#username = self.mucous.dlang(username)
					pre = " * %s " % username
					s = "%s" % message
					length += len(timestamp) + len(pre)
# 				elif mtype == "List":
# 					room = self.current
# 					pre = "Users in %s: "% room
# 					length +=  len(pre)
# 					for user, color in message:
# 						length += len(self.dlang(user))
				elif mtype in ("Mentioned", "Normal", "Status"):
					if username != "": # Universal Timestamp
						if mtype == "Status": # Mucous debugging message
							length += len(timestamp) + 2
						else: # Normal user chat
							length += len(timestamp) + 4
						
						#length += len(self.dlang(username))
						length += len(username)
		
				if "\n" in message:
					
					messagez = message.split('\n')
					# Wrap first line
					firstmsg = messagez[0]
					wit =  len(timestamp) + 4 + len(username)
					lm = len(firstmsg)
					mess = lm - ( (wit + lm ) - w["width"])
					cut_list.append( [ mtype, timestamp, username, firstmsg[:mess] ] )
					restmess = firstmsg[mess:]
					div = ( len(restmess)/w["width"] ) + 1
					spaces= (w["width"] * div) -  len(restmess)
					for seq in range(div):
						if mtype == "Me":
							cut_list.append(['cutme', '', '', restmess[:w["width"]] ])
						else:
							cut_list.append(['cut', '', '', restmess[:w["width"]] ])
						restmess = restmess[w["width"]:]

					# Prepend -- to all following lines
					m = []
					for messages in messagez[1:]:
						m.append("--"+messages)
					# Wrap each of the following lines
					for messages in m:
						lm = len(messages)
						restmess = messages
						div = ( len(restmess)/w["width"] ) + 1
						spaces= (w["width"] * div) -  len(restmess)
						for seq in range(div):
							if mtype == "Me":
								cut_list.append(['cutme', '', '', restmess[:w["width"]] ])
							else:
								cut_list.append(['cut', '', '', restmess[:w["width"]] ])
							restmess = restmess[w["width"]:]
					pos += 1
					continue	
							
					# Short message
				if length +len(message) <= w["width"]:
					cut_list.append([mtype, timestamp, username, message])
					
					# long message
				elif length +len(message) > w["width"]:
					lm = len(message)
					mess = lm - ( (length + lm ) - w["width"])
					cut_list.append( [ mtype, timestamp, username, message[:mess] ] )
					restmess = message[mess:]
					div = ( len(restmess)/w["width"] ) + 1
					spaces= (w["width"] * div) -  len(restmess)
					for seq in range(div):
						#self.mucous.Help.Log("debug", str(div)+"--" + restmess[:w["width"]] )
						if mtype == "Me":
							cut_list.append(['cutme', '', '', restmess[:w["width"]] ])
						else:
							cut_list.append(['cut', '', '', restmess[:w["width"]] ])
						restmess = restmess[w["width"]:]
 						
				pos += 1
			return cut_list
		except Exception, e:
			# Exceptions are Inevitable
			self.mucous.Help.Log("debug", "LineWrap: " + str(e))
			
	## Draw Chat Log Window Text
	# @param self is ChatRooms (class)
	# @param roomlinenumber number of line in chat room log
	def DrawChatText(self, roomlinenumber):
		try:
			room = self.current
			mtype, timestamp, username, message2 = roomlinenumber
			lang = mucous_config["mucous"]["language"]
			w = self.dimensions["chat"]
			room = self.mucous.dlang(room)
			length = 0
			tw = self.windows["text"]["chat"]
			message = ""
			for m in message2:
				message += curses.unctrl(m)
			try:
				if mtype == "Me":
					# /me message
					
					tw.addstr(timestamp)
					username = self.mucous.dlang(username)
					pre = " * %s " % username
					tw.addstr(pre, self.mucous.colors["green"] | curses.A_BOLD)
					s = "%s" % self.mucous.dlang(message)
					tw.addstr(s, self.mucous.colors["green"] | curses.A_BOLD)
					length += len(timestamp) + len(pre)+ len(s)
				elif mtype == "List":
					# List of users in Room
					
					pre = "Users in %s: "% room
					#self.textwin.addstr(pre)
					length +=  len(pre)
					for username, color in message:
						username = self.mucous.dlang(username)
						length += len(username)
						if color == "Me":
							tw.addstr(username, curses.A_BOLD)
						elif color == "Left":
							tw.addstr(username, self.mucous.colors["yellow"])
						elif color == "Banned":
							tw.addstr(username, self.mucous.colors["red"])
						elif color == "Buddies":
							tw.addstr(username, self.mucous.colors["green"])
						elif color == "NotLast":
							tw.addstr(username)
						elif color == "Normal":
							tw.addstr(username)
							
				elif mtype == "cut":
					s = self.mucous.dlang(message) 
					tw.addstr(s)
					length += len(s)
				elif mtype == "cutme":
					s = self.mucous.dlang(message) 
					tw.addstr(s, self.mucous.colors["green"] | curses.A_BOLD)
					length += len(s)
				else:
					if username != "":
						# Universal Timestamp
						tw.addstr(timestamp)
						if mtype == "Status":
							# Mucous debugging message
							pre = " "
							tw.addstr(pre)
							
						else:
							# Normal user chat
							pre = " ["
							tw.addstr(pre, curses.A_BOLD | self.mucous.colors["black"])
					length += len(timestamp) + len(pre)
					
					name = self.mucous.dlang(username)
					if username == self.mucous.username:
						tw.addstr(username ,  curses.A_BOLD )
					elif username not in self.rooms[room]:
						tw.addstr(name, self.mucous.colors["yellow"])
					elif username in self.mucous.config["banned"].keys():
						tw.addstr(name, self.mucous.colors["red"])
					elif username in self.mucous.config["buddies"].keys():
						tw.addstr(name, self.mucous.colors["green"])
					else:
						tw.addstr(name)
					length += len(name)
					
					if username != "":
						if mtype == "Status":
							suf = " "
							tw.addstr(" ")
						else:
							suf = "] "
							tw.addstr(suf, curses.A_BOLD | self.mucous.colors["black"])
					length += len(suf)
					if mtype == "Mentioned":
						x = message.split(" ")
						for e in x:
							e = self.mucous.dlang(e)
							
							if self.mucous.username not in e:
								tw.addstr(e)
								length += len(e)
							elif self.mucous.username in e:
								tw.addstr(e, self.mucous.colors["cyan"] | curses.A_BOLD)
								length += len(e)
							if e is not  x[-1]:
								if length < w["width"]:
									tw.addstr(" ")
									length +=  1
					elif mtype == "Normal":
						
						s = self.mucous.dlang(message) 
						tw.addstr(s)
						length += len(s)
					elif mtype == "Status":
						s = self.mucous.dlang(message) 
						tw.addstr(s)
						length += len(s)
				
	
			except Exception, e:
				pass
				# Exceptions are Inevitable
			try:
				if length < w["width"]:
					tw.addstr(" " * (w["width"] - length))
			except Exception, e:
				pass
		except Exception, e:
			self.mucous.Help.Log("debug", "DrawChatText: " + str(e))
			
	## Append message to Chat Log
	# @param self is ChatRooms (class)
	# @param mtype type of message
	# @param room room
	# @param user username
	# @param message text
	def AppendChat(self, mtype, room, user, message):
		try:
			if room == None:
				room = self.current
			full_message = [mtype, time.strftime("%H:%M:%S"), user, message]
			if len( self.logs["rooms"][room] ) >= 700:
				del self.logs["rooms"][room][0]
			oldlen = len(self.logs["rooms"][room])
			self.logs["rooms"][room].append(full_message)
				
			if self.mucous.mode == "chat":
				if room == self.current and self.selected == "chatroom":
					if self.scrolling["chatroom"] >= oldlen -1:
						self.scrolling["chatroom"] = -1
						self.FormatChatText()
				elif room == self.current and self.selected == "roombox":
					temp = self.scrolling["chatroom"]
					self.scrolling["chatroom"] = -1
					self.FormatChatText()
					self.scrolling["chatroom"] = temp
		except Exception,e :
			self.mucous.Help.Log("debug", "AppendChat: " + str(e))

	## Draw Chat Room Status Window Border 
	# @param self is ChatRooms (class)
	def DrawStatusWin(self):
		try:
			if self.shape in ("nostatuslog", "chat-only"):
				return
			w = self.dimensions["chat"]
			bw = self.windows["border"]["roomstatus"]
			
			if self.mucous.PopupMenu.show == True: raise  Exception,  "popup"
			
			if self.shape in ("noroombox", "big", "small", "rightlist", "widelist"):
				if self.selected == "roomstatus":
					bw.attron(self.mucous.colors["green"])
				else:
					bw.attroff(self.mucous.colors["green"])
				bw.border()
				bw.addstr(0, 3, "<")
				bw.addstr(0, 4, " Status Log ", self.mucous.colors["blue"] | curses.A_BOLD)
				bw.addstr(0, 16, ">")
				bw.noutrefresh()
		except:
			pass
				
	## Switch to another Chat Window Layout
	# @param self is ChatRooms (class)
	def ChatLayout(self):
		try:
# 			[ "small","big","widelist","rightlist","nostatuslog","chat-only","noroombox"]

			if self.shape == "noroombox":
				self.shape = "small"
				self.selected  = "roombox"
			elif self.shape == "small":
				self.shape = "big"
				self.selected  = "roombox"
			elif self.shape == "big":
				self.shape = "widelist"
				self.selected  = "roombox"
			elif self.shape == "widelist":
				self.shape = "rightlist"
				self.selected  = "roombox"
			elif self.shape == "rightlist":
				self.shape = "nostatuslog"
				self.selected  = "chatroom"
			elif self.shape == "nostatuslog":	
				self.shape = "chat-only"
				self.selected  = "chatroom"
			elif self.shape == "chat-only":
				self.shape = "noroombox"
				self.selected  = "chatroom"
				
			mucous_config["mucous"]["roombox"] = self.shape
			self.Mode()
		except Exception, e:
			self.mucous.Help.Log("debug", "ChatLayout: " + str(e))
			
	
	## Change Room (Reset scrolling)
	# @param self is ChatRooms (class)
	# @param r room name
	def Change(self, r):
		self.scrolling["chatroom"] = self.scrolling["roomstatus"] = -1
		self.scrolling["roombox"] = 0
		self.set_room(r)
		
	## Change Room
	# @param self is ChatRooms (class)
	# @param r room name
	def set_room(self, r):
		try:
			
			self.current = r
			self.mucous.Spl["title"]= r
			
			if self.mucous.mode != "chat":
				return
			
			# Change title in edit window
			if self.shape not in ("chat-only", "nostatuslog"):
				self.DrawStatusWin()
				self.DrawStatusText()
			self.mucous.set_edit_title(self.current)
			# Display Next-room hotspot's text
			try:
				# Encoding
				if self.current != None:
					if self.current in self.mucous.config["encoding.rooms"]:
						blah = self.mucous.config["encoding.rooms"][self.current]
					else:
						blah = self.mucous.config["encoding"]["network"]
					
					self.mucous.windows["inputborder"].addstr(0, self.mucous.w-17-len(blah)-4, "<" + (" " *( len(blah) +2) )+  ">")
					self.mucous.windows["inputborder"].addstr(0, self.mucous.w-17-len(blah)-2, blah, self.mucous.colors["cyan"] | curses.A_BOLD)
					# Previous, Next Buttons
					self.mucous.windows["inputborder"].addstr(0, self.mucous.w-17, "<      >")
					self.mucous.windows["inputborder"].addstr(0, self.mucous.w-15, "Prev", self.mucous.colors["cyan"] | curses.A_BOLD)
					self.mucous.windows["inputborder"].addstr(0, self.mucous.w-9, "<      >")
					self.mucous.windows["inputborder"].addstr(0, self.mucous.w-7,"Next", self.mucous.colors["cyan"] | curses.A_BOLD)
	
					# Clean screen
					self.mucous.windows["inputborder"].noutrefresh()
			except Exception, e:
				pass
			
			try:
				self.windows["input"].noutrefresh()
			except:
				pass
			self.DrawBox()
			
			# Display chat log
			if self.selected == "chatroom":
				self.windows["border"]["chat"].attron(self.mucous.colors["green"])
			else:
				self.windows["border"]["chat"].attroff(self.mucous.colors["green"])
			
			self.FormatChatText()
			
			# Clear Alert log
			if "%s" % self.current == self.mucous.Alerts.log:
				self.mucous.Alerts.setStatus("")
			
			self.TickersStartTimer()
			try:
				self.windows["text"]["chat"].noutrefresh()
			except:
				pass
			
			self.mucous.Alerts.Check()
		except Exception, e:
			self.mucous.Help.Log("debug", "set_room: " + str(e))
		
		
## Browse Shares
# Files and Directory viewer
class BrowseShares:
	## Constructor
	# @param self BrowseShares (class)
	# @param mucous Mucous (class)
	def __init__(self, mucous):
		## @var mucous 
		# Mucous (Class)
		self.mucous = mucous
		
		## @var dimensions
		# Window placement
		self.dimensions = {}
		## @var windows
		# Curses Window instances
		self.windows = {}
		## @var requests 
		# Users whose shares we've requested (Discard other requests)
		self.requests = []
		## @var current
		# Currently shown user's shares
		self.current = None
		## @var current_dir
		# Current Directory
		self.current_dir = None
		## @var users 
		# Users whose info we have
		self.users = []
		## @var logs
		# dict containing descriptions and stats of users
		self.logs = {}
		## @var help
		# Instructions
		self.help = self.mucous.Help.log["browse"]
		## @var files 
		# Current user's files in current directory
		self.files = []
		## @var dirs 
		# Current user's directories
		self.dirs = []
		## @var scrolling
		# dict containing vertical scroll position for files, directories
		self.scrolling = {"files": 0, "directories": 0}
		## @var selected
		# Selected window
		self.selected = "directories"
		## @var results
		# dict of users with dict of shares
		self.results = {}
		## @var collapsed 
		# dict of users with list of collapsed directories
		self.collapsed = {}
		## @var browse_num
		# dict of numbers related to the current files in the current directory 
		self.browse_num = {}
		## @var bfilter
		# Filter string for files
		self.bfilter = None
		
	## Get the currently selected user and file
	# @param self BrowseShares (class)
	# @return user, path
	def CurrentFile(self):
		user = self.current
		path = self.current_dir+"\\"+self.files[self.scrolling["files"]]
		return user, path
	
	## Get the currently selected user and directory
	# @param self BrowseShares (class)
	# @return user, directory
	def CurrentDir(self):
		if self.selected == "files":
			w = self.dimensions["browse"]
			directory = self.current_dir
			user = self.current
			
		elif self.selected == "directories":
			w = self.dimensions["directories"]
			directory = self.current_dir
			user = self.current
		return user, directory
		
	## Get the user and path from file number
	# @param self BrowseShares (class)
	# @param number number of file
	# @return user, path
	def GetDownloadFromNum(self, number):
		try:

			number = int(number)
			user = self.current
			path = self.current_dir+"\\"+self.files[number]
			return user, path
				
		except Exception, e:
			self.mucous.Help.Log("debug", "download_path_file: " + str(e))
			
	## Create windows and Call draw functions
	# @param self BrowseShares (class)
	def Mode(self):
		try:
			self.mucous.mode = "browse"
			self.mucous.PopupMenu.show = False

			# Cleanup stale windows
			if "text" in self.windows:
				del self.windows["text"]
			if "border" in self.windows: 
				del self.windows["border"]
			if "dirwin" in self.windows:
				del self.windows["dirwin"]
			if "dirborder" in self.windows:
				del self.windows["dirborder"]
			if "browsebar" in self.windows:
				del self.windows["browsebar"]
			
			w = self.dimensions["browse"] = {"height": self.mucous.h-11, "width": self.mucous.w-mucous_config["mucous"]["browse_width"], "top": 5, "left": mucous_config["mucous"]["browse_width"]-1, "start": 0}
			# Files Border	
			wbb = self.windows["border"] = curses.newwin(w["height"]+2, w["width"]+2, w["top"]-1, w["left"]-1)
			# Directories Border
			self.windows["dirborder"] = curses.newwin(w["height"]+2, self.mucous.w-w["width"]-2, w["top"]-1, 0)
			self.DrawBrowseWin()
			# Files Text
			tbb = self.windows["text"] = wbb.subwin(w["height"], w["width"], w["top"], w["left"])
			tbb.scrollok(0)
			tbb.idlok(1)
			tbb.noutrefresh()

			d = self.dimensions["directories"] = {"height": w["height"], "width": self.mucous.w-w["width"]-4, "top": w["top"], "left":1}
			# Directories Text
			dw = self.windows["dirwin"] = self.windows["dirborder"].subwin(d["height"], d["width"], d["top"], d["left"])
			dw.erase()
			dw.noutrefresh()
	
# 			self.scrolling["files"] = self.scrolling["directories"] = 0
			# Vars

			self.files = []
			self.dirs = []
			
			self.windows["browsebar"] = curses.newwin(1, self.mucous.w, w["top"]+w["height"]+1, 0)
			self.windows["browsebar"].erase()
			self.windows["browsebar"].noutrefresh()
			
			self.mucous.Alerts.Check()
			self.mucous.HotKeyBar()
			self.FormatBrowse()
			curses.doupdate()
			del w
		except Exception, e:
			self.mucous.Help.Log("debug", "BrowseShares.Mode: " + str(e))
			
	## Recieved shares
	# @param self BrowseShares (class)
	# @param user Username
	# @param shares Shares dict
	def Recieved(self, user, shares):
		try:
			if user not in self.requests:
				return
			self.requests.remove(user)
			if user not in self.users:
				self.users.append(user)
			
			self.current = user
			if self.mucous.mode != "browse":
				self.mucous.Alerts.alert["BROWSE"].append(self.current)
				self.mucous.Alerts.Check()

			self.results[user] = {}
			self.collapsed[user] = []
			#self.num[user] = 0
			self.results[user]["dirs"] = []
			# Debugging
			#self.mucous.Help.Log("debug", shares.keys())
			#########
			if shares != {}:
				sdirs = shares.keys()
				sdirs.sort(key=str.lower)
			
				if sdirs != []:
					for item in sdirs:
						s = item.split("\\")
						path = ''
	
						parent = s[0]
						for seq in s[1:]:

							parent += "\\"
	
							path = parent+seq

			
							if path not in self.results[user]["dirs"]:
								self.results[user]["dirs"].append(path)
							parent =  path
								
				self.results[user]["dirs"].sort(key=str.lower)
			else:
				self.results[user]["dirs"].append("Empty Shares")
				
			self.current_dir = self.results[user]["dirs"][0]
			
			self.results[user]["shares"] = shares
			
			for dirs, files in shares.items():
				self.results[user][dirs] = files
				#result_list = []
				
			if self.mucous.mode == "browse":
				self.mucous.set_edit_title("Browse "+user+"'s files in " + self.current_dir + " ")
				self.Mode()
		except Exception, e:
			self.mucous.Help.Log("debug", "BrowseShares.Recieved: " + str(e))
			
	## Draw Browse Window Border
	# @param self BrowseShares (class)
	def DrawBrowseWin(self):
		try:
			w = self.dimensions["browse"]
			mw = self.windows["border"]
			if self.mucous.BrowseShares.selected == "files":
				mw.attron(self.mucous.colors["green"])
			else:
				mw.attroff(self.mucous.colors["green"])
			mw.border()
	
			try:
				if self.mucous.BrowseShares.selected == "files":
					attr = self.mucous.colors["green"] | curses.A_BOLD
				else:
					attr = curses.A_BOLD
				if self.current == None:
					mw.addstr(0, 3, "< Browse users >",  attr)
				else:
					mw.addstr(0, 1, "<Num",  attr)
					mw.addch(curses.ACS_VLINE, attr)
					mw.addstr(" Size  ",  attr)
					mw.addch(curses.ACS_VLINE, attr)
					mw.addstr(" Filename >",  attr)
			except:
				pass
			mw.noutrefresh()
			
			self.windows["dirborder"].erase()
			if self.mucous.BrowseShares.selected == "directories":
				self.windows["dirborder"].attron(self.mucous.colors["green"])
				attr = self.mucous.colors["green"] | curses.A_BOLD
			else:
				attr = curses.A_BOLD
			self.windows["dirborder"].border()
			self.windows["dirborder"].attroff(self.mucous.colors["green"] )
			self.windows["dirborder"].addstr(0, 1, "< Directories >",  attr)
			self.windows["dirborder"].addstr(w["height"]+1, 1, "< Width - %s + >"  % mucous_config["mucous"]["browse_width"],  attr)
			self.windows["dirborder"].noutrefresh()

			if self.current == None:
				self.scrolling["directories"] = 0
				self.mucous.set_edit_title("Choose a user to Browse Shares")
				self.mucous.DrawInstructionsButtons()
			else:
				self.mucous.DrawInstructionsButtons()
				#s = "Browse "+self.current+"'s files in "
				#ls = len(s)
				#self.mucous.set_edit_title( self.current_dir[:self.mucous.w-8] )
		except Exception, e:
			self.mucous.Help.Log("debug", "BrowseShares.DrawBrowseWin: " + str(e))
			
	## Parse Directories and display extremely formatted list
	# expensive (HIGH CPU Usage) 
	# @param self BrowseShares (class)
	def FormatBrowseDirs(self):
		try: 
			d = self.dimensions["directories"]
			w = self.dimensions["browse"] 
			tw = self.windows["text"]
			
			if self.current == None:
                                # Clear windows, display browse help
				self.windows["dirwin"].erase()
				self.windows["dirwin"].noutrefresh()
				tw.erase()
				count = 0
				
				for lines in self.help:

					try:
						self.DrawBrowseFileText(lines, count , self.scrolling["files"])
		
					except Exception, e:
						self.mucous.Help.Log("debug", "Browse mode" + str(e))
				tw.noutrefresh()
				return
                        # If the default help isn't displayed
						
			tempdirs = self.results[self.current]["dirs"]
			#tempdirs.sort(key=str.lower)
			# List, Directory, Scroll position
			collapsed = self.collapsed[self.current]
			num = 0
			dirswithtree = []
			self.dirs = []
			parents = []
			for directory in tempdirs:
				parent = "\\".join(directory.split("\\")[:-1])
				if parent in tempdirs and parent not in parents:
					parents.append(parent)

			for directory in tempdirs:
				try:
					parent = "\\".join(directory.split("\\")[:-1]) 
					a = 0
					for dirs in collapsed:
						if parent.startswith(dirs+"\\") or parent == dirs:
							a = 1
							break
					if a == 1:
						num += 1
						continue
					if directory in parents:
						if directory in collapsed:
							dirswithtree.append([directory, 2])
							self.dirs.append(directory)
						else:
							for dir in collapsed:
								if dir in directory:
									pass
							else:
								dirswithtree.append([directory, 1])
								self.dirs.append(directory)
					else:
						for dir in collapsed:
							if dir in directory:
								pass
						else:
							dirswithtree.append([directory, 0])
							self.dirs.append(directory)
				except Exception, e:
					for dir in collapsed:
						if dir in directory:
							pass
					else:
						dirswithtree.append([directory, 0])
						self.dirs.append(directory)
				num += 1 
			
			if self.mucous.BrowseShares.selected == "directories":
				clipped_list, self.scrolling["directories"], start = self.mucous.FormatData.scrollbox(dirswithtree, self.scrolling["directories"], d["height"])
			else:
				clipped_list, self.scrolling["directories"], start = self.mucous.FormatData.scrollbox(dirswithtree, self.scrolling["directories"], d["height"])
			#self.mucous.Help.Log("debug", self.scrolling["directories"])
			self.dimensions["directories"]["start"] = start
			count = 0
			self.windows["dirwin"].erase()
			# Display directory tree
			for s, has_child in clipped_list:
				try:
					dir = s.split("\\")
					if has_child == 1:
						modifier = "[-]"
					elif has_child == 2:
						modifier = "[+]"
					else: 
						modifier = "|\\"
					# Spaces before directory, to make it look like a tree
					string = (" " * (len(dir)-2)) + modifier
					string += self.mucous.dlang(dir[-1][:d["width"]-len(string)])
					string += " " * ( d["width"] -len(string) )
					if count +d["start"] == self.scrolling["directories"]:
						self.windows["dirwin"].addstr(string, self.mucous.colors["green"])
					else:
						self.windows["dirwin"].addstr(string)
					count += 1
				except Exception, e:
					pass
					#self.mucous.Help.Log("debug", str(e))
			del clipped_list
			
			
		except Exception, e:
			self.mucous.Help.Log("debug", "BrowseShares.FormatBrowseDirs: " + str(e))
			
	## Format Files and Directories (with calls to functions)
	# @param self BrowseShares (class)
	# @param FormatDirs Format and Draw Dirs (True/False)
	def FormatBrowse(self, FormatDirs=True):
		try:
			if "directories" not in self.dimensions:
				return
			if FormatDirs:
				self.FormatBrowseDirs()
			if self.current != None:
				self.current_dir = self.dirs[self.scrolling["directories"]]
				self.mucous.set_edit_title(self.current_dir )
			
				self.DrawFiles( self.current, self.current_dir)
			
				self.FileBar( self.current, self.current_dir)
			
			self.windows["dirwin"].noutrefresh()
		
			
			
			self.mucous.DrawTabs(self.users, self.current)

			
		except Exception, e:
			self.mucous.Help.Log("debug", "BrowseShares.FormatBrowse: " + str(e))
			


	## Send a request to museekd to browse this user
	# @param self BrowseShares (class)
	# @param user Username
	def Get(self, user):
		try:
			if user not in self.requests:
				self.requests.append(user)
			self.mucous.SendMessage(messages.UserShares(user))
		except Exception, e:
			self.mucous.Help.Log("debug", "BrowseShares.Get" + str(e))

	## Draw file's number, name and size
	# @param self BrowseShares (class)
	# @param line line from list
	# @param count line position in list
	# @param sup scroll position
	def DrawBrowseFileText(self,  line, count, sup):
		try:
			w = self.dimensions["browse"]
			tw = self.windows["text"]
			this_line = self.mucous.dlang( line )
			if len(this_line) > self.dimensions["browse"]["width"]:
				crop = len(this_line) - self.dimensions["browse"]["width"]
				this_line = this_line[:-crop]
				
			if count + w["start"] == sup:
				attr = self.mucous.colors["blafgcyabg"] |curses.A_REVERSE|curses.A_BOLD	
				nattr = self.mucous.colors["cyan"] |curses.A_REVERSE|curses.A_BOLD
			else:
				attr = curses.A_NORMAL
				nattr = self.mucous.colors["cyan"] 
			if self.current == None:
				tw.addstr(this_line, attr )
			else:
				tw.addstr(this_line[:4], attr )
				tw.addch(curses.ACS_VLINE, attr)
				tw.addstr(this_line[5:12], nattr )
				tw.addch(curses.ACS_VLINE, attr)
				tw.addstr(this_line[13:], attr )
			z = w["width"]-len(this_line)
			space = " " * ( z )
			tw.addstr(space, attr)
			
		except Exception, e:
			#self.mucous.Help.Log("debug", "BrowseShares.BrowseFileText: " + str(e))
			pass
	
	## Draw files in a user's directory
	# @param self BrowseShares (class)
	# @param user Username
	# @param directory Directory of file list
	def DrawFiles(self, user, directory):
		try:
			if self.mucous.mode != "browse":
				self.mucous.Alerts.alert["BROWSE"].append(user)
				self.mucous.Alerts.setStatus("Browse: %s" % user)
				return
			
			tw = self.windows["text"]
			w = self.dimensions["browse"]
			self.browse_num[user] = 0
			browse_list = []
			count =0 
			# file, stats[ size, ftype, [bitrate, length ] ]
			
			if directory not in self.results[user]["shares"] or self.results[user]["dirs"] == {}:
				tw.erase()
				tw.addstr("Empty..")
				tw.refresh()
				self.files =  []
				return
			
			length_list = len(str(len(self.results[user][directory].keys() ) ) )
			list1 = self.results[user][directory].keys()
			list1.sort(key=str.lower)

			for file in list1:
				stats = self.results[user][directory][file]
				count += 1
				
				self.browse_num[user] = self.browse_num[user] +1
				size = str(self.mucous.FormatData.Humanize(stats[0]))
				if len(size) < 6:
					size = ' '* (6-len(size)) + size
				ftype =stats[1]
				
				if ftype.upper() in ('OGG', 'MP3') and stats[2] != []:
					bitrate =str(stats[2][0])
					if bitrate == '':
						bitrate = '0'	
					length =str(stats[2][1])
					if length != '' and length != None:
						minutes = int(length)/60
						seconds = str( int(length) - (60 * minutes))
						if len(seconds) < 2:
							seconds = '0' + seconds
						length = str(minutes)+":"+str(seconds)
					else:
						length = "0:00"
						bitrate = '0'
				else:
					ftype = "None"
					length = "0:00"
					bitrate = '0'
					
				filename = directory + "\\" + file
				#result_list = user, filename
				# Activate Number for Result
				if len(str(count)) < 4:
					s = " " * (4 - len(str(count)))
				else:
					s = ''
				
				size = " " * (7 - len(str(size))) + size[:7]
				line = "%s%s|%s|%s" % ( s, str(count), size, file )
				browse_list.append(line)
				
			self.files = list1
				
			if self.bfilter != None:
				a = []
				for path in browse_list:
					if re.match( self.bfilter, path):
						a.append(path)
				browse_list = a
				del a
					
			clipped_list, self.scrolling["files"], self.dimensions["browse"]["start"] = self.mucous.FormatData.scrollbox(browse_list, self.scrolling["files"], w["height"])
			sup = self.scrolling["files"]
				
			

			count = 0
			tw.erase()
			for line in clipped_list:
				self.DrawBrowseFileText(line, count, sup)
				count += 1
			tw.refresh()
			
		except Exception, e:
			self.mucous.Help.Log("debug", "BrowseShares.DrawFiles: " + str(e))
			
	## Draw File's stats in FileBar
	# @param self BrowseShares (class)
	# @param user Username
	# @param directory Directory of file list
	def FileBar(self, user, directory):
		try:
			self.windows["browsebar"].erase()
			num = self.scrolling["files"]

			if directory not in self.results[user]["shares"]:
				self.windows["browsebar"].refresh()
				return
			if self.results[user]["shares"][directory].keys() != []:
                                list1 = self.results[user]["shares"][directory].keys()
			        list1.sort(key=str.lower)
                                file = list1[num]
                                stats = self.results[user]["shares"][directory][file] 
			else: 
				self.windows["browsebar"].refresh()
				return
	

			size  = self.mucous.FormatData.Humanize(stats[0])
			
			ftype =stats[1]
			if ftype == '':
				ftype = "None"
				length = "0:00"
				bitrate = '0'
			else:
				bitrate =str(stats[2][0])
				if bitrate == '':
					bitrate = '0'	
				length =str(stats[2][1])
				if length != '' and length != None:
					minutes = int(length)/60
					seconds = str( int(length) - (60 * minutes))
					if len(seconds) < 2:
						seconds = '0' + seconds
					length = str(minutes)+":"+str(seconds)
				else:
					length = "0:00"
			
                        #l=len('['+str(num+1)+'] '+" Size: " + str(size)+" Length: " + length + " Bitrate: " + bitrate)
                        atr = self.mucous.colors["cyan"] | curses.A_BOLD

			self.windows["browsebar"].addstr("[")
                        self.windows["browsebar"].addstr(str(num+1), atr )
                        self.windows["browsebar"].addstr("] | Size: ")
                        self.windows["browsebar"].addstr(str(size), atr)
                        self.windows["browsebar"].addstr(" | ")
                        self.windows["browsebar"].addstr(bitrate, atr)
                        self.windows["browsebar"].addstr("Kbps | Length: ")
                        self.windows["browsebar"].addstr(length, atr)
			self.windows["browsebar"].refresh()
		except Exception, e:
			self.mucous.Help.Log("debug", "BrowseShares.FileBar: " + str(e))
			
	## Change Directory to line
	# @param self BrowseShares (class)
	# @param line string that should contain a valid path 
	def ChangeDir(self, line):
		try:
			if self.current_dir == '' or line[0:1] == '\\' or line[1:2] == ":":
				if self.current in self.results.keys():
					if line[0:1] == '\\':
						if line in self.results[self.current].keys():
							self.current_dir = line
						else:
							self.mucous.Help.Log("status", "No such directory: %s user:" % (line[1:],  self.current))
					if line[1:2] == ":":
						if line in self.results[self.current].keys():
							self.current_dir = line
						else:
							self.mucous.Help.Log("status", "No such directory: %s user:" % (line,  self.current))
					else:
						if line in self.results[self.current].keys():
							self.current_dir = line
						else:
							self.mucous.Help.Log("status", "No such directory: %s user:" % (line,  self.current))
				
			elif line =='..':
				z = self.ParentDir()
				if z != 0:
					self.current_dir = z
				else:
					self.mucous.Help.Log("status", "No parent directory, User: " +  self.current)
			else:
				if self.current_dir + '\\'+line in self.results[self.current].keys():
					self.current_dir += '\\'+line
				else:
					self.mucous.Help.Log("status", "No such directory: %sUser: " % (line, self.current) )
					
			if self.current == None:
				self.mucous.set_edit_title("Choose a user to Browse Shares")
			else:
				s = "Browse "+self.current+"'s files in "
				ls = len(s)
				self.mucous.set_edit_title(s  + self.current_dir[:self.mucous.w-ls-4] + " ")
		except Exception, e:
			self.mucous.Help.Log("debug", "BrowseShares.ChangeDir: " + str(e))
			
	## Get Parent directory of current_dir
	# @param self BrowseShares (class)
	# @return directory
	def ParentDir(self):
		try:
			splitit = self.current_dir
			splitit = splitit.split("\\")
			s = len(splitit)
			directory=''
			for r in range(s-1):
				if r == 0:
					directory += splitit[r]
				else:
					directory += "\\"+splitit[r]
					
			if directoryz in self.results[self.current]["shares"].keys():
				return directory
			else:
				return None
		except Exception, e:
			self.mucous.Help.Log("debug", "BrowseShares.ParentDir: " + str(e))
	## Close Tab of user
	# @param self BrowseShares (class)
	# @param user Username whose shared are being closed
	def Close(self, user):
		try:
			if user in self.users:
				self.users.remove(user)
				self.scrolling["directories"] = 0
			if user in self.logs:
				del self.logs[user]
			if user in self.results:
				del self.results[user]
			if self.users != []:
				if self.current == user:
					self.current = self.users[0]
			else:
				self.current = None
			if user in self.mucous.Alerts.alert["BROWSE"] and user != "__default":
				self.mucous.Alerts.alert["BROWSE"].remove(user)
			self.Mode()
		except Exception, e:
			self.mucous.Help.Log("debug", "BrowseShares.Close: " + str(e))
	
	## Mouse Coordinates in the Browse Shares Mode
	# @param self is BrowseShares (class)
	# @param x is the horizontal position from the left
	# @param y is the vertical postion from the top
	# @param z is unimportant
	# @param event is the mouse event (button, doubleclick, etc) represented by a number
	def MouseBrowse(self, x,y,z,event):
		try:
			d = self.dimensions["directories"]
			w = self.dimensions["browse"]
			if y in (1, 2, 3):
				if len(self.users) == 1 and self.current == None:
					self.current = self.users[0]
					self.Mode()
				if len(self.users) > 1:	
					if self.current == None:
						self.current = self.users[0]
					else:
						self.current, match = self.mucous.MouseClickTab(x, self.current)
						if match == None:
							s = self.users.index(self.current)
							self.current = self.users[s-1]
						sdirs =  self.results[self.current].keys()
						sdirs.sort(key=str.lower)
						self.current_dir=sdirs[0]
					
					self.Mode()
			elif y == w["top"] + w["height"]:
				if x < mucous_config["mucous"]["browse_width"]:
					if x in (7,8,9,10):
						if mucous_config["mucous"]["browse_width"] > 20: 
							mucous_config["mucous"]["browse_width"] -= 1
							self.Mode()
					elif x in (12,13,14,15,16,17):
						if mucous_config["mucous"]["browse_width"] < self.mucous.w-20:
							mucous_config["mucous"]["browse_width"] += 1
							self.Mode()
					
			elif y == w["top"]-1:
			
				if x >= self.mucous.w-17 and self.current != None:
					self.current = None
					self.Mode()
			elif x in range(d["width"]) and y >= d["top"] and y <= d["top"] + d["height"]:
				if self.current == None:
					return
				if self.mucous.BrowseShares.selected != "directories":
					self.mucous.BrowseShares.selected = "directories"
					self.mucous.BrowseShares.DrawBrowseWin()
					
				self.scrolling["directories"] = y - d["top"] + d["start"]
				self.FormatBrowse()
				
				if event in ( 4096, 16384):
					self.mucous.ChatRooms.DrawBox()
					self.mucous.PopupMenu.Create("browse-dirs", 0, True)
				else:
					self.mucous.ChatRooms.DrawBox()
				curses.doupdate()
				
			elif x >=  w["left"] and y >= w["top"] and y <= w["top"] + w["height"]:
				if self.current == None:
					return
				if self.mucous.BrowseShares.selected != "files":
					self.mucous.BrowseShares.selected = "files"
					self.mucous.BrowseShares.DrawBrowseWin()
				self.scrolling["files"] = y - w["top"]+ w["start"]
				self.FormatBrowse()
				
				if event in ( 4096, 16384):
					#self.mucous.DrawBox()
					self.mucous.PopupMenu.Create("browse-files", 0, True)
				#else:
					#self.ChatRooms.DrawBox()
				curses.doupdate()
				
			elif y in ( self.mucous.h-5, self.mucous.h-6):
				if x>= self.mucous.w-27 and x < self.mucous.w-18:
					self.mucous.PopupMenu.Create("encoding", 0, True)
					return
				elif x >=self.mucous.w-10 and x < self.mucous.w-1 and self.current != None:
					self.Close(self.current)
		except Exception, e:
			self.mucous.Help.Log("debug", "BrowseShares.MouseBrowse: " +str(e) )

			
			
## Users Lists
#			
class UsersLists:
	## Constructor
	# @param self UsersLists (class)
	# @param mucous Mucous (class)
	def __init__(self, mucous):
		## @var mucous 
		# Mucous (Class)
		self.mucous = mucous
		## @var logs
		# holds temporary data, until the next Mucous.config update
		self.logs = {"buddied": [], "banned": [], "ignored": [], "trusted": []}
		## @var scrolling
		# dict containing scroll position for buddied, banned, ignored ad trusted lists 
		self.scrolling = {"buddied": 0, "banned": 0, "ignored": 0, "trusted": 0}
		## @var current
		# default list is buddied
		self.current = "buddied"
		## @var windows
		# dict containing curses window instances
		self.windows = {"text":{}, "border":{} }
		## @var dimensions
		# dict containing placement data for windows
		self.dimensions = {}
		
	## Pick List to display
	# @param self UsersLists (class)	
	def ModeLists(self):
		self.mucous.mode = "lists"
		self.mucous.PopupMenu.show = False
		if self.current == "buddied":
			self.ModeBuddy()
		elif self.current == "banned":
			self.ModeBan()
		elif self.current == "ignored":
			self.ModeIgnore()
		elif self.current == "trusted":
			self.ModeTrust()	
		elif self.current == "interests":
			self.mucous.Recommendations.ModeInterests()
				
	## Display Trusted users list
	# @param self UsersLists (class)	
	def ModeTrust(self):
		try:
			self.current = "trusted"
			#self.DestroyOldWindows()
			self.mucous.PopupMenu.show = False
			
			s = self.dimensions[self.current] = {"height": self.mucous.h-7, "top": 2, "left": 1, "width": self.mucous.w-2, "start": 0}
			self.ListTrust()
			self.DrawListsWindows()
			
			self.FormatLists(s, "trusted")
			
			self.mucous.HotKeyBar()
			curses.doupdate()
		except Exception, e:
			self.mucous.Help.Log("debug", "ModeTrust: " + str(e))
			
	## Display Buddied users list
	# @param self UsersLists (class)
	def ModeBuddy(self):
		try:
			self.current = "buddied"
			self.mucous.PopupMenu.show = False
			
			s = self.dimensions[self.current] = {"height": self.mucous.h-7, "top": 2, "left": 1, "width": self.mucous.w-2, "start": 0}
			self.ListBuddy()
			self.DrawListsWindows()
			
			self.FormatLists(s, "buddied")
			
			self.mucous.HotKeyBar()
			curses.doupdate()
		except Exception, e:
			self.mucous.Help.Log("debug", "ModeBuddy: " + str(e))
	
	## Display Banned users list
	# @param self UsersLists (class)
	def ModeBan(self):
		try:
			self.current = "banned"
			self.mucous.PopupMenu.show = False
			
			s = self.dimensions[self.current] = {"height": self.mucous.h-7, "top": 2, "left": 1, "width": self.mucous.w-2, "start": 0}
			self.DrawListsWindows()
			self.ListBan()
			self.FormatLists(s, "banned")
			self.mucous.HotKeyBar()
			curses.doupdate()
		except Exception, e:
			self.mucous.Help.Log("debug", "ban_mode: " + str(e))
	
	## Display Ignored users list
	# @param self UsersLists (class)
	def ModeIgnore(self):
		try:
			self.current = "ignored"
			self.mucous.PopupMenu.show = False
			
			s = self.dimensions[self.current] = {"height": self.mucous.h-7, "top": 2, "left": 1, "width": self.mucous.w-2, "start": 0}
			self.DrawListsWindows()
			
			self.FormatLists(s, "ignored")
			self.mucous.HotKeyBar()
			curses.doupdate()
		except Exception, e:
			self.mucous.Help.Log("debug", "ModeIgnore: " + str(e))
	
	## Format lists to fit inside window dimensions
	# @param self UsersLists (class)
	# @param window Window dimensions dict
	# @param mode list name
	def FormatLists(self, window, mode):
		try:
			if self.logs[mode] != None and self.logs[mode] != []:
				clipped_list, self.scrolling[mode], self.dimensions[self.current]["start"] = self.mucous.FormatData.scrollbox(self.logs[mode], self.scrolling[mode], window["height"])
				count = 0 
				try:
					self.windows["border"][self.current].addstr(self.mucous.h-6, self.mucous.w-18, "< "+str(len(self.logs[mode]))+" >", self.mucous.colors["green"] | curses.A_BOLD)
					self.windows["border"][self.current].noutrefresh()	
				except:
					pass
				self.windows["text"][self.current].erase()
				for lines in clipped_list:
					self.DrawLists(lines, count, self.current)
					count += 1
				
				self.windows["text"][self.current].noutrefresh()
		except Exception, e:
			self.mucous.Help.Log("debug", "FormatLists: " + str(e))
			
	## Draw List Window borders
	# @param self UsersLists (class)
	def DrawListsWindows(self):
		try:
			# Cleanup stale windows
			if self.current in self.windows["text"]: 
				del self.windows["text"][self.current]
			if self.current in self.windows["border"]:
				del self.windows["border"][self.current]
				
			s = self.dimensions[self.current]
			mw = self.windows["border"][self.current] = curses.newwin(s["height"]+2, s["width"]+2, s["top"]-1, s["left"]-1)
			mw.attron(self.mucous.colors["green"])
			mw.border()
			mw.attroff(self.mucous.colors["green"])

			if self.current =="buddied":
				mw.addstr(0, 3, "< Buddied >",  self.mucous.colors["green"] | curses.A_BOLD)
				mw.addstr(0, 16, "< Banned >", self.mucous.colors["green"])
				mw.addstr(0, 28, "< Ignored >", self.mucous.colors["green"])
				mw.addstr(0, 40, "< Trusted >", self.mucous.colors["green"])
				mw.addstr(0, 52, "< Interests >", self.mucous.colors["green"])
				
				self.mucous.set_edit_title("Add Buddy:")
			elif self.current =="banned":
				mw.addstr(0, 3, "< Buddied >",  self.mucous.colors["green"] )
				mw.addstr(0, 16, "< Banned >", self.mucous.colors["green"]| curses.A_BOLD)
				mw.addstr(0, 28, "< Ignored >", self.mucous.colors["green"])
				mw.addstr(0, 40, "< Trusted >", self.mucous.colors["green"])
				mw.addstr(0, 52, "< Interests >", self.mucous.colors["green"])
				self.mucous.set_edit_title("Ban User:")
			elif self.current =="ignored":
				mw.addstr(0, 3, "< Buddied >",  self.mucous.colors["green"] )
				mw.addstr(0, 16, "< Banned >", self.mucous.colors["green"])
				mw.addstr(0, 28, "< Ignored >", self.mucous.colors["green"]| curses.A_BOLD)
				mw.addstr(0, 40, "< Trusted >", self.mucous.colors["green"])
				mw.addstr(0, 52, "< Interests >", self.mucous.colors["green"])
				self.mucous.set_edit_title("Ignore User:")
			elif self.current =="trusted":
				mw.addstr(0, 3, "< Buddied >",  self.mucous.colors["green"] )
				mw.addstr(0, 16, "< Banned >", self.mucous.colors["green"])
				mw.addstr(0, 28, "< Ignored >", self.mucous.colors["green"])
				mw.addstr(0, 40, "< Trusted >", self.mucous.colors["green"] | curses.A_BOLD)
				mw.addstr(0, 52, "< Interests >", self.mucous.colors["green"])
				self.mucous.set_edit_title("Add Trusted:")
		
			mw.noutrefresh()
			tw = self.windows["text"][self.current] = mw.subwin(s["height"], s["width"], s["top"], s["left"])
			tw.scrollok(0)
			tw.idlok(1)
		except Exception, e:
			self.mucous.Help.Log("debug", "DrawLists: " + str(e))
	
	## Draw List Contents
	# @param self UsersLists (class)
	# @param line list of [attributes, username, note]
	# @param count number in list (Add to window["start"] to get the current line)
	# @param window window name (buddied, banned, ignored, trusted)
	def DrawLists(self, line, count, window):
		try:
			start = self.dimensions[window]["start"]
			tw = self.windows["text"][self.current]
			# attributes can contain ['trusted', 'banned', 'ignored', and 'buddied']
			attributes, username, note = line
		
			tabbeduser = self.mucous.dlang(username[:20])

			while len(tabbeduser) < 24:
				tabbeduser += ' '
			try:
				if username in self.mucous.user["status"].keys():
					if self.mucous.user["status"][username] == 1:
						tw.addstr('* ', self.mucous.colors["yellow"]|curses.A_BOLD)
					elif self.mucous.user["status"][username] == 2:
						tw.addstr('* ', self.mucous.colors["green"]|curses.A_BOLD)
					elif self.mucous.user["status"][username] == 0:
						tw.addstr('* ', self.mucous.colors["red"]|curses.A_BOLD)
				else: 
					tw.addstr('* ',  curses.A_BOLD )	
				pos = 2
				
				if self.current == "buddied":
					attrcount = 0
					try:
						if 'trusted' in attributes:
							color = self.mucous.colors["cyan"] | curses.A_BOLD 
							tw.addstr('!', color)
						else: tw.addstr(' ')
						color = self.mucous.colors["green"] | curses.A_BOLD 
						tw.addstr('!', color)
						if 'banned' in attributes:
							color = self.mucous.colors["red"] | curses.A_BOLD 
							tw.addstr('!', color)
						else: tw.addstr(' ')
						
						if 'ignored' in attributes:
							color = self.mucous.colors["yellow"] | curses.A_BOLD 
							tw.addstr('! ', color)
						else: tw.addstr('  ')
							
					except Exception, e:
						self.mucous.Help.Log("debug", "display list text" + str(e))
						pass
					
					
				elif self.current == "banned":
					
					try:
						if 'trusted' in attributes:
							color = self.mucous.colors["cyan"] | curses.A_BOLD 
							tw.addstr('!', color)
						else: tw.addstr(' ')
						
						if 'buddies' in attributes:
							color = self.mucous.colors["green"] | curses.A_BOLD 
							tw.addstr('!', color)
						else: tw.addstr(' ')
						color = self.mucous.colors["red"] | curses.A_BOLD 
						tw.addstr('!', color)
						if 'ignored' in attributes:
							color = self.mucous.colors["yellow"] | curses.A_BOLD 
							tw.addstr('! ', color)
						else: tw.addstr('  ')
						

					except:
						self.mucous.Help.Log("debug", "display list text" + str(e))
						
				elif self.current == "trusted":
					try:
						color = self.mucous.colors["cyan"] | curses.A_BOLD 
						tw.addstr('!', color)
						
						if 'buddies' in attributes:
							color = self.mucous.colors["green"] | curses.A_BOLD 
							tw.addstr('!', color)
						else: tw.addstr(' ')
						if 'banned' in attributes:
							color = self.mucous.colors["red"] | curses.A_BOLD 
							tw.addstr('!', color)
						else: tw.addstr(' ')
						if 'ignored' in attributes:
							color = self.mucous.colors["yellow"] | curses.A_BOLD 
							tw.addstr('! ', color)
						else: tw.addstr('  ')
					except Exception, e:
						self.mucous.Help.Log("debug", "display list text" + str(e))
						
				elif self.current == "ignored":
					try:
						if 'trusted' in attributes:
							color = self.mucous.colors["cyan"] | curses.A_BOLD 
							tw.addstr('!', color)
						else: tw.addstr(' ')
						if 'buddies' in attributes:
							color = self.mucous.colors["green"] | curses.A_BOLD 
							tw.addstr('!', color)
						else: tw.addstr(' ')
						if 'banned' in attributes:
							color = self.mucous.colors["red"] | curses.A_BOLD 
							tw.addstr('!', color)
						else: tw.addstr(' ')
						color = self.mucous.colors["yellow"] | curses.A_BOLD 
						tw.addstr('! ', color)
					except Exception, e:
						self.mucous.Help.Log("debug", "display list text" + str(e))
				#else:
					#tw.addstr(tabbeduser)
					#stats = note = ''
				color = curses.A_NORMAL
				pos +=5
				
				if count + start == self.scrolling[self.current]:
					attrib = curses.A_BOLD | curses.A_REVERSE | color
					attrib2 = curses.A_BOLD | curses.A_REVERSE 
				else:
					attrib = curses.A_BOLD | color
					attrib2 = curses.A_BOLD 
					
				tw.addstr(tabbeduser, attrib)
							
				if username in self.mucous.user["statistics"]:
					stats = " %sKB/s" % str(self.mucous.user["statistics"][username][0]/1024)
					while len(stats) < 9:
						stats += " "
					files = str(self.mucous.user["statistics"][username][2])
					while len(files) < 7:
						files = " " + files
					stats += files
					while len(stats) < 18:
						stats += " "
					tw.addstr( stats, attrib2)
				else:
					stats  = " 0KB/s         0  "
					tw.addstr(stats, attrib2)
					
				width = len(tabbeduser) + len(stats) + len(note) + 5
				subtract = self.mucous.w - width
				if subtract < 0:
					tw.addstr(note[:len(note)+subtract], attrib2)
				else:
					tw.addstr(note, attrib2)
					
					
				pos += len(tabbeduser) + len(stats) + len(note)
				if self.dimensions[window]["width"] - pos > 0:
					spaces = " " * (self.dimensions[window]["width"] - pos)
					tw.addstr(spaces, attrib2)
			except Exception, e:
				pass

		except Exception, e:
			self.mucous.Help.Log("debug", "DrawLists: " + str(e))

	## Mouse Coordinates in the Users Lists
	# @param self is mucous
	# @param x is the horizontal position from the left
	# @param y is the vertical postion from the top
	# @param z is unimportant
	# @param event is the mouse event (button, doubleclick, etc) represented by a number
	# @return 
	def Mouse(self, x,y,z,event):
		try:
			
			if self.current == "interests":
				w = self.mucous.Recommendations.dimensions[self.mucous.Recommendations.selected]
			else:
				w = self.dimensions[self.current]
			if y == 1:
				if x >= 4 and x <= 15:
					self.current="buddied"
					self.ModeLists()
				elif x >= 17 and x <= 27:
					self.current="banned"
					self.ModeLists()
				elif x >= 29 and x <= 40:
					self.current="ignored"
					self.ModeLists()
				elif x >= 42 and x <= 51:
					self.current="trusted"
					self.ModeLists()
				elif x >= 52 and x <= 64:
					self.current="interests"
					self.ModeLists()
				return
			if self.current == "interests":
				return self.mucous.Recommendations.MouseInterests(x,y,z,event)
			elif self.current in ("buddied", "banned", "ignored", "trusted"):
				# clicking on items in lists
				if y >= w["top"] and y < w["top"] + w["height"] and x >= w["left"] and x < w["left"] +w["width"]:
					y -= w["top"]
					
					this_list = self.logs[self.current]
					if y  + w["start"] in range(len(this_list)):
						self.scrolling[self.current]  = y  + w["start"]
						
						if event in ( 4096, 16384):
							self.SelectLists()
							self.mucous.PopupMenu.Create("lists", 0, True)
						else:
							self.SelectLists()
		except Exception, e:
			self.mucous.Help.Log("debug", "UsersLists.Mouse: " +str(e) )
	
	## ReDraw the current List
	# @param self UsersLists (class)
	def SelectLists(self):
		try:
			this_list = self.logs[self.current]
			if self.scrolling[self.current] > len(this_list):
				self.scrolling[self.current] = len(this_list)
			clipped_list, self.scrolling[self.current], self.dimensions[self.current]["start"] = self.mucous.FormatData.scrollbox(this_list, self.scrolling[self.current], self.mucous.h-7)
			count = 0
			self.windows["text"][self.current].erase()
			for lines in clipped_list:
				self.DrawLists(lines, count, self.current)
				count += 1
			self.windows["text"][self.current].refresh()
		except Exception, e:
			self.mucous.Help.Log("debug", "SelectLists: " + str(e))
			
	## Rebuild Buddied List from Mucous.config
	# @param self UsersLists (class)
	def ListBuddy(self):
		try:
			if "buddies" not in self.mucous.config.keys():
				return
			self.logs["buddied"] = []
			alpha_list = SortedDict()
			for keyname, keyvalue in self.mucous.config["buddies"].items():
				alpha_list[keyname] = keyvalue
			
			for user, note in alpha_list.items():
				attributes = []
				if self.mucous.config["trusted"].has_key(user):
					attributes.append("trusted")
				if self.mucous.config["ignored"].has_key(user):
					attributes.append("ignored")
				if self.mucous.config["banned"].has_key(user):
					attributes.append("banned")
				self.logs["buddied"].append([attributes, user, note])
		except Exception, e:
			self.mucous.Help.Log("debug", "ListBuddy: " + str(e))
			
	## Rebuild Trusted List from Mucous.config
	# @param self UsersLists (class)
	def ListTrust(self):
		try:
			if "trusted" not in self.mucous.config.keys():
				return
			self.logs["trusted"] = []
			alpha_list = SortedDict()
			for keyname, keyvalue in self.mucous.config["trusted"].items():
				alpha_list[keyname] = keyvalue
			
			for user, note in alpha_list.items():
				attributes = []
				if self.mucous.config["ignored"].has_key(user):
					attributes.append("ignored")
				if self.mucous.config["banned"].has_key(user):
					attributes.append("banned")
				if self.mucous.config["buddies"].has_key(user):
					attributes.append("buddies")
				self.logs["trusted"].append([attributes, user, note])
				
		except Exception, e:
			self.mucous.Help.Log("debug", "ListTrust: " + str(e))
			
	## Rebuild ListBan from Mucous.config
	# @param self UsersLists (class)
	def ListBan(self):
		try:
			if "banned" not in self.mucous.config.keys():
				return
			self.logs["banned"] = []
			alpha_list = SortedDict()
			for keyname, keyvalue in self.mucous.config["banned"].items():
				alpha_list[keyname] = keyvalue
			
			for user, note in alpha_list.items():
				attributes = []
				if self.mucous.config["ignored"].has_key(user):
					attributes.append("ignored")
				if self.mucous.config["buddies"].has_key(user):
					attributes.append("buddies")
				if self.mucous.config["trusted"].has_key(user):
					attributes.append("trusted")
				self.logs["banned"].append([attributes, user, note])
		except Exception, e:
			self.mucous.Help.Log("debug", "ListBan: " + str(e))
			
	## Rebuild ListIgnore from Mucous.config
	# @param self UsersLists (class)
	def ListIgnore(self):
		try:
			if self.mucous.config ==  {}:
				return
			if "ignored" not in self.mucous.config.keys():
				return
			self.logs["ignored"] = []
			alpha_list = SortedDict()
			for keyname, keyvalue in self.mucous.config["ignored"].items():
				alpha_list[keyname] = keyvalue
			
			for user, note in alpha_list.items():
				attributes = []
				if self.mucous.config["banned"].has_key(user):
					attributes.append("banned")
				if self.mucous.config["buddies"].has_key(user):
					attributes.append("buddies")
				if self.mucous.config["trusted"].has_key(user):
					attributes.append("trusted")
				self.logs["ignored"].append([attributes, user, note])
				
							
		except Exception, e:
			self.mucous.Help.Log("debug", "ListIgnore: " + str(e))	
			
			
		
## Recommendations
#			
class Recommendations:
	## Constructor
	# @param self Recommendations (class)
	# @param mucous Mucous (class)
	def __init__(self, mucous):
		## @var mucous 
		# Mucous (Class)
		self.mucous = mucous
		## @var dimensions
		# dict containing placement data for windows
		self.dimensions = {}
		## @var input
		# in which interets list to input data
		self.input = "add_likes"
		## @var sort
		# sorting method alphabetical, size
		self.sort = "alpha"
		## @var selected
		# highlighted window
		self.selected = "recommendations"
		## @var logs
		# holds temporary data, until the next scroll update
		self.logs = {"recommendations": [], "likes": [], "hates": [], "similar_users":[] }
		## @var windows
		# dict containing curses window instances
		self.windows = {"text":{}, "border":{}}
		## @var scrolling
		# dict containing scroll position for likes, hates, recommendations and similar users
		self.scrolling = {"likes": 0, "hates": 0, "recommendations": 0, "similar_users": 0}
		## @var data
		# holds temporary data, until the next server update
		self.data = {"recommendations": {}, "similar_users": {}}


	## Create the four windows and call the draw functions
	# @param self Recommendations (class)
	def ModeInterests(self):
		try:
			self.selected = "interests"
			self.mucous.PopupMenu.show = False
# 			self.scrolling[ "recommendations" ] = self.scrolling[ "likes" ] = self.scrolling[ "hates" ] = self.scrolling[ "similar_users" ] = 0
			self.dimensions["recommendations"] = s = {"height": self.mucous.h-8, "top": 3, "left": 21, "width": self.mucous.w-42, "start": 0}
			self.dimensions["likes"] = l = {"height": self.mucous.h/2-5, "top": 3, "left": 1, "width": 18, "start": 0}
			self.dimensions["hates"] = h = {"height": self.mucous.h-8-(l["height"])-2, "top": 5+l["height"], "left": 1, "width": 18, "start": 0}
			self.dimensions["similar_users"] = u = {"height": self.mucous.h-8, "top":3 , "left": self.mucous.w-19, "width": 18, "start": 0}
			
			mw = curses.newwin(3, self.mucous.w,  1, 0)
			mw.attron(self.mucous.colors["green"])
# 			win = curses.newwin(w["height"]+2, w["width"]+2, w["top"]-1, w["left"]-1)
			mw.erase()
			mw.border()
			mw.addstr(0, 3, "< Buddied >",  self.mucous.colors["green"])
			mw.addstr(0, 16, "< Banned >", self.mucous.colors["green"])
			mw.addstr(0, 28, "< Ignored >", self.mucous.colors["green"])
			mw.addstr(0, 40, "< Trusted >", self.mucous.colors["green"] )
			mw.addstr(0, 52, "< Interests >", self.mucous.colors["green"]  | curses.A_BOLD)
			mw.noutrefresh()
			# Cleanup stale windows
			del mw
	

			if self.selected == "likes":
				if self.input not in ("add_likes", "del_likes"):
					self.input = "add_likes"
				if self.input == "add_likes":
					self.mucous.set_edit_title("Add Liked (Alt-D to Toggle to Delete)")
				elif self.input == "del_likes":
					self.mucous.set_edit_title("Delete Liked (Alt-D to Toggle to Add)")
			elif self.selected == "hates":
				if self.input not in ("add_hates", "del_hates"):
					self.input = "add_hates"
				if self.input == "add_hates":
					self.mucous.set_edit_title("Add Hated (Alt-D to Toggle to Delete)")
				elif self.input == "del_hates":
					self.mucous.set_edit_title("Delete Hated (Alt-D to Toggle to Add)")
			elif self.selected == "recommendations":
				self.mucous.set_edit_title("Recommendations:")
			elif self.selected == "similar_users":
				self.mucous.set_edit_title("Similar Users:")
			self.InterestsWindows(s, "recommendations")
			self.InterestsWindows(l, "likes")
			self.InterestsWindows(h, "hates")
			self.InterestsWindows(u, "similar_users")
			self.DrawInterests()

			
			self.mucous.HotKeyBar()
			curses.doupdate()
		except Exception, e:
			self.mucous.Help.Log("debug", "ModeInterests: " + str(e))
			
	## Mouse events in likes, hates, recommendations and similar users
	# @param self Recommendations (class)
	# @param x vertical
	# @param y horizontal
	# @param z doesn't matter
	# @param event is the mouse event (button, doubleclick, etc) represented by a number
	# @return line
	def MouseInterests(self, x,y,z,event):
		try:
			rexw = self.dimensions["recommendations"]
			userw = self.dimensions["similar_users"]
			hatew = self.dimensions["hates"]
			likew = self.dimensions["likes"]
			
			if y >= userw["top"]-1 and y < userw["top"] + userw["height"]+1 and x >= userw["left"]-1 and x < userw["left"]+1 +userw["width"]:
				w = userw
				if self.selected != "similar_users":
					self.selected = "similar_users"
			
				if y == w["top"] + w["height"]:
					if x >= w["left"]+w["width"] -11 and x <=  w["left"]+w["width"]:
						self.mucous.SendMessage(messages.GetSimilarUsers())
				if y >= w["top"] and y < w["top"] + w["height"] and x >= w["left"] and x < w["left"] +w["width"]:
					y -= w["top"]
					this_list = self.logs[self.selected]
					if y  + w["start"] in range(len(this_list)):
						self.scrolling[self.selected]  = y  + w["start"]
						self.mucous.line = str(self.logs[self.selected][self.scrolling[self.selected]][0])
				self.ModeInterests()
				return self.mucous.line
			elif y >= likew["top"]-1 and y < likew["top"] + likew["height"]+1 and x >= likew["left"]-1 and x < likew["left"]+1 +likew["width"]:
				w = likew
				if self.selected != "likes":
					self.selected = "likes"
					
				
				if y == w["top"] + w["height"]:
					
					if x >= w["left"]+2 and x <= w["left"]+7:
						
						if self.input == "add_likes":
							self.InterestLikedAdd(self.mucous.line)
						else:
							self.input = "add_likes"
					elif x >= w["left"]+9 and x <= w["left"]+w["width"]:
						if self.input == "del_likes":
							self.InterestLikedRemove(self.mucous.line)
						else:
							self.input = "del_likes"
						
				if y >= w["top"] and y < w["top"] + w["height"] and x >= w["left"] and x < w["left"] +w["width"]:
					y -= w["top"]
					this_list = self.logs[self.selected]
					
					if y  + w["start"] in range(len(this_list)):
						self.scrolling[self.selected]  = y  + w["start"]
						self.mucous.line = self.logs[self.selected][self.scrolling[self.selected]]

					
				self.ModeInterests()
				return self.mucous.line
			elif y >= hatew["top"]-1 and y < hatew["top"] + hatew["height"]+1 and x >= hatew["left"]-1 and x < hatew["left"]+1 +hatew["width"]:
				w = hatew
				if self.selected != "hates":
					self.selected = "hates"
				if y == w["top"] + w["height"]:
					if x >= 2 and x <= 7:
						if self.input == "add_hates":
							self.InterestHatedAdd(self.mucous.line)
						else:
							self.input = "add_hates"
						
					elif x >= w["left"]+9 and x <= w["left"]+w["width"]:
						if self.input == "del_hates":
							self.InterestHatedRemove(self.mucous.line)
						else:
							self.input = "del_hates"
				if y >= w["top"] and y < w["top"] + w["height"] and x >= w["left"] and x < w["left"] +w["width"]:
					y -= w["top"]
					this_list = self.logs[self.selected]
					if y  + w["start"] in range(len(this_list)):
						self.scrolling[self.selected]  = y  + w["start"]
						self.mucous.line = self.logs[self.selected][self.scrolling[self.selected]]
				self.ModeInterests()
				return self.mucous.line
					
			elif y >= rexw["top"]-1 and y < rexw["top"] + rexw["height"]+1 and x >= rexw["left"]-1 and x < rexw["left"]+1 +rexw["width"]:
				w = rexw
				if self.selected != "recommendations":
					self.selected = "recommendations"
				if y == w["top"] -1:
					if x >= w["left"]+w["width"] -len(self.sort) -5 and x <=  w["left"]+w["width"]:
						if self.sort == "size":
							self.sort = "alpha"
						elif self.sort == "alpha":
							self.sort = "size"
				elif y == w["top"] + w["height"]:
					if x >= w["left"]+ 1 and x <=  w["left"]+12:
						self.mucous.SendMessage(messages.GetRecommendations())
					elif x >= w["left"]+w["width"] -10 and x <=  w["left"]+w["width"]:
						self.mucous.SendMessage(messages.GetGlobalRecommendations())
				elif y >= w["top"] and y < w["top"] + w["height"] and x >= w["left"] and x < w["left"] +w["width"]:
					y -= w["top"]
					this_list = self.logs[self.selected]
					if y  + w["start"] in range(len(this_list)):
						self.scrolling[self.selected]  = y  + w["start"]
						self.mucous.line = self.logs[self.selected][self.scrolling[self.selected]][0]
						
				self.ModeInterests()
				return self.mucous.line
		except Exception, e:
			self.mucous.Help.Log("debug", "MouseInterests: " +str(e) )
			
	
	## Clear recommendations window and read from self.data
	# @param self Recommendations (class)
	def DrawRecommendations(self):
		try:
			mode  = "recommendations"
			self.windows["text"][mode].erase()
			w = self.dimensions[mode]
			self.logs[mode] = []
			sup = self.scrolling[ mode ]
			if self.data[mode] != {}:
				if self.sort == "alpha":
					dict = self.data[mode].keys()
					dict.sort(key=str.lower)
					for item in dict:
						self.logs[mode].append( [item, self.data[mode][item] ])

				elif self.sort == "size":
					dict = self.mucous.FormatData.sortbyvalue(self.data[mode])
					dict.reverse()
					for item, num in dict:
						self.logs[mode].append( [item, num])
				
					
			else:
				self.logs[mode] = [["EMPTY RECOMMENDATIONS", 0]]
			count = 0
			clipped_list, sup, self.dimensions[mode]["start"] = self.mucous.FormatData.scrollbox(self.logs[mode], sup, w["height"])
			self.scrolling[mode] = sup
			start = self.dimensions[mode]["start"]
			for item, num in clipped_list:
				length = len( item+( " " * (w["width"] - len(item)-len(str(num))))+str(num ) )
				if length > w["width"]:
					item = item [:w["width"] - length  ]
				if count + start == sup:
					self.windows["text"][mode].addstr(item +( " " * (w["width"] - len(item)-len(str(num))))+str(num ), curses.A_BOLD)
				else:
					self.windows["text"][mode].addstr(item +( " " * (w["width"] - len(item)-len(str(num))))+str(num ))
				count += 1
			self.windows["text"][mode].refresh()
		except Exception, e:
			self.windows["text"][mode].refresh()
 			self.mucous.Help.Log("debug", "DrawRecommendations: " + str(e))
			
	## Clear users window and read from self.data
	# @param self Recommendations (class)
	def DrawSimilarUsers(self):
		try:
			mode  = "similar_users"
			self.windows["text"][mode].erase()
			sup = self.scrolling[ mode ]
			w = self.dimensions[mode]
			if self.data[mode] != {}:
				self.logs[mode] = []
				
				users = self.data[mode].keys()
				users.sort(key=str.lower)
				for user in users:
					self.logs[mode].append( [user, self.data[mode][user] ])
				
				 
				
				clipped_list, sup, start = self.mucous.FormatData.scrollbox(self.logs[mode], sup, w["height"])
				self.dimensions[mode]["start"] = start
				self.scrolling[mode] = sup
			else:
				clipped_list = [["NO SIMILAR USERS", 0]]
				start = 0
			count = 0
			for user, status in clipped_list:
				if count + start == sup:
					attr = curses.A_BOLD
				else: 
					attr = curses.A_NORMAL
				if status == 1:
					self.windows["text"][mode].addstr("* ", self.mucous.colors["yellow"] | attr)
				elif status == 2:
					self.windows["text"][mode].addstr("* ", self.mucous.colors["green"] | attr)
				else:
					self.windows["text"][mode].addstr("* " , attr)
				if len (user )+2 > w["width"]:
					user = user[ :w["width"]-2-len(user) ]
				self.windows["text"][mode].addstr(user + " " * (w["width"] - len(user)-2),   attr)
				count +=1
				
			
			self.windows["text"][mode].refresh()
		except Exception, e:
			self.mucous.Help.Log( "debug", "DrawSimilarUsers " + str(e) + str(self.scrolling["similar_users" ]))
			self.windows["text"]["similar_users"].refresh()
	
	## Draw everything
	# @param self Recommendations (class)
	def DrawInterests(self):
		self.DrawLiked()
		self.DrawHated()
		self.DrawRecommendations()
		self.DrawSimilarUsers()
		
	## Clear hated window and read from self.data
	# @param self Recommendations (class)
	def DrawHated(self):
		try:
			mode = "hates"

			self.windows["text"][mode].erase()
			w = self.dimensions[mode]
			self.logs[mode] = []
			sup = self.scrolling[ mode ]
			if "interests.hate" in self.mucous.config.keys():
				for item in self.mucous.config["interests.hate"]:
					
					self.logs[mode].append( item)
	
			count = 0
			clipped_list, sup, self.dimensions[mode]["start"] = self.mucous.FormatData.scrollbox(self.logs[mode], sup, w["height"])
			self.scrolling[mode] = sup
			start = self.dimensions[mode]["start"]
			for line in clipped_list:
				length = len( line+( " " * (w["width"] - len(line) ) ) )
				if length > w["width"]:
					line = line [:w["width"] - length  ]
				if count + start == sup:
					self.windows["text"][mode].addstr(line + " " * (self.dimensions["hates"]["width"] - len(line)), curses.A_BOLD)
				else:
					self.windows["text"][mode].addstr(line + " " * (self.dimensions["hates"]["width"] - len(line)))
				count += 1
			self.windows["text"][mode].refresh()
		
		except Exception, e:
			#self.mucous.Help.Log( "debug", "DrawHated " + str(e))
			self.windows["text"]["hates"].refresh()
			
	## Clear liked window and read from self.data
	# @param self Recommendations (class)
	def DrawLiked(self):
		try:
			mode = "likes"
			self.windows["text"][mode].erase()
			w = self.dimensions[mode]
			self.logs[mode] = []
			sup = self.scrolling[ mode ]
			if "interests.hate" in self.mucous.config.keys():
				for item in self.mucous.config["interests.like"]:

					self.logs[mode].append( item)
	
			count = 0
			clipped_list, sup, self.dimensions[mode]["start"] = self.mucous.FormatData.scrollbox(self.logs[mode], sup, w["height"])
			self.scrolling[mode] = sup
			start = self.dimensions[mode]["start"]
			for line in clipped_list:
				length = len( line+( " " * (w["width"] - len(line) ) ) )
				if length > w["width"]:
					line = line [:w["width"] - length  ]
				if count + start == sup:
					self.windows["text"][mode].addstr(line + " " * (w["width"] - len(line)), curses.A_BOLD)
				else:
					self.windows["text"][mode].addstr(line + " " * (w["width"] - len(line)))
				count += 1
			self.windows["text"][mode].refresh()
		except Exception, e:

			self.windows["text"][mode].refresh()
			
	## Creates all windows, exact stored in it's own self.windows[type][mode] slot
	# @param self Recommendations (class)
	# @param w dimensions dict
	# @param mode window name
	def InterestsWindows(self, w, mode):
		try:
			# Cleanup stale windows
			if mode in self.windows["text"]:
				del self.windows["text"][mode]
			if mode in self.windows["border"]:
				del self.windows["border"][mode]
				 
			self.windows["border"][mode] = win = curses.newwin(w["height"]+2, w["width"]+2, w["top"]-1, w["left"]-1)
			if self.selected == mode:
				win.attron(self.mucous.colors["green"])
			win.border()
			if mode == "recommendations":
				title = "Recommendations"
				rs = len(self.sort)
				win.addstr(0, w["width"]-rs-4, "< %s >" % (" "*rs))
				win.addstr(0, w["width"]-rs-2, self.sort.capitalize(),  curses.A_BOLD | self.mucous.colors["cyan"])
				win.addstr(w["height"]+1, 1, "<          >")
				win.addstr(w["height"]+1, 3, "PERSONAL",  curses.A_BOLD | self.mucous.colors["cyan"])
				win.addstr(w["height"]+1, w["width"]-10, "<        >")
				win.addstr(w["height"]+1, w["width"]-8, "GLOBAL",  curses.A_BOLD | self.mucous.colors["cyan"])
			elif mode == "likes":
				title = "Liked"
				if self.input == "add_likes":
					aattr = curses.A_BOLD | self.mucous.colors["cyan"]
					dattr = curses.A_NORMAL
				elif self.input  == "del_likes":
					aattr = curses.A_NORMAL
					dattr = curses.A_BOLD | self.mucous.colors["cyan"]
				else:
					aattr = curses.A_NORMAL
					dattr = curses.A_NORMAL
				win.addstr(w["height"]+1, 1, "<     >")
				win.addstr(w["height"]+1, 3, "ADD", aattr)
				win.addstr(w["height"]+1, w["width"]-9, "<        >")
				win.addstr(w["height"]+1, w["width"]-7, "DELETE", dattr)
			elif mode == "hates":
				title = "Hated"
				if self.input == "add_hates":
					aattr = curses.A_BOLD | self.mucous.colors["cyan"]
					dattr = curses.A_NORMAL
				elif self.input  == "del_hates":
					aattr = curses.A_NORMAL
					dattr = curses.A_BOLD | self.mucous.colors["cyan"]
				else:
					aattr = curses.A_NORMAL
					dattr = curses.A_NORMAL
				win.addstr(w["height"]+1, 1, "<     >")
				win.addstr(w["height"]+1, 3, "ADD", aattr)
				win.addstr(w["height"]+1, w["width"]-9, "<        >")
				win.addstr(w["height"]+1, w["width"]-7, "DELETE", dattr)
			elif mode == "similar_users":
				title = "Users"
				win.addstr(w["height"]+1, w["width"]-10, "<         >")
				win.addstr(w["height"]+1, w["width"]-8, "REFRESH",  curses.A_BOLD | self.mucous.colors["cyan"])
			
			win.addstr(0, 1, "< %s >" % (" " * len(title)))
			if mode == self.selected:
				 win.addstr(0, 3, title, curses.A_BOLD | self.mucous.colors["green"])
			else:
				 win.addstr(0, 3, title, curses.A_BOLD)
			if self.selected == mode:
				win.attroff(self.mucous.colors["green"])
			win.refresh()
			self.windows["text"][mode] = twin = win.subwin(w["height"], w["width"], w["top"], w["left"])
			
			twin.scrollok(0)
			twin.idlok(1)
	
			

		except Exception, e:
			self.mucous.Help.Log( "debug", "InterestsWindows: " + str(e))
			
	
	## Add an item of interest to your liked list
	# @param self is mucous
	# @param interest is a text string
	def LikedAdd(self, interest):
		try:
			if not interest.isspace() and interest != "":
				self.mucous.SendMessage(messages.AddInterest(interest))
		except Exception,e:
			self.mucous.Help.Log("debug", "InterestLikedAdd: " + str(e))	
			
	## Add an item of interest to your hated list
	# @param self is mucous
	# @param interest is a text string
	def HatedAdd(self, interest):
		try:
			if not interest.isspace() and interest != "":
				self.mucous.SendMessage(messages.AddHatedInterest(interest))
		except Exception,e:
			self.mucous.Help.Log("debug", "InterestHatedAdd: " + str(e))
	
	## Remove an item of interest from your liked list
	# @param self is mucous
	# @param interest is a text string
	def LikedRemove(self, interest):
		try:
			if not interest.isspace() and interest != "":
				if interest in self.mucous.config["interests.like"]:
					self.mucous.SendMessage(messages.RemoveInterest(interest))
		except Exception,e:
			self.mucous.Help.Log("debug", "InterestLikedRemove: " + str(e))
	
	## Remove an item of interest from your hated list
	# @param self is mucous
	# @param interest is a text string
	def HatedRemove(self, interest):
		try:
			if not interest.isspace() and interest != "":
				if interest in self.mucous.config["interests.hate"]:
					self.mucous.SendMessage(messages.RemoveHatedInterest(interest))
		except Exception,e:
			self.mucous.Help.Log("debug", "InterestHatedRemove: " + str(e))
			
	## Parse input entry line for interest and match it with Recommendations.selected
	# @param self is mucous
	# @param interest is a text string	
	def InputInterests(self, interest):
		try:
			interest = self.mucous.dlang(interest)
			if self.selected == "likes":
				if self.input == "add_likes":
					self.InterestLikedAdd(interest)
				elif self.input == "del_likes":
					self.InterestLikedRemove(interest)
			elif self.selected == "hates":
				if self.input == "add_hates":
					self.InterestHatedAdd(interest)
				elif self.input == "del_hates":
					self.InterestHatedRemove(interest)
				
				
		except Exception,e:
			self.mucous.Help.Log("debug", "InputInterests: " + str(e))

			
			
			
## RoomsList
# Scrollable and sortable list of rooms on the server
class RoomsList:
	## Constructor (create initial variables)
	# @param self RoomsList (class)
	# @param mucous Mucous (class)
	def __init__(self, mucous):
		## @var mucous 
		# Mucous (Class)
		self.mucous = mucous
		## @var windows
		# dict containing instances of curses windows
		self.windows = {}
		## @var scrolling
		# vertical position in list
		self.scrolling = 0
		## @var dimensions
		# dict containing placement data for windows
		self.dimensions = {}
		## @var rooms
		# dict containing rooms and their sizes; updated by server
		self.rooms = {}
		## @var sizedrooms
		# Sorted rooms; no size data; rebuilt every time viewed
		self.sizedrooms = []
		
		
		

		
		
	## Build windows and display rooms
	# @param self RoomsList (class)#
	def Mode(self):
		try:
			self.mucous.mode = "roomlist"
			self.mucous.PopupMenu.show = False
			
			s = self.dimensions = {"height": self.mucous.h-7, "top": 2, "left": 1, "width": self.mucous.w-2}
			self.DrawWindow()
			
			self.sizedrooms = []
			alpharooms = []
			
			if mucous_config["mucous"]["rooms_sort"]  in ("alpha", "alpha-reversed"):
				for rooms in self.rooms.keys():
					alpharooms.append(rooms)
				alpharooms.sort(key=str.lower)
				if mucous_config["mucous"]["rooms_sort"] =="alpha-reversed":
					alpharooms.reverse()
					
			elif mucous_config["mucous"]["rooms_sort"] in ("size", "size-reversed"):
				bigsizes = []
				bigsizes = self.mucous.FormatData.sortbyvalue (self.rooms)
				if mucous_config["mucous"]["rooms_sort"] == "size":
					bigsizes.reverse()
				for rooms, sizes in bigsizes:
					alpharooms.append(rooms)
			
			for rooms9 in alpharooms:
				if self.rooms[rooms9] >= mucous_config["mucous"]["roomlistminsize"]:
					self.sizedrooms.append(rooms9)
					
			self.Format()
			
			self.mucous.HotKeyBar()
			curses.doupdate()
		except Exception, e:
			self.mucous.Help.Log("debug", "RoomsList.Mode: " + str(e))
		

	## Mouse Coordinates in the RoomsList
	# @param self is RoomsList (Class)
	# @param x is the horizontal position from the left
	# @param y is the vertical postion from the top
	# @param z is unimportant
	# @param event is the mouse event (button, doubleclick, etc) represented by a number
	def Mouse(self, x,y,z,event):
		try:
			if y == self.mucous.h-5:
				if x >= 14 and x <= 22:
					mucous_config["mucous"]["rooms_sort"] = "alpha"
					self.Mode()
				elif x >= 24 and x <= 35:
					mucous_config["mucous"]["rooms_sort"] = "alpha-reversed"
					self.Mode()
				elif x >= 37 and x <= 46:
					mucous_config["mucous"]["rooms_sort"] = "size"
					self.Mode()
				elif x >= 47 and x <= 56:
					mucous_config["mucous"]["rooms_sort"] = "size-reversed"
					self.Mode()
				elif x >= self.mucous.w-16:
					self.mucous.SendMessage(messages.RoomList())
					
			w = self.dimensions
			if y >= w["top"] and y < w["top"] + w["height"] and x >= w["left"] and x < w["left"] +w["width"]:
				y -= w["top"]
				if y  + w["start"] in range(len(self.sizedrooms)):
					self.scrolling  = y  + w["start"]
					self.Format()
					return self.sizedrooms[self.scrolling]
		except Exception, e:
			self.mucous.Help.Log("debug", "RoomsList.Mouse: " +str(e) )
	
	## Build and display RoomsList border and sort bar
	# @param self is RoomsList (Class)
	def DrawWindow(self):
		try:
			# Cleanup stale windows
			if "text" in self.windows:
				del self.windows["text"]
			if "border" in self.windows:
				del self.windows["border"]
				
			s = self.dimensions
			mw = self.windows["border"] = curses.newwin(s["height"]+2, s["width"]+2, s["top"]-1, s["left"]-1)
			mw.attron(self.mucous.colors["green"])
			mw.border()
			mw.attroff(self.mucous.colors["green"])
			
			mw.addstr(0, 3, "< Room List >",  self.mucous.colors["green"] | curses.A_BOLD)
			pos = 3
			sorta = "< "
			sort = "Sort by:"
			sortnaz = " Name A-Z"
			sortnza = " Name Z-A"
			sorts90 =" Size 9-0"
			sorts09 =" Size 0-9"
			quick = mucous_config["mucous"]["rooms_sort"]
			sortnaz_color = sortnza_color = sorts90_color = sorts09_color = curses.A_NORMAL
			if quick == "size":
				sorts90_color = self.mucous.colors["green"]
			elif quick == "size-reversed":
				sorts09_color = self.mucous.colors["green"]
			elif quick == "alpha-reversed":
				sortnza_color = self.mucous.colors["green"]
			elif quick == "alpha":
				sortnaz_color = self.mucous.colors["green"]
			mw.addstr(self.mucous.h-6, pos, sorta,  self.mucous.colors["green"] | curses.A_BOLD)
			pos += 2
			mw.addstr(self.mucous.h-6, pos, sort,  curses.A_BOLD)
			pos += len(sort)
			mw.addstr(self.mucous.h-6, pos, sortnaz,  sortnaz_color | curses.A_BOLD)
			pos += len(sortnaz)
			mw.addstr(self.mucous.h-6, pos, " |",  self.mucous.colors["green"] | curses.A_BOLD)
			pos += 2
			mw.addstr(self.mucous.h-6, pos, sortnza,  sortnza_color | curses.A_BOLD)
			pos += len(sortnza)
			mw.addstr(self.mucous.h-6, pos, " |",  self.mucous.colors["green"] | curses.A_BOLD)
			pos += 2
			mw.addstr(self.mucous.h-6, pos, sorts90, sorts90_color | curses.A_BOLD)
			pos += len(sorts90)
			mw.addstr(self.mucous.h-6, pos, " |",  self.mucous.colors["green"] | curses.A_BOLD)
			pos += 2
			mw.addstr(self.mucous.h-6, pos, sorts09,  sorts09_color | curses.A_BOLD)
			pos += len(sorts09)
			mw.addstr(self.mucous.h-6, pos, " >",  self.mucous.colors["green"] | curses.A_BOLD)
			mw.addstr(self.mucous.h-6, self.mucous.w-15, "< Refresh >",  self.mucous.colors["green"] | curses.A_BOLD)
			self.mucous.set_edit_title("Join a Room")
		
			mw.noutrefresh()
			tw = self.windows["text"] =  mw.subwin(s["height"], s["width"], s["top"], s["left"])
			tw.attron(self.mucous.colors["green"])
			#tw.border()
			tw.attroff(self.mucous.colors["green"])
			#self.scrolling
			self.scrolling = 0
			tw.noutrefresh()
		except Exception, e:
			self.mucous.Help.Log("debug", "RoomsList.DrawWindow: " + str(e))
			
	## Display one room 
	# @param self is RoomsList (Class)
	# @param roomitem a string
	# @param count position in the compacted list
	# @param start padding required for position to be accurate
	def Draw(self, roomitem, count, start):
		try:
			
			if count + start == self.scrolling:
				attrib =  curses.A_BOLD | curses.A_REVERSE
			else:
				attrib = curses.A_NORMAL
			num = str(self.rooms[roomitem])
			while len(num) < 8:
				num += " "
			string = num + self.mucous.dlang(roomitem)
			if len(string) < self.mucous.w-2:
				spaces = " " * (self.mucous.w-2 - len(string))
			else:
				string = string[:self.mucous.w-2]
				spaces = ''
			self.windows["text"].addstr(string+spaces, attrib)
			
		except Exception, e:
			pass
			# Always errors
			#self.mucous.Help.Log("debug", "RoomsList.Draw: " + str(e))
	
	## Display all rooms; Calls Draw 
	# @param self is RoomsList (Class)
	def Format(self):
		try:
			self.windows["text"].erase()
			clipped_list, self.scrolling, self.dimensions["start"] = self.mucous.FormatData.scrollbox(self.sizedrooms, self.scrolling, self.mucous.h-7)
			count =0 
			for rooms10 in clipped_list:
				self.Draw(rooms10, count, self.dimensions["start"])
				count += 1
			self.windows["text"].refresh()
		except Exception, e:
			print e
			self.mucous.Help.Log("debug", "RoomsList.Format: " + str(e))
				
## Setup and view mucous and museekd config options
#			
class Setup:
	## Constructor
	# @param self Setup (class)
	# @param mucous Mucous (class)
	def __init__(self, mucous):
		## @var mucous 
		# Mucous (Class)
		self.mucous = mucous
		## @var windows
		# dict containing instances of curses windows
		self.windows = {"border":{}, }
		## @var input
		# determines how to parse input enter in Setup
		self.input = "default"
		## @var current
		# Currently shown settings
		self.current = "mucous"
		## @var dimensions
		# dict containing placement data for windows
		self.dimensions = {}
		## @var modes
		# Setup modes
		self.modes = ["mucous", "museek", "shares", "userinfo", "logs"]
		## @var password
		# display password
		self.password = False
		
	## Reset input to 'default' and redraw setup
	# @param self Setup (class)
	def Default(self):
		try:
			self.input = "default"
			self.Mode()
		except Exception, e:
			self.mucous.Help.Log("debug", "Setup.Default: "+ str(e))
			
	## Create window, display contents
	# @param self is Setup (Class)
	def Mode(self):
		
		self.mucous.mode = "setup"
		self.mucous.PopupMenu.show = False
		try:
			# Cleanup stale windows
			if "setup" in self.windows["border"]:
				del self.windows["border"]["setup"]
				
			w = self.dimensions["setup"] = {"height": self.mucous.h-5, "width": self.mucous.w, "top": 1, "left": 0}	
			mw = self.windows["border"]["setup"] = curses.newwin(w["height"], w["width"], w["top"], w["left"])
			mw.erase()
			mw.border()
			mw.addstr(w["height"]-1, 2, "< Use the mouse, if possible. Otherwise: /help setup >")

			if self.current == "mucous":
				#self.mucous.set_edit_title("Mucous Setup")
				try:
					mw.addstr(0, 1, "< Mucous >",  curses.A_BOLD)
					mw.addstr(0, 15, "< Museek >")
					mw.addstr(0, 30, "< Shares >")
					mw.addstr(0, 45, "< Userinfo >")
					mw.addstr(0, 60, "< Logs >")
				except:
					pass
			elif self.current == "museek":
				try:
					mw.addstr(0, 1, "< Mucous >")
					mw.addstr(0, 15, "< Museek >",  curses.A_BOLD)
					mw.addstr(0, 30, "< Shares >")
					mw.addstr(0, 45, "< Userinfo >")
					mw.addstr(0, 60, "< Logs >")
				except:
					pass
			elif self.current == "shares":
				try:
					mw.addstr(0, 1, "< Mucous >")
					mw.addstr(0, 15, "< Museek >")
					mw.addstr(0, 30, "< Shares >",  curses.A_BOLD)
					mw.addstr(0, 45, "< Userinfo >")
					mw.addstr(0, 60, "< Logs >")
				except:
					pass
			elif self.current == "userinfo":
				try:
					mw.addstr(0, 1, "< Mucous >")
					mw.addstr(0, 15, "< Museek >")
					mw.addstr(0, 30, "< Shares >")
					mw.addstr(0, 45, "< Userinfo >",  curses.A_BOLD)
					mw.addstr(0, 60, "< Logs >")
				except:
					pass
			elif self.current == "logs":
				try:
					mw.addstr(0, 1, "< Mucous >")
					mw.addstr(0, 15, "< Museek >")
					mw.addstr(0, 30, "< Shares >")
					mw.addstr(0, 45, "< Userinfo >")
					mw.addstr(0, 60, "< Logs >",  curses.A_BOLD)
				except:
					pass
			self.InputTitle()
			mw.noutrefresh()
			# Create buttons, settings and immediately Delete them to aviod leaks
			if self.current in ("shares"):
				self.DrawShares()
			elif self.current in ("userinfo"):
				self.DrawUserinfo()
			elif self.current in ("logs"):
				self.DrawLogs()
			elif self.current == "mucous":
				self.DrawMucous()
			elif self.current == "museek":
				self.DrawMuseek()
				

		except Exception, e:
			self.mucous.Help.Log("debug", "Setup.Mode: " + str(e) )
		self.mucous.ModeTopbar()
		self.mucous.HotKeyBar()
		curses.doupdate()
		
	## Update input line's title
	# @param self is Setup (Class)
	def InputTitle(self):
		si = self.input
		if si == "default":
			self.mucous.set_edit_title("Setup Mode")
		elif si == "interface":
			self.mucous.set_edit_title("Set Interface")
		elif si == "custom-url":
			self.mucous.set_edit_title("Set custom URL handler: command$command")
		elif si == "interface-password":
			self.mucous.set_edit_title("Set Mucous's Interface password")
		elif si == "museek-interface-password":
			self.mucous.set_edit_title("Set Museek's Interface password")
		elif si == "museek-interface-bind":
			self.mucous.set_edit_title("Add a Museek Interface")
		elif si == "server-host":
			self.mucous.set_edit_title("Set Server Address")
		elif si == "server-port":
			self.mucous.set_edit_title("Set Server Port")
		elif si == "soulseek-username":
			self.mucous.set_edit_title("Set Soulseek Username")
		elif si == "soulseek-password":
			self.mucous.set_edit_title("Set Soulseek Password")
		elif si == "slots":
			self.mucous.set_edit_title("Set Number of Upload Slots to:")
		elif si == "download-dir":
			self.mucous.set_edit_title("Set completed download directory")
		elif si == "incomplete-dir":
			self.mucous.set_edit_title("Set incompleted download directory")
		elif si == "userinfo":
			self.mucous.set_edit_title("Set UserInfo")
		elif si == "userimage":
			self.mucous.set_edit_title("Set UserImage")
		elif si == "adddir":
			self.mucous.set_edit_title("Add directory to your normal shares")
		elif si == "rmdir":
			self.mucous.set_edit_title("Remove directory from your normal shares")
		elif si == "addbuddydir":
			self.mucous.set_edit_title("Add directory to your buddy shares")
		elif si == "rmbuddydir":
			self.mucous.set_edit_title("Remove directory from your buddy shares")
			
	## Parse input entry line for interest and match it with Setup.input
	# @param self is Setup (Class)
	# @param line is a text string
	def InputSetup(self, line):
		try:
			line = self.mucous.dlang(line)
			if self.input == "interface":
				mucous_config["connection"]["interface"] = line
			elif self.input=="interface-password":
				mucous_config["connection"]["passw"] = line
			elif self.input=="custom-url":
				if "$" in line:
					custom = line.split("$")
					if len(custom) > 1 and len(custom) < 3:
						mucous_config["mucous"]["url custom prefix"] = custom[0]
						mucous_config["mucous"]["url custom suffix"] = custom[1]
					elif len(custom) == 1:
						mucous_config["mucous"]["url custom prefix"] = custom[0]
						mucous_config["mucous"]["url custom suffix"] = ''
			elif self.input=="museek-interface-password":
				
				self.mucous.SendMessage(messages.ConfigSet("interfaces", "password", line))
			elif self.input=="museek-interface-bind":
				
				self.mucous.SendMessage(messages.ConfigSet("interfaces.bind", line))
			elif self.input=="server-host":
				
				self.mucous.SendMessage(messages.ConfigSet("server", "host", line))
			elif self.input=="server-port":
				
				self.mucous.SendMessage(messages.ConfigSet("server", "port", line))
			elif self.input=="soulseek-username":
				self.mucous.SendMessage(messages.ConfigSet("server", "username", line))
			elif self.input=="soulseek-password":
				self.mucous.SendMessage(messages.ConfigSet("server", "password", line))
			elif self.input=="download-dir":
				self.mucous.SendMessage(messages.ConfigSet("transfers", "download-dir", line))
			elif self.input=="incomplete-dir":
				
				self.mucous.SendMessage(messages.ConfigSet("transfers", "incomplete-dir", line))
			elif self.input=="userinfo":
				
				try:
					if '\\n' in line:
						line = line.replace('\\n', '\n')
					self.mucous.SendMessage(messages.ConfigSet("userinfo", "text", line))
				except Exception, e:
					self.mucous.Help.Log("debug", "set userinfo: "+str( e))
			elif self.input=="userimage":
				
				try:
					self.mucous.SendMessage(messages.ConfigSet("userinfo", "image", line))
				except:
					pass
			elif self.input=="adddir":
				self.mucous.Muscan.Command(["muscan", "-s", line])
				self.mucous.Help.Log("status", "Adding "+line+" to normal shares. Scanning will begin.")
			elif self.input=="rmdir":
				self.mucous.Muscan.Command(["muscan", "-u", line])
				self.mucous.Help.Log("status", "Removing "+line+" from normal shares. Please rescan or update.")
			elif self.input=="addbuddydir":
				
				self.mucous.Muscan.Command(["muscan", "-b", "-s", line])
				self.mucous.Help.Log("status", "Adding "+line+" to buddy shares. Scanning will begin.")
			elif self.input=="rmbuddydir":
				self.mucous.Muscan.Command(["muscan", "-b", "-u", line])
				self.mucous.Help.Log("status", "Removing "+line+" from buddy shares. Please rescan or update.")
			self.input = "default"
			self.Mode()
		except Exception,e:
			self.mucous.Help.Log("debug", "InputSetup: " + str(e))
			
	## Draw Mucous settings
	# @param self is Setup (Class)
	def DrawMucous(self):
		w = self.dimensions["setup"]
		mw = self.windows["border"]["setup"]
		# Interface
		interface =""
		if "connection" in mucous_config:
			interface = self.mucous.dlang( mucous_config["connection"]["interface"][:28] )
		
		self.SetupButton("Museek Interface", interface ,2,1, 3,32)
		
		
		if "connection" in mucous_config:
			if self.password == True:
				password = self.mucous.dlang( str(mucous_config["connection"]["passw"]) )
			else:
				password = '*********'
		else:
			password = "NOT set"
			
		self.SetupButton("Interface Password", password, 5,1,3,32)
		
		bwin = curses.newwin(6,22,2,33)
		bwin.border()
		try:
			bwin.addstr(0, 1, "< Stats >",  curses.A_BOLD)
		except:
			pass
		bwin.noutrefresh()
		inbwin1_1 = bwin.subwin(1,20,3,34)
		inbwin1_2 = bwin.subwin(1,20,4,34)
		inbwin1_3 = bwin.subwin(1,20,5,34)
		inbwin1_4 = bwin.subwin(1,20,6,34)
		inbwin1_1.scrollok(1)
		inbwin1_2.scrollok(1)
		inbwin1_3.scrollok(1)
		inbwin1_4.scrollok(1)
		if self.mucous.data["mystats"] != []:
			try:
				inbwin1_1.addstr("Files: "+str(self.mucous.data["mystats"][3]), self.mucous.colors["cyan"] )
				inbwin1_2.addstr("Dirs: "+str(self.mucous.data["mystats"][4]), self.mucous.colors["cyan"] )
				inbwin1_3.addstr("Downloads: "+str(self.mucous.data["mystats"][2]), self.mucous.colors["cyan"] )
				inbwin1_4.addstr("Speed: "+str(self.mucous.data["mystats"][1]/1024)+"KB/s", self.mucous.colors["cyan"] )
				#self.data["mystats"] = user,  avgspeed, numdownloads, numfiles, numdirs
			except:
				pass
		else:
			if self.mucous.username != None:
				self.mucous.SendMessage(messages.PeerStats(self.mucous.username))
		inbwin1_1.noutrefresh()
		inbwin1_2.noutrefresh()
		inbwin1_3.noutrefresh()
		inbwin1_4.noutrefresh()
		del inbwin1_1
		del inbwin1_2
		del inbwin1_3
		del inbwin1_4 
		del bwin
		
		self.SetupCheck("Show Tickers:         /showtickers", mucous_config["tickers"]["tickers_enabled"] ,8,1,1,45, True)

		self.SetupCheck("Cycle Tickers:        /tickers", mucous_config["tickers"]["ticker_cycle"] ,9,1,1,45, True, True)
		self.SetupCheck("Scroll Tickers:       /tickers", mucous_config["tickers"]["ticker_scroll"] ,10,1,1,45, True, True)
		self.SetupCheck("Auto-clear Transfers: /autoclear", mucous_config["mucous"]["auto-clear"],11,1,1,45, True)

		self.SetupCheck("Auto-retry Transfers: /autoretry", mucous_config["mucous"]["auto-retry"],12,1, 1,45, True)

		self.SetupCheck("Auto-Buddy downloads: /autobuddy", mucous_config["mucous"]["autobuddy"],13,1,1,45, True)
		
		self.SetupCheck("Beep:                 /beep", mucous_config["mucous"]["beep"],14,1,1,45, True)
		self.SetupButton("< Ticker Time >", " -  %.2f +\n -  %.2f +" % ( float(mucous_config["tickers"]["cycletime"]), float(mucous_config["tickers"]["scrolltime"])), 8,39, 4,16, False, False)
		# Minimum Room size for Roomlist
		
		self.SetupButton("<Min Roomlist>", " -  "+str(mucous_config["mucous"]["roomlistminsize"])+" +", 8,55, 3,16, False, False)

		self.SetupButton("Encoding", mucous_config["mucous"]["language"], 12,39,3,16)
		
		# Custom URL
		prefix =""
		if "url custom prefix" in mucous_config["mucous"] and "url custom suffix" in mucous_config["mucous"]:
			prefix = self.mucous.dlang(mucous_config["mucous"]["url custom prefix"])+"$"+self.mucous.dlang(mucous_config["mucous"]["url custom suffix"])
		self.SetupButton("Custom URL Reader", prefix,15,1,3,32, optionbold=True)
		self.SetupButton("URL Reader", self.mucous.dlang(mucous_config["mucous"]["url reader"]), 15,33,3,16)


		# Save button
		self.SetupButton(None, " Save Config", 15,49,3,16, True)
		
	## Draw Museek settings
	# @param self is Setup (Class)
	def DrawMuseek(self):
		w = self.dimensions["setup"]
		mw = self.windows["border"]["setup"]
		# Server
		bw = curses.newwin(5,38,2,1)
		bw.border()
		bw.addstr(0, 1, "< Server >",  curses.A_BOLD)
			
		bw.noutrefresh()
		inbw = bw.subwin(1,36,3,2)
		inbw.scrollok(1)
		inbw.addstr("Host: ")
		if "server" in self.mucous.config:
			try:
				inbw.addstr(self.mucous.dlang( self.mucous.config["server"]["host"][:22] )+":"+self.mucous.config["server"]["port"], self.mucous.colors["cyan"] )
			except:
				pass
		inbw.noutrefresh()
		del inbw
		

		
		inusernamewin2 = bw.subwin(1,36,4,2)
		inusernamewin2.scrollok(1)
		inusernamewin2.addstr("Name: ")
		if "server" in self.mucous.config:
			a = self.mucous.dlang(self.mucous.config["server"]["username"])
			try:
				inusernamewin2.addstr(a, self.mucous.colors["cyan"])
			except:
				pass

		inusernamewin2.noutrefresh()
		del inusernamewin2

		inifacepasswin = bw.subwin(1,36,5,2)
		inifacepasswin.addstr("Pass: ")
		if self.password == True:
			if "server" in self.mucous.config:
				inifacepasswin.addstr(self.mucous.dlang( self.mucous.config["server"]["password"] ), self.mucous.colors["cyan"])
				
		else:
			if "server" in self.mucous.config:
				inifacepasswin.addstr("*********", self.mucous.colors["cyan"])
		inifacepasswin.noutrefresh()
		del inifacepasswin
		del bw

		ifacepasswin = curses.newwin(3,26,2,39)
		ifacepasswin.border()
		ifacepasswin.addstr(0, 1, "< Interface Password >",  curses.A_BOLD)

		ifacepasswin.noutrefresh()
		inifacepasswin = ifacepasswin.subwin(1,24,3,40)
		inifacepasswin.scrollok(1)
		if "interfaces" in self.mucous.config:
			if self.password == True:
				try:
					inifacepasswin.addstr(self.mucous.dlang( self.mucous.config["interfaces"]["password"] ), self.mucous.colors["cyan"])
				except:
					pass
			else:
				inifacepasswin.addstr("*********", self.mucous.colors["cyan"])
		inifacepasswin.noutrefresh()
		del inifacepasswin

		#------------------------

		self.SetupCheck("Share to Buddies-Only", self.mucous.config["transfers"]["only_buddies"],8,1,1,30, True)

		self.SetupCheck("Buddies get Privileges", self.mucous.config["transfers"]["privilege_buddies"],9,1,1,30, True)

		self.SetupCheck("Enable Buddy-Only shares",self.mucous.config["transfers"]["have_buddy_shares"],10,1,1,30, True)

		self.SetupCheck("Allow Trusted users to send you files",self.mucous.config["transfers"]["trusting_uploads"],11,1,1,self.mucous.w-3, True)

		self.SetupCheck("Send automatic warnings via Private Chat",self.mucous.config["transfers"]["user_warnings"],12,1,1,self.mucous.w-3, True)

		self.SetupButton("<Connections >", self.mucous.config["clients"]["connectmode"],5,49,3,16, True, False)

		self.SetupButton("<Upload Slots>", " - " + self.mucous.config["transfers"]["upload_slots"]+ " +", 8,49,3,16, True, False)

		dirwin = curses.newwin(4,self.mucous.w-2,13,1)
		dirwin.border()
		dirwin.addstr(0, 1, "< Download/Incomplete Directories >",  curses.A_BOLD)
		dirwin.noutrefresh()
		dircompletewin = dirwin.subwin(1,self.mucous.w-4,14,2)
		try:
			dircompletewin.addstr(self.mucous.dlang(self.mucous.config["transfers"]["download-dir"]), self.mucous.colors["cyan"])
		except: pass
		dircompletewin.noutrefresh()
		dirincompletewin = dirwin.subwin(1,self.mucous.w-4,15,2)
		try:
			dirincompletewin.addstr(self.mucous.dlang(self.mucous.config["transfers"]["incomplete-dir"]), self.mucous.colors["cyan"])
		except: pass
		dirincompletewin.noutrefresh()
		del dirincompletewin
		del dircompletewin
		del dirwin
		
	## Draw Shares config options
	# @param self is Setup (Class)
	def DrawShares(self):
		w = self.dimensions["setup"]
		mw = self.windows["border"]["setup"]
		# First Row
		self.SetupButton("Normal", "List Shared", 3,1,3,16)
		self.SetupButton(None, "Add Directory", 3,17,3,16)
		self.SetupButton(None, "Remove Dir", 3,33,3,16)
		self.SetupButton(None, "Click on the buttons to run the local muscan.\nWhen you click on Add/Remove Directory, type in the directory below, and start with '//' instead of just a '/'", 2,49,10,self.mucous.w-50)
		# Second Row
		self.SetupButton(None, "Rescan Shares",6,1,3,16)
		self.SetupButton(None, "Update Shares", 6,17,3,16)
		
		# Third Row
		self.SetupButton("Buddy-only", "List Shared", 9,1,3,16)
		self.SetupButton(None, "Add Directory", 9,17,3,16)
		self.SetupButton(None, "Remove Dir", 9,33,3,16)
		
		# Fourth Row
		self.SetupButton(None, "Rescan Shares", 12,1,3,16)
		self.SetupButton(None, "Update Shares", 12,17,3,16)
		self.SetupButton(None, "Reload Shares", 12,49,3,16, optionbold=True)
		
		museekconfigfile = self.mucous.Spl["museekconfigfile"]
		# Fifth Row
		self.SetupButton("Museek Config File", museekconfigfile[:self.mucous.w-2], 15,1,3,self.mucous.w-2)
		
		
	## Draw Log file options
	# @param self is Setup (Class)
	def DrawLogs(self):
		w = self.dimensions["setup"]
		mw = self.windows["border"]["setup"]
		self.SetupCheck("Log Chat messages? ", mucous_config["mucous"]["logging"],2,1,1,30, True)
		self.SetupButton("Log Directory", os.path.expanduser(mucous_config["mucous"]["log_dir"])[:37], 5,1,3,self.mucous.w-2)
	## Draw User Info 
	# @param self is Setup (Class)
	def DrawUserinfo(self):
		w = self.dimensions["setup"]
		mw = self.windows["border"]["setup"]
		info = ""
		if "userinfo" in self.mucous.config.keys():
			if "text" in self.mucous.config["userinfo"]:
				info = self.mucous.config["userinfo"]["text"]
				#for line in self.mucous.config["userinfo"]["text"]:
					#info += line.decode(mucous_config["mucous"]["language"], "replace") +"\n"
		
		self.SetupButton("Your Userinfo", info, 2,1,self.mucous.h-8,self.mucous.w-2)
		
		inputimage = curses.newwin(1,13,self.mucous.h-6,1)
		inputimage.erase()
		inputimage.addstr( "Your Image: ")
		inputimage.noutrefresh()
		
		if "userinfo" in self.mucous.config.keys():
			if "image" in self.mucous.config["userinfo"]:
				inputimage2 = curses.newwin(1,self.mucous.w-2-14,self.mucous.h-6,14)
				inputimage2.erase()
				inputimage2.scrollok(1)
				inputimage2.addstr( str(self.mucous.config["userinfo"]["image"][:self.mucous.w-3-14]))
				inputimage2.noutrefresh()
		del inputimage2
		del inputimage
			
	## Create a Button
	# @param self Setup (class)
	# @param title
	# @param option
	# @param x
	# @param y
	# @param height
	# @param width
	# @param optionbold True/False
	# @param titlepad True/False
	# @param border
	def SetupButton(self, title, option, x, y, height, width, optionbold=False, titlepad=True, border=True):
		try:
			winborder = curses.newwin(height,width,x,y)
			if border:
				winborder.border()
			if title != None:
				if titlepad:
					winborder.addstr(0,1, "< %s >" % title, curses.A_BOLD)
				else:
					winborder.addstr(0,1, title, curses.A_BOLD)
			winborder.noutrefresh()
			win = winborder.subwin(height-2,width-2,x+1,y+1)
			win.scrollok(1)
			if option != None:
				if optionbold:
					win.addstr(option, self.mucous.colors["cyan"] | curses.A_BOLD)
				else:
					win.addstr(option, self.mucous.colors["cyan"])
			win.noutrefresh()
			del win
			del winborder
		except Exception,e:
			self.mucous.Help.Log("debug", "SetupButton: "+title+" "+ str(e))
			
	## Create a Check box or a toggle button
	# @param self Setup (class)
	# @param title
	# @param option
	# @param x
	# @param y
	# @param height
	# @param width
	# @param titlebold True/False
	# @param toggle True/False (is a togglebutton)
	def SetupCheck(self, title, option, x, y, height, width, titlebold=False, toggle=False):
		try:
			enabled = "[x]"
			disabled = "[ ]"
			selected = "(*)"
			notselected = "( )"
			
			win = curses.newwin(height,width,x,y)
			win.erase()
			if option in ("True", "true", "yes"):
				if toggle:
					z = selected
				else:
					z = enabled
			else:
				if toggle:
					z = notselected
				else:
					z = disabled
			win.addstr(z+" ", self.mucous.colors["cyan"])
			if title != None:
				if titlebold:
					win.addstr(title,  curses.A_BOLD)
				else:
					win.addstr(title)
			win.noutrefresh()
			
			del win

		except Exception,e:
			self.mucous.Help.Log("debug", "SetupButton: "+title+" "+ str(e))
			
	## Mouse Coordinates in the Setup Mode
	# @param self is Setup (Class)
	# @param x is the horizontal position from the left
	# @param y is the vertical postion from the top
	# @param z is unimportant
	# @param event is the mouse event (button, doubleclick, etc) represented by a number
	def Mouse(self, x,y,z,event):
		try:
			
			if y in (0, 1):
				if x >=1 and x <=12:
					if self.current != "mucous":
						self.current="mucous"
						self.input = "default"
				elif x >=16 and x <=26:
					if self.current != "museek":
						self.current="museek"
						self.input = "default"
				elif x >=31 and x <=41:
					if self.current != "shares":
						self.current="shares"
						self.input = "default"
				elif x >=46 and x <=57:
					if self.current != "userinfo":
						self.current="userinfo"
						self.input = "default"
				elif x >=60 and x <=69:
					if self.current != "logs":
						self.current="logs"
						self.input = "default"
				self.Mode()

			if self.current=="shares":
				if y in ( 3, 4, 5):
					if x >= 1 and x <= 16:
						self.mucous.Muscan.ListNormal()
					elif x >= 17 and x <= 32:
						self.mucous.Muscan.ChangeInput("adddir")
					elif x >= 33 and x < 49:
						self.mucous.Muscan.ChangeInput("rmdir")

				if y in ( 6, 7, 8):
					if x >= 1 and x <= 16:
						self.mucous.Muscan.RescanNormal()
					elif x >= 17 and x <= 32:
						self.mucous.Muscan.UpdateNormal()
				elif y in ( 9, 10, 11):
					if x >= 1 and x <= 16:
						self.mucous.Muscan.ListBuddy()
					elif x >= 17 and x <= 32:
						self.mucous.Muscan.ChangeInput("addbuddydir")
					elif x >= 33 and x < 49:
						self.mucous.Muscan.ChangeInput("rmbuddydir")
				elif y in ( 12, 13, 14):
					if x >= 1 and x <= 16:
						self.mucous.Muscan.RescanBuddy()
					elif x >= 17 and x <= 32:
						self.mucous.Muscan.UpdateBuddy()
					elif x >= 49 and x <= 66:
						self.mucous.SendMessage(messages.ReloadShares())
			elif self.current=="userinfo":
				if y >= 1 and y < self.mucous.h-7:
					self.input="userinfo"
				elif y <= self.mucous.h-5 and y >= self.mucous.h-7:
					self.input="userimage"
				self.Mode()
			elif self.current=="logs":
				if y >= 2 and y <= 3 and x < 37:
					self.mucous.ToggleLogging()
					self.Mode()
				
					
			if self.current not in ("museek", "mucous"):
				return
			if y not in (2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17):
				return
			if self.current=="museek" and "transfers" in self.mucous.config:
				if y in (2, 3) and x >=1 and x <=35:
					self.input="server-host"
					self.Mode()
				elif y == 4 and x >=1 and x <=35:
					self.input="soulseek-username"
					self.Mode()
				elif y == 5 and x >=1 and x <=35:
					self.input="soulseek-password"
					self.Mode()
				elif y in (2, 3, 4) and x >=40 and x <=63:
					self.input="museek-interface-password"
					self.Mode()
				elif y in (5,6,7) and x >=50 and x <=63:
					# Connect Mode
					if "clients" in self.mucous.config:
						
						if self.mucous.config["clients"]["connectmode"] == "passive":
							self.mucous.SendMessage(messages.ConfigSet("clients", "connectmode", "active"))
						elif self.mucous.config["clients"]["connectmode"] == "active":
							self.mucous.SendMessage(messages.ConfigSet("clients", "connectmode", "passive"))
							
				elif y==8 and x >=1 and x <=30:
					#Buddies-only
					
					if self.mucous.config["transfers"]["only_buddies"] == "true":
						self.mucous.SendMessage(messages.ConfigSet("transfers", "only_buddies", "false"))
					elif self.mucous.config["transfers"]["only_buddies"] == "false":
						self.mucous.SendMessage(messages.ConfigSet("transfers", "only_buddies", "true"))
				elif y==9 and x >=1 and x <=30:
					
					if self.mucous.config["transfers"]["privilege_buddies"] == "true":
						self.mucous.SendMessage(messages.ConfigSet("transfers", "privilege_buddies", "false"))
							
					elif self.mucous.config["transfers"]["privilege_buddies"] == "false":
						self.mucous.SendMessage(messages.ConfigSet("transfers", "privilege_buddies", "true"))
				elif y==10 and x >=1 and x <=30:
					if self.mucous.config["transfers"]["have_buddy_shares"] == "true":
						self.mucous.SendMessage(messages.ConfigSet("transfers", "have_buddy_shares", "false"))
							
					elif self.mucous.config["transfers"]["have_buddy_shares"] == "false":
						self.mucous.SendMessage(messages.ConfigSet("transfers", "have_buddy_shares", "true"))
				elif y==11 and x >=1 and x <=50:
					if self.mucous.config["transfers"]["trusting_uploads"]== "true":
						self.mucous.SendMessage(messages.ConfigSet("transfers", "trusting_uploads", "false"))
							
					elif self.mucous.config["transfers"]["trusting_uploads"] == "false":
						self.mucous.SendMessage(messages.ConfigSet("transfers", "trusting_uploads", "true"))
				elif y==12 and x >=1 and x <=50:
					if self.mucous.config["transfers"]["user_warnings"] == "true":
						self.mucous.SendMessage(messages.ConfigSet("transfers", "user_warnings", "false"))
							
					elif self.mucous.config["transfers"]["user_warnings"] == "false":
						self.mucous.SendMessage(messages.ConfigSet("transfers", "user_warnings", "true"))
				
				elif y in (8,9,10)  and x >=49 and x <=64:
					s = int(self.mucous.config["transfers"]["upload_slots"]) 
					if x >=49 and x <=53:
						s  -= 1
					elif x >=54 and x <=64:
						s  += 1
					if s < 0:
						s = 0
					s = str(s)
					self.mucous.SendMessage(messages.ConfigSet("transfers", "upload_slots", s))
					self.Mode()
				elif y in (13, 14):
					# Download Directory
					self.input="download-dir"
					self.Mode()
				elif y in (15, 16):
					# Incomplete Download Directory
					self.input="incomplete-dir"
					#if x >=1 and x <=61:
					self.Mode()
					
			elif self.current=="mucous":
				if y in (2, 3, 4):
					if x >=1 and x <=35:
						self.input="interface"
						self.Mode()
				elif y in (5, 6, 7):
					if x >=1 and x <=35:
						self.input="interface-password"
					self.Mode()
				elif y == 8 and x >=1 and x <=40:
					self.mucous.ChatRooms.ToggleTickersDisplay()
				elif y in (9, 10) and  x >=1 and x <=38:
					self.mucous.ChatRooms.ToggleTickers()
						
				elif y == 11 and x >=1 and x <=38:
					if mucous_config["mucous"]["auto-clear"] == "yes":
						mucous_config["mucous"]["auto-clear"] = "no"
						self.mucous.clear_timer.cancel()
						self.mucous.clear_timer = threading.Timer(30.0, self.mucous.ThreadTransfersClear)
						
					else:
						mucous_config["mucous"]["auto-clear"] ="yes"
						self.mucous.clear_timer.cancel()
						self.mucous.clear_timer = threading.Timer(30.0, self.mucous.ThreadTransfersClear)
						self.mucous.clear_timer.start()
					self.Mode()
				elif y in (8, 9, 10, 11) and x >= 39 and x <= 54:
					# Minimum size of rooms displayed in room list
					
					if x >=39 and x <=47:
						
						if y in (8, 9):
							
							mucous_config["tickers"]["cycletime"] = str(float (mucous_config["tickers"]["cycletime"])-0.5) 
						elif y in (10,11):
							
							mucous_config["tickers"]["scrolltime"] = str(float( mucous_config["tickers"]["scrolltime"])-0.1)
					elif x >=48 and x <=54:
						if y in (8, 9):
							
							mucous_config["tickers"]["cycletime"] = str( float( mucous_config["tickers"]["cycletime"])+0.5)
						elif y in (10,11):
							mucous_config["tickers"]["scrolltime"] = str(float( mucous_config["tickers"]["scrolltime"])+0.1)
					if float(mucous_config["tickers"]["scrolltime"]) < 0.1:
						mucous_config["tickers"]["scrolltime"] = str(0.1)
					if float(mucous_config["tickers"]["cycletime"]) < 1.0:
						mucous_config["tickers"]["cycletime"] = str(1.0)
					self.Mode()
				elif y in (8, 9, 10) and x >= 55 and x <= 71:
					# Minimum size of rooms displayed in room list
					if x >=55 and x <=61:
						mucous_config["mucous"]["roomlistminsize"] -= 1
					elif x >=62 and x <=71:
						mucous_config["mucous"]["roomlistminsize"] += 1
					if mucous_config["mucous"]["roomlistminsize"] < 1:
						mucous_config["mucous"]["roomlistminsize"] = 1
					self.Mode()
				
				elif y == 12 and x >=1 and x <=40:
					if str(mucous_config["mucous"]["auto-retry"]) == "yes":
						mucous_config["mucous"]["auto-retry"] = "no"
						self.mucous.retry_timer.cancel()
					else:
						mucous_config["mucous"]["auto-retry"] ="yes"
						self.mucous.retry_timer.cancel()
						self.mucous.retry_timer = threading.Timer(30.0, self.mucous.ThreadTransfersRetry)
						self.mucous.retry_timer.start()
					self.Mode()
					
				elif y ==13  and x >=1 and x <=40:
					# Toggle Autobuddy
					if mucous_config["mucous"]["autobuddy"]  == "yes":
						mucous_config["mucous"]["autobuddy"] = "no"

					elif mucous_config["mucous"]["autobuddy"]  == "no":
						mucous_config["mucous"]["autobuddy"] = "yes"
					self.Mode()
				elif y == 14 and  x >=1 and x <=40:
					self.mucous.ToggleBeep()

					
				elif y in (12, 13, 14) and x >=39 and x <=55:
					# Change charset, encoding, language that text is piped thru
					if "language" in mucous_config["mucous"]:
						if mucous_config["mucous"]["language"] in self.mucous.encodings:
							pos = self.mucous.encodings.index(mucous_config["mucous"]["language"])
							pos +=1
							if pos not in range(len(self.mucous.encodings)):
								pos = 0
							mucous_config["mucous"]["language"]=self.mucous.encodings [pos]
							self.Mode()
						else:
							mucous_config["mucous"]["language"]=self.mucous.encodings [0]
							self.Mode()
			
				elif y in (15, 16, 17):
					if x >=1 and x <=32:
						# Edit custom URL handler process
						self.input="custom-url"
						self.Mode()
					elif x >=35 and x <=49:
						# Cycle thru list of URL handlers
						u = mucous_config["mucous"]["url reader"]
						if u == 'lynx': u = 'links'
						elif u == 'links': u = 'elinks'
						elif u == 'elinks': u = 'firefox'
						elif u == 'firefox': u = 'custom'
						elif u == 'custom': u = 'lynx'
						mucous_config["mucous"]["url reader"] = u
						self.Mode()
					elif x >=50 and x <=65:
						config_manager.update_config()
						self.mucous.Help.Log("status", "Config Saved")
		except Exception, e:
			self.mucous.Help.Log("debug", "Setup.Mouse: " +str(e) )
		
		
## Search for files
#			
class Search:
	## Constructor
	# @param self Search (class)
	# @param mucous Mucous (class)
	def __init__(self, mucous):
		## @var mucous 
		# Mucous (Class)
		self.mucous = mucous
		## @var logs
		# dict of tickets with lists of results
		self.logs = {}
		## @var windows
		# dict containing instances of curses windows
		self.windows = {}
		## @var dimensions
		# dict containing placement data for windows
		self.dimensions = {}
		## @var sorted_search
		# list of sorted results
		self.sorted_search = None
		## @var sfilter
		# Display results that match this case-insensitive string
		self.sfilter = None
		## @var current
		# Current ticket
		self.current = None
		## @var tickets
		# key is the stringified ticket number; value is the string query
		self.tickets = { }
		## @var results
		# results [ ticket ] [ num ] [ str(ticket), user, free, speed, queue, result[0], result[1], ftype, result[3] ]
		self.results = { }
		## @var numresults
		# dict of tickets with number of search results recieved 
		self.numresults = { }
		## @var viewing
		# list of search results
		self.viewing = []
		## @var scrolling
		# vertical scroll position
		self.scrolling = -1
		## @var order
		# Sorting order (default is by number) :: num, user, free, speed, que, path, sizefile, bitrate, time 
		self.order = "num"
		## @var reverse
		# Reverse sorting
		self.reverse = False
		## @var method
		# Searching method (Global by default)
		self.method = "globally"
		## @var username
		# User to search shares of
		self.username = None
		## @var help
		# Search commands
		self.help = ["Search commands:"] + self.mucous.Help.log["search"] + ["Or, type in the query, below."]
		
	## Create Search window
	# @param self Search (class)
	def Mode(self):
		try:
			self.mucous.mode = "search"
			self.mucous.PopupMenu.show = False
			
			# Cleanup stale windows
			if "query" in self.windows:
				del self.windows["query"]
			if "border" in self.windows:
				del self.windows["border"]
			if "stats" in self.windows:
				del self.windows["stats"]
				
			w = self.dimensions = {"height": self.mucous.h-11, "width": self.mucous.w-2, "top": 5, "left": 1, "start": 0}
			mw = self.windows["border"] = curses.newwin(w["height"]+2, w["width"]+2, w["top"]-1, w["left"]-1)
			mw.attron(self.mucous.colors["green"])
			mw.border()
			mw.attroff(self.mucous.colors["green"])
			try:
				mw.addstr(0, 3, "< Search >",  self.mucous.colors["green"] | curses.A_BOLD)
			except:
				pass
			
			if self.sfilter != None:
				sfilter = "Filter: " +self.sfilter
				
			else:
				sfilter = "Filter: Disabled"
			lfil = len(sfilter)
			mw.addstr(0,15, "< ", self.mucous.colors["green"])
			if self.sfilter != None:
				mw.addstr(0,17, self.mucous.dlang(sfilter), self.mucous.colors["cyan"] | curses.A_BOLD)
			else:
				mw.addstr(0,17, self.mucous.dlang(sfilter), self.mucous.colors["red"] | curses.A_BOLD)
			mw.addstr(0,17+lfil, " >", self.mucous.colors["green"])
			
			self.SortBar()
			tw = self.windows["query"] = mw.subwin(w["height"], w["width"], w["top"], w["left"])
			tw.scrollok(0)
			tw.idlok(1)
			
			self.windows["stats"] = curses.newwin(1, self.mucous.w, self.mucous.h-5, 0)
			self.windows["stats"].erase()
			self.windows["stats"].noutrefresh()
			
			self.Draw()
			
			
			if self.method != None:
				if self.method == "user":
					if self.username != None:
						self.mucous.set_edit_title("Search (Alt-t) "+self.method.capitalize()+" "+self.username+"'s shares")
					else:
						self.mucous.set_edit_title("Search (Alt-t) "+self.method.capitalize()+" (Pick a user with /searchuser)")
				else:
					self.mucous.set_edit_title("Search (Alt-t) "+self.method.capitalize()+" for:")
			
			self.mucous.DrawTabs(self.results.keys(), self.current)

			if self.current != None:
				self.mucous.DrawInstructionsButtons()
				self.mucous.Alerts.Check()
			else:
				self.mucous.HotKeyBar()
			curses.doupdate()
		except Exception,e:
			self.mucous.Help.Log("debug", "Search.Mode: "+str(e))
			
	## New Search Ticket recieved
	# @param self Search (class)
	# @param query string searched for
	# @param ticket unique number associated with search
	def NewTicket(self, query, ticket):
		try:
			self.tickets[str(ticket)] = query
			if self.current == None:
				self.current = str(ticket)
				if self.mucous.mode == "search":
					self.Mode()
					self.Stats("status", "Started search for: %s" % query, str(ticket), 0)
			self.results[str(ticket)] = {}	
			self.numresults[str(ticket)] = 0
		except Exception,e:
			self.mucous.Help.Log("debug", "Search.NewTicket: "+str(e))
			
	## New Search Results recieved
	# @param self Search (class)
	# @param ticket unique number (used to organize results)
	# @param user username of user with results
	# @param free is there a free slot open? (True/False)
	# @param speed average speed of user
	# @param queue length of queue
	# @param results list of files [path, size, extension, list of attributes(bitrate, length, unused)]
	def NewResults(self, ticket, user, free, speed, queue, results):
		try:
			if str(ticket) not in self.tickets:
				return 
			for result in results:
				result_list = []
				# Create Result List for future use 
				# clear it next interation
				# Count Search Result
				path, size, extension, attributes = result 
				num = self.numresults[str(ticket)]
				num += 1
				self.numresults[str(ticket)] = num
				# Send Num of Results to Search Window

				ftype = result[2]
				if ftype in ('', None):
					if result[0][-4:-3] == ".":
						ftype = result[0][-3:]
				ftype = ftype.upper()
				result_list = str(ticket), user, free, speed, queue, path, size, ftype, attributes
				self.results[str(ticket)][num] = result_list
			
			if self.mucous.mode != "search" or self.current != str(ticket):
				if str(ticket) not in self.mucous.Alerts.alert["SEARCH"]:
					self.mucous.Alerts.alert["SEARCH"].append( str(ticket) )
					self.mucous.Alerts.Check()

			if self.current == str(ticket) and  self.mucous.PopupMenu.show != True:
				self.FormatResults(str(ticket))
			else:
				self.Count(num)
				self.mucous.DrawTabs(self.tickets.keys(), self.current)
		except Exception,e:
			self.mucous.Help.Log("debug", "Search.NewResults: "+str(e))
	
	## Get Download from number
	# @param self Search (class)
	# @param num number
	# @return user, path
	def GetDownloadFromNum(self, num):
		try:
			number = int(num)
			if not self.results[self.current].has_key(number):
				self.mucous.Help.Log("debug", "Search.GetDownloadFromNum: No such number")
				return None, None
			user = self.results[self.current][number][1]
			path = self.results[self.current][number][5]
			return user, path
		except Exception,e:
			self.mucous.Help.Log("debug", "Search.GetDownloadFromNum: "+str(e))
	
	## Download Search result 
	# @param self Search (class)
	# @param user Username
	# @param path Path of search result
	# @param getdir If True, Download the directory if False, the file
	def DownloadSearch(self, user, path, getdir=False):
		try:
			if user == None or path == None:
				return
				
			if getdir:
				
				self.mucous.Transfers.FolderDownload(user, path)
			else:
				self.mucous.Transfers.RetryDownload(user, path)
				
			self.mucous.AutobuddyUser(user)
				
				
		except Exception, e:
			self.mucous.Help.Log("debug", "DownloadSearch: " + str(e))
	
	## Draw Sort Bar 
	# @param self Search (class)
	def SortBar(self):
		try:
			w = self.dimensions
			ls = ("Num", "User", "Free", "Speed", "Que", "Path", "Size", "File", "Bitrate", "Time")
			mw = self.windows["border"]
			mw.addstr(w["height"]+1, 1, "<    |    |    |     |   |    |    |    |       |     >", self.mucous.colors["green"])
			pos  = 0
			for i in ls:
				if i == self.order.capitalize():
					mw.addstr(w["height"]+1, 3+pos, self.order.capitalize(), self.mucous.colors["green"]| curses.A_BOLD)
				else:
					mw.addstr(w["height"]+1, 3+pos, i, self.mucous.colors["red"] | curses.A_BOLD)
				pos += len(i) + 1
	
			pos = 56
			mw.addstr(w["height"]+1, pos, "<         >", self.mucous.colors["green"])
			pos = 58
			if self.reverse:
				
				mw.addstr(w["height"]+1, pos, "Reverse", self.mucous.colors["green"]| curses.A_BOLD)
			else:
				mw.addstr(w["height"]+1, pos, "Reverse", self.mucous.colors["red"]| curses.A_BOLD)
	
			mw.noutrefresh()
			
		except Exception,e:
			self.mucous.Help.Log("debug", "Search.SortBar: "+str(e))
			
	## Draw Search Instructions/Help or call Search.FormatResults 
	# @param self Search (class)
	def Draw(self):
		try:
			
			if self.current == None:
				tw = self.windows["query"]
				tw.erase()
				w = self.dimensions
				for lines in self.help:
					try:
						lines, ls = self.mucous.FormatData.StringAddBlanks(lines, w)
						tw.addstr(self.mucous.dlang(lines))
					except Exception, e:
						#self.mucous.Help.Log("debug", e)
						pass
				tw.noutrefresh()
				
			else:
				try:
					if self.mucous.PopupMenu.show == True: raise  Exception,  "popup"
					self.FormatResults(self.current)
				except Exception, e:
					#self.mucous.Help.Log("debug", e)
					pass
			
		except Exception,e:
			self.mucous.Help.Log("debug", "Search.Draw: "+str(e))
	
	## Draw the number of Search results in the Search counter
	# @param self Search (class)
	# @param s string
	def Count(self, s):
		try:
			if self.mucous.logs["search_count"] == ["Results: ", s]:
				return
			self.mucous.logs["search_count"] = "Results: ", s
			ssw = self.mucous.windows["border"]["searchstatus"]
			try:
				ssw.erase()
				ssw.addstr(self.mucous.logs["search_count"][0],  self.mucous.colors["blafgcyabg"] )
				ssw.addstr(str(self.mucous.logs["search_count"][1]),  self.mucous.colors["blafgcyabg"] )
				ssw.refresh()
			except Exception, e:
				pass
				#self.mucous.Help.Log( "debug", "Search Status: " + str(e))
		except Exception, e:
			self.mucous.Help.Log("debug", "Search.Count: " + str(e))
	
	## Clear all search data
	# @param self Search (class)
	def Clear(self):
		try:
			self.tickets = {}
			self.logs = {}
			self.numresults = {}
			self.results = {}
			self.current = None
			self.username = None
			self.Count(0)
			self.Mode()
		except Exception, e:
			self.mucous.Help.Log("debug", "Search.Clear: " + str(e))
	
	## Close Search tab
	# @param self Search (class)
	# @param ticket ticket to be closed 
	def Close(self, ticket):
		try:
			ticket = str(ticket)
			if ticket in self.tickets.keys():
				del self.tickets[ticket]
			if ticket in self.results.keys():
				del self.results[ticket]
			if ticket in self.numresults.keys():
				del self.numresults[ticket]
			if ticket in self.logs:
				del self.logs[ticket]
			if self.tickets.keys() != []:
				self.current = self.tickets.keys()[0]
			else:
				self.current = None
				
			if ticket in self.mucous.Alerts.alert["SEARCH"]:
				self.mucous.Alerts.alert["SEARCH"].remove(ticket)
			self.Mode()
		except Exception, e:
			self.mucous.Help.Log("debug", "Search.Close: " + str(e))
	
	## Format Results for this ticket to fit search window and send them to Search.Stats
	# @param self Search (class)
	# @param this_ticket ticket
	def FormatResults(self, this_ticket):
		if self.mucous.mode != "search":
			return
		try:
			tw = self.windows["query"]
			sorting_list = {}
			if str(this_ticket) not in self.results:
				self.Stats("status", 0, "Empty.....", 0 )
				return
			for numbers, results in self.results[str(this_ticket)].items():
				ticket, user, free, speed, queue, path, size, ftype, extended = results
				if this_ticket == ticket and  self.current == ticket and self.mucous.mode == "search":
					if ftype.upper() in ('MP3', 'OGG'):
						if extended != []:
							bitrate = extended[0]
							time = extended[1]
						else:
							bitrate = 0
							time = 0
					else: 
						bitrate = 0
						time = 0

					if time in ('', None):
						time = 0
					
					if self.order == "num":
						sorting_list[numbers] = 0
					elif self.order == "user":
						sorting_list[numbers] = user
					elif self.order == "free":
						sorting_list[numbers] =  free
					elif self.order == "speed":
						sorting_list[numbers] =  speed
					elif self.order == "que":
						sorting_list[numbers] =  queue
					elif self.order == "path":
						sorting_list[numbers] =  path
					elif self.order == "size":
						sorting_list[numbers] =  size
					elif self.order == "file":
						sorting_list[numbers] =  ftype
					elif self.order == "bitrate":
						sorting_list[numbers] = bitrate
					elif self.order == "time":
						sorting_list[numbers] = time
					
			
			slist = self.mucous.FormatData.sortbyvalue (sorting_list)
			# Filter search while browsing
			if self.sfilter != None:
				s = []
				searchfilter = re.compile('.*' +str(self.sfilter) + '.*', re.DOTALL | re.I)
				for x,y  in slist:
					z =self.results[x]
					for c in (z[1], z[5]) :
						if re.match(searchfilter, c): s.append(x); break
				
				self.sorted_search = s
			else:
				s = []
				for x,y  in slist:
					s.append(x)
				self.sorted_search = s
			if self.reverse == True:
				self.sorted_search.reverse()
			self.logs[str(this_ticket)] = []
			
			clipped_list, self.scrolling, self.dimensions["start"] = self.mucous.FormatData.scrollbox(self.sorted_search, self.scrolling, self.dimensions["height"])
			tw.erase()
			count = 0
			self.viewing = clipped_list
			for number in clipped_list:
				#self.format_this_search(n)
				self.Stats("result", number, str( self.results[this_ticket][number][0] ), count )
				count += 1
				
			
			tw.noutrefresh()
			self.Count(self.numresults[self.current])
			self.mucous.DrawTabs(self.results.keys(), self.current)
			##self.mucous.Help.Log("debug", "Search.Start: " + str(clipped_list))
		except Exception, e:
			self.mucous.Help.Log("debug", "Search.FormatResults: " + str(e))

	## Draw Result and Stats (if it's the current scroll position) 
	# @param self Search (class)
	# @param typer Type of Result (
	# @param result result number
	# @param ticket Ticket
	# @param count Clipped list position
	def Stats(self, typer, result, ticket, count):
		if str(ticket) not in self.logs:
			return
		try:
			if self.mucous.mode != "search":
				return
			if self.current != str(ticket):
				return
			tw = self.windows["query"]
			ss = self.windows["stats"]
			if typer == "status":
				ss.erase()
				ss.addstr(self.mucous.dlang(result), self.mucous.colors["cyan"])
				ss.noutrefresh()
			elif typer == "result":
				number = result
				ticket, user, free, speed, queue, path, size, ftype, extended = self.results[ticket][number]
				size  = self.mucous.FormatData.byte_format(size)

				if ftype.upper() in ('MP3', 'OGG'):
					if extended != []:
						bitrate = extended[0]
						length = int(extended[1])
						minutes = length/60
						seconds = str(length - (60 * minutes))
						
						if len(seconds) < 2:
							seconds = '0' + seconds
					else:
						bitrate = '0'
						minutes = '0'
						seconds = '00'
						length = 0
				else:
					bitrate = '0'
					minutes = '0'
					seconds = '00'
					length = 0
				if free:
					free = 'Y'
				else:
					free = 'N'
		
				
				if count + self.dimensions["start"]== self.scrolling:
					attr =  curses.A_REVERSE | curses.A_BOLD
					attrc = self.mucous.colors["cybg"]| curses.A_BOLD
					ss.erase()

					ss.addstr("F: ")
					atr = self.mucous.colors["cyan"] | curses.A_BOLD
					ss.addstr(free, atr )
					ss.addstr(" | Q:")
					ss.addstr(str(queue), atr )
					ss.addstr(" | ")
					ss.addstr(user[:15], atr )
					ss.addstr(" | ")
					ss.addstr(str(speed/1024), atr )
					ss.addstr("KB/s | Size: ")
					ss.addstr(str(size), atr )
					if bitrate != '0' and length != 0:
						ss.addstr(" | ")
						ss.addstr(str(bitrate), atr )
						ss.addstr("Kbps| Len: ")
						ss.addstr(str(minutes), atr )
						ss.addstr(":")
						ss.addstr(str(seconds), atr )
					ss.refresh()
					
				else:
					attr = curses.A_NORMAL
					attrc = self.mucous.colors["cyan"]
				try:
					extra = ''
					sn = len(str(number))
					sr = len(str(self.numresults[ticket]))
					if sn < sr :
						nub = (" " * (sr - sn)) + str(number)
					else:
						nub = str(number)
						
					f = path.split("\\")
					file = f[-1]
					directory = "\\".join(f[:-1])
					## Shrink directory and file to fit in line
					if len(nub)+2+len(path) >= self.mucous.w-2:
						pos = self.mucous.w-2-len(str(nub)+"| ")-len(directory)-len(file)
						if abs(pos) > len(directory):
							a = abs(pos) - len(directory)
							file = file[:-a]
							directory = ''
						else:
							directory = directory[-pos:]
						

					extra = " " * (self.mucous.w-len(str(nub))- len(directory)-len(file)-4)
					tw.addstr(nub, attrc)
					tw.addch(curses.ACS_VLINE, attr)
					tw.addstr(""+directory+"\\", attr)
					tw.addstr(file, attrc)
					if extra != "":
						tw.addstr(extra, attr)
				except Exception, e:
					pass

		except Exception, e:
			self.mucous.Help.Log("debug", "Search Log: " + str(e))
	
	## Mouse Coordinates in the Search Mode
	# @param self is Search (Class)
	# @param x is the horizontal position from the left
	# @param y is the vertical postion from the top
	# @param z is unimportant
	# @param event is the mouse event (button, doubleclick, etc) represented by a number
	def Mouse(self, x,y,z,event):
		try:
			
			w = self.dimensions
			if self.current != None:
				if y >= w["top"] and y < w["top"] + w["height"] and x >= w["left"] and x < w["left"] +w["width"]:
					#self.mucous.Help.Log("debug", "%d:%d::%d" %(x,y,w["top"]) )
					y1 = y- w["top"]
					
					if y1  + w["start"] in range(self.numresults[self.current]):
						self.scrolling  = y1  + w["start"]
						self.Draw()
						if event in ( 4096, 16384):
							self.mucous.PopupMenu.Create("search", 0, True)
							return

			if y in (1, 2, 3):
				if len(self.tickets.keys()) >= 1:
					
					
					if self.current == None:
						self.current = self.tickets.keys()[0]

					self.current, match = self.mucous.MouseClickTab(x, self.current)	
						
					if match == None:
						s = self.tickets.keys().index(self.current)
						self.current = self.tickets.keys()[s-1]
					self.Mode()

			elif y in ( self.mucous.h-3, self.mucous.h-4):
				if x >= 10 and x <= 20:
					# Toggle type of search
					if self.method == "globally":
						self.method = "buddies"
					elif self.method == "buddies":
						self.method = "rooms"
					elif self.method == "rooms":
						self.method = "globally"
					self.Mode()
					
			elif y in ( self.mucous.h-5, self.mucous.h-6):
				#m< Num|User|Free|Speed|Que|Path|Size|File|Bitrate|Time >< Reverse >

				change = 0
				if x >= 2 and x <= 6 and self.order != "num":
					self.order = "num"
					change = 1
				elif x >= 7 and x <= 11 and self.order != "user":
					self.order = "user"
					change = 1
				elif x >= 12 and x <= 16  and self.order != "free":
					self.order = "free"
					change = 1
				elif x >= 17 and x <= 22  and self.order != "speed":
					self.order = "speed"
					change = 1
				elif x >= 23 and x <= 26  and self.order != "que":
					self.order = "que"
					change = 1
				elif x >= 27 and x <= 31  and self.order != "path":
					self.order = "path"
					change = 1
				elif x >= 33 and x <= 36  and self.order != "size":
					self.order = "size"
					change = 1
				elif x >= 37 and x <= 41  and self.order != "file":
					self.order = "file"
					change = 1
				elif x >= 42 and x <= 49  and self.order != "bitrate":
					self.order = "bitrate"
					change = 1
				elif x >= 50 and x <= 54  and self.order != "time":
					self.order = "time"
					change = 1
				elif x >= 56 and x <= self.mucous.w-10:
					if self.reverse == True:
						self.reverse = False
					elif self.reverse == False:
						self.reverse= True
					change = 1
				elif x >=self.mucous.w-10 and x < self.mucous.w-1:
					self.Close(self.current)
				if change == 1:
					self.Mode()
			
			elif y == 4:
				if self.current != None:
					if x >=self.mucous.w-18:
						self.current=None
						self.Mode()
		except Exception, e:
			self.mucous.Help.Log("debug", "Search.Mouse: " +str(e) )
			
## Transfers (Uploads and Downloads)
#
class Transfers:
	## Constructor
	# @param self Transfers (class)
	# @param mucous Mucous (class)
	def __init__(self, mucous):
		## @var mucous 
		# Mucous (Class)
		self.mucous = mucous
		## @var logs
		# dict containing upload and downloads counters
		self.logs = {"uploads": "Up: 0", "downloads": "Down: 0", }
		## @var windows
		# dict containing instances of curses windows
		self.windows = {"text": {}, "border": {}}
		## @var dimensions
		# dict containing placement data for windows
		self.dimensions = {}
		## @var scrolling
		# dict of uploads and downloads contains the vertical scroll position
		self.scrolling = {"uploads": 0, "downloads": 0}
		## @var sort
		# Sorting method
		self.sort = "all"
		## @var sorted_transfer_list
		# Alphabetically Sorted transfer list, for setting / getting transfer numbers 
		self.sorted_transfer_list = {}
		## @var current
		# Current transfer window
		self.current = "downloads"
		## @var speed
		# Show speed if True, Percent if False
		self.speed = True
		## @var transfers
		# dict of downloads and uploads (ALL transfers) 
		self.transfers = {"downloads": {}, "uploads": {} }
		## @var uploads
		# Status-Limited Uploads
		self.uploads = {}
		## @var downloads
		# Status-Limited Downloads
		self.downloads = {}
		## @var modes
		# the sorting modes for Transfers.sort
		self.modes = ["all","active",  "queued", "finished", "failed"]
		## @var states
		# String associated with transfer states
		self.states = {0: "Finished", 1: "Xferring", 2: "Negotiating", 3:"Waiting", 4: "Establishing", 5: "Initiating", 6: "Connecting",  7: "Queued", 8:"Address", 9:  "Status", 10: "Offline",11: "Closed",12: "Can't Connect", 13: "Aborted",14: "Not Shared"}
		## @var username
		# Upload to this user
		self.username = None
		## @var downloaddirectory
		# directory DownloadTo transfers get downloaded into
		self.downloaddirectory = os.path.expanduser("~/")

	## Create Windows, draw borders :: Call: Transfers.TransferBar and Transfers.UploadManager and Transfers.DownloadManager
	# @param self Transfers (class)
	def ModeTransfers(self):
		self.mucous.mode = "transfer"
		self.mucous.PopupMenu.show = False

		try:
			# Cleanup stale windows
			if "uploads" in self.windows["text"]:
				del self.windows["text"]["uploads"]
			if "uploads" in self.windows["border"]:
				del self.windows["border"]["uploads"]
			if "downloads" in self.windows["text"]:
				del self.windows["text"]["downloads"]
			if "downloads" in self.windows["border"]:
				del self.windows["border"]["downloads"]
				
			if mucous_config["mucous"]["transbox"] == "split":
				
					
				u = self.dimensions["uploads"] = {"height": self.mucous.h/2-4, "width": self.mucous.w-2, "top": 2, "left": 1}
				d = self.dimensions["downloads"] = {"height": self.mucous.h-5-u["height"]-4, "width": self.mucous.w-2, "top": self.mucous.h/2, "left": 1}
				self.DrawTransfersLists("uploads")
				self.DrawTransfersLists("downloads")
				
				# Draw download and upload windows
				uw = self.windows["border"]["uploads"]
				uw.noutrefresh()
				dw = self.windows["border"]["downloads"]
				dw.noutrefresh()
				
				utw = self.windows["text"]["uploads"] = uw.subwin( u["height"], u["width"], u["top"], u["left"])
				utw.scrollok(0)
				utw.idlok(1)
				utw.noutrefresh()
				
				dtw = self.windows["text"]["downloads"] = dw.subwin(d["height"],d["width"], d["top"],d["left"])
				dtw.scrollok(0)
				dtw.idlok(1)
				dtw.noutrefresh()
				
			elif mucous_config["mucous"]["transbox"] == "tabbed":
				if self.current == "uploads":
					# Draw upload window
					u = self.dimensions["uploads"] = {"height": self.mucous.h-7, "width": self.mucous.w-2, "top": 2, "left": 1}
					self.DrawTransfersLists("uploads")
					
					uw = self.windows["border"]["uploads"]
					uw.refresh()
					utw = self.windows["text"]["uploads"] = uw.subwin( u["height"], u["width"], u["top"], u["left"])
					utw.scrollok(0)
					utw.idlok(1)
					utw.noutrefresh()
				else:
					# Draw download window
					d = self.dimensions["downloads"] = {"height": self.mucous.h-7, "width": self.mucous.w-2, "top": 2, "left": 1}
					self.DrawTransfersLists("downloads")

					dw = self.windows["border"]["downloads"]
					dw.refresh()
					# Draw download window
					dtw = self.windows["text"]["downloads"] = dw.subwin(d["height"],d["width"], d["top"],d["left"])
					dtw.scrollok(0)
					dtw.idlok(1)
					dtw.noutrefresh()
			
		except Exception, e:
			self.mucous.Help.Log("debug", "transfer mode: " + str(e))
			
		try:
			self.TransferBar()
						
			self.mucous.set_edit_title("Modify Transfers")
			if mucous_config["mucous"]["transbox"] == "split":
				self.UploadManager()
				self.DownloadManager()
				curses.doupdate()
			else:
				if self.current == "uploads":
					self.UploadManager()
					curses.doupdate()
				if self.current == "downloads":
					self.DownloadManager()
					curses.doupdate()
					
		except Exception, e:
			self.mucous.Help.Log("debug", "transfer panel: " + str(e))


		self.mucous.HotKeyBar()
		curses.doupdate()

		
	## Update Transfer Counters
	# @param self Transfers (class)
	def Status(self):
		if "uploadstatus" in self.windows["border"]:
			del self.windows["border"]["uploadstatus"]
		if "downloadstatus" in self.windows["border"]:
			del self.windows["border"]["downloadstatus"]
		## Upload status window
		usw = 0
		usw = self.windows["border"]["uploadstatus"]  = curses.newwin(1, 10, 0, 25)
		usw.bkgdset(" ", self.mucous.colors["blafgcyabg"]  | curses.A_REVERSE | curses.A_BOLD)
		usw.idlok(1)
		try:
			usw.erase()
			usw.addstr(self.logs["uploads"],  self.mucous.colors["blafgcyabg"] )
		except:
			pass
		usw.noutrefresh()
		
		dsw = self.windows["border"]["downloadstatus"] = curses.newwin(1, 12, 0, 35)
		dsw.bkgdset(" ", self.mucous.colors["blafgcyabg"]  | curses.A_REVERSE | curses.A_BOLD)
		dsw.idlok(1)
		try:
			dsw.erase()
			dsw.addstr(self.logs["downloads"],  self.mucous.colors["blafgcyabg"] )
		except:
			pass
		dsw.noutrefresh()
	## Get Upload user and path from number
	# @param self Transfers
	# @param num number
	# @return username, path 
	def GetUploadFromNum(self, num):
		if num == None:
			return None, None
		if num in self.uploads.keys():
			for username,path in self.uploads[num].items():
				return username, path
		else:
			self.mucous.Help.Log("status", "No such upload #" + str(num))
			return None, None
	## Get Download user and path from number
	# @param self Transfers
	# @param num number
	# @return username, path
	def GetDownloadFromNum(self, num):
		if num == None:
			return None, None
		if num in self.downloads.keys():
			for username,path in self.downloads[num].items():
				return username, path
		else:
			self.mucous.Help.Log("status", "No such download #" + str(num))
			return None, None
		
	## Download a file to the Transfers.downloaddirectory
	# @param self Transfers
	# @param username Username
	# @param path File path 
	def DownloadFileTo(self, username, path):
		if username == None or path == None:
			return
		p = path.split("\\")
		self.mucous.SendMessage(messages.DownloadFileTo(user, path, self.downloaddirectory+"/"+p[-1]))
		self.mucous.Help.Log("status", "Trying to Download: " + path+" from "+ user+"to "+self.downloaddirectory+"/"+p[-1])
		
	## Download a folder
	# @param self Transfers
	# @param username Username
	# @param path Folder path (filename is removed)
	def FolderDownload(self,username, path):
		if username == None or path == None:
			return
		path = path.replace("/", "\\")
		r = path.split('\\')
		r.remove(r[-1])
		directory = ''
		for s in r:
			if s is not r[-1]:
				directory += s + "\\"
			else:
				directory += s
		directory = directory.replace("/", "\\")
		self.mucous.SendMessage(messages.GetFolderContents(username, directory))
		self.mucous.Help.Log("status", "Try to Download directory: %s from %s" % (directory, username))
		
	## Abort a Download
	# @param self Transfers
	# @param username Username
	# @param path File path
	def AbortDownload(self, username, path):
		if username == None or path == None:
			return
		self.mucous.SendMessage(messages.TransferAbort(0, username, path))
		self.mucous.Help.Log("status", "Aborting download: [%s] %s" % (username, path))
		
	## Abort an Upload
	# @param self Transfers
	# @param username Username
	# @param path File path
	def AbortUpload(self, username, path):
		if username == None or path == None:
			return
		self.mucous.SendMessage(messages.TransferAbort(1, username, path))
		self.mucous.Help.Log("status", "Aborting upload: [%s] %s" % (username, path))
		
	## Clear all failed or finished uploads from the transfer manager
	# @param self Transfers
	def ClearAllUploads(self):
		for userpath, values in self.transfers["uploads"].items():
			if values[3] in (0, 10, 11, 12, 13, 14):
				self.mucous.SendMessage(messages.TransferRemove(1, values[1], values[2]))
				
	## Clear all of a user's finished downloads from the transfer manager
	# @param self Transfers
	# @param user Username
	def ClearUserDownloads(self, user):
		for userpath, values in self.transfers["downloads"].items():
			if values[3] == 0:
				self.mucous.SendMessage(messages.TransferRemove(0, values[1], values[2]))
	## Clear all of a user's uploads
	# @param self Transfers
	# @param user Username
	def ClearUserUploads(self, user):
		for userpath, values in self.transfers["uploads"].items():
			if values[3] == 0:
				self.mucous.SendMessage(messages.TransferRemove(0, values[1], values[2]))
	## Remove all finished downloads
	# @param self Transfers
	def ClearAllDownloads(self):
		for userpath, values in self.transfers["downloads"].items():
			if values[3] == 0:
				self.mucous.SendMessage(messages.TransferRemove(0, values[1], values[2]))
				
	## Retry all failed downloads
	# @param self Transfers (Class)
	def RetryAllDownloads(self):
		for user_path, transfer in self.transfers["downloads"].items():
			if int(transfer[3]) in (10, 11, 12, 13, 14):
				self.mucous.SendMessage(messages.DownloadFile(transfer[1], transfer[2]))
	## Retry a Download
	# @param self Transfers
	# @param username Username
	# @param path File path
	def RetryDownload(self, username, path):
		if username == None or path == None:
			return
		path = path.replace("/", "\\")
		self.mucous.SendMessage(messages.DownloadFile(username, path))
		self.mucous.Help.Log("status", "Downloading: [%s] %s" % (username, path))
	## Retry a Upload
	# @param self Transfers
	# @param username Username
	# @param path File path
	def RetryUpload(self, username, path):
		if username == None or path == None:
			return
		path = path.replace("/", "\\")
		self.mucous.SendMessage(messages.UploadFile(username, path))
		self.mucous.Help.Log("status", "Uploading: [%s] %s" % (username, path))
	## Clear a Download
	# @param self Transfers
	# @param username Username
	# @param path File path
	def ClearDownload(self, username, path):
		if username == None or path == None:
			return
		self.mucous.SendMessage(messages.TransferRemove(0, username, path))
		self.mucous.Help.Log("status", "Removing download: [%s] %s" % (username, path))
	## Retry an Upload
	# @param self Transfers
	# @param username Username
	# @param path File path
	def ClearUpload(self, username, path):
		if username == None or path == None:
			return
		self.mucous.SendMessage(messages.TransferRemove(1, username, path))
		self.mucous.Help.Log("status", "Removing upload: [%s] %s" % (username, path))
		
	## Draw the Upload counter with s as the value
	# @param self Transfers
	# @param s string
	def DrawUploadCount(self, s):
		try:
			self.logs["uploads"] = "Up: %s" %str(s)
			usw = self.windows["border"]["uploadstatus"]
			try:
				usw.erase()
				usw.addstr(self.logs["uploads"], self.mucous.colors["blafgcyabg"] )
				usw.refresh()
			except Exception, e:
				self.mucous.Help.Log( "debug", "Upload Status: " + str(e))
		except Exception, e:
			self.mucous.Help.Log("debug", "DrawUploadCount: " + str(e))
	## Draw the Download counter with s as the value
	# @param self Transfers
	# @param s string
	def DrawDownloadCount(self, s):
		try:
			self.logs["downloads"] = "Down: %s" %str(s)
			dsw = self.windows["border"]["downloadstatus"]
			try:
				dsw.erase()
				dsw.addstr(self.logs["downloads"], self.mucous.colors["blafgcyabg"] )
				dsw.refresh()
			except Exception, e:
				self.mucous.Help.Log( "debug", "Download Status: " + str(e))
		except Exception, e:
			self.mucous.Help.Log("debug", "DrawDownloadCount: " + str(e))
	
	## Wrap a green string with < and >
	# @param self Transfers (Class)
	# @param window Curses window instance 
	# @param height vertical position
	# @param pos horizontal position
	# @param string string to be wrapped
	def TArrows(self, window, height, pos, string):
		try:
			window.addstr(height, pos, "< ")
			window.addstr(height, pos+2, string.capitalize(), self.mucous.colors["green"] | curses.A_BOLD)
			window.addstr(height, pos+2+len(string), " >")
		except Exception, e:
			self.mucous.Help.Log("debug", "TArrows: " + str(e))
			
	## Limit list to Transfers.sort method and window height :: Call Transfers.TransferItem
	# @param self Transfers (Class)
	# @param list the transfers list
	# @return list
	def ListCompact(self, list):
		try:
			if self.sort == 'active':
				status_list = (1, 2, 3, 4, 5, 6, 8, 9,)
			elif self.sort == 'all':
				status_list = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14)
			elif self.sort == 'finished':
				status_list = (0, 99999)
			elif self.sort == 'queued':
				status_list = (7, 99999)
			elif self.sort == 'failed':
				status_list = ( 10, 11, 12, 13)
			if list == "downloads":
				self.downloads = {}
			elif list == "uploads":
				self.uploads = {}
			statuslist = []
			statuslist = self.transfers[list].keys()
			statuslist.sort()
			
			self.sorted_transfer_list[list] = statuslist
			num = 0
			filterlist = []
			for user_path in statuslist:
				valid = 1
				num += 1
				transfer, user, path, status, error, filepos, filesize, rate, place = self.transfers[list][user_path]
				username = {}
				username[user] = path
				if list == "downloads":
					self.downloads[num] = username
				else:
					self.uploads[num] = username
				if status not in status_list:
					valid = 0
				if valid:
					filterlist.append([user_path, num])
				
			del statuslist

			clipped_list, self.scrolling[list], self.dimensions[list]["start"] = self.mucous.FormatData.scrollbox(filterlist, self.scrolling[list], self.dimensions[list]["height"]-1)
			del filterlist
			finallist = []
			for user_path, number in clipped_list:
				item = self.TransferItem(list, user_path, number)
				finallist.append(item)
			del clipped_list
			return finallist
		except Exception, e:
			self.mucous.Help.Log("debug", "ListCompact: " + str(e))
			
	## Draw Transfer bar on selected window
	# @param self Transfers (Class)
	def TransferBar(self):
		try:
			s = self.dimensions[self.current ]
			window = self.windows["border"][ self.current ]
			pos = 2
			 
			self.TArrows(window, s["height"]+1, pos, mucous_config["mucous"]["transbox"])
			
			if self.sort == 'all':
				
				pos = 20
				self.TArrows(window, s["height"]+1, pos, self.sort)
			else:
				window.addstr(s["height"]+1, 20, "< All >")

			if self.sort == 'active':
				pos = 28
				self.TArrows(window, s["height"]+1, pos, self.sort)
			else:
				window.addstr(s["height"]+1, 28, "< "+'Active'+" >")

			if self.sort == 'queued':
				pos = 39
				self.TArrows(window, s["height"]+1, pos, self.sort)
			else:
				window.addstr(s["height"]+1, 39, "< "+'Queued'+" >")
			if self.sort == 'finished':
				pos = 50
				self.TArrows(window, s["height"]+1, pos, self.sort)
			else:
				window.addstr(s["height"]+1, 50, "< "+'Finished'+" >")
			if self.sort == 'failed':
				pos = 63
				self.TArrows(window, s["height"]+1, pos, self.sort)
			else:
				window.addstr(s["height"]+1, 63, "< "+'Failed'+" >")
			window.refresh()
		except Exception, e:
			self.mucous.Help.Log("debug", "TransferBar: " + str(e))
			
	## Draw Transfer List Window Border 
	# @param self Transfers (Class)
	# @param window window name (uploads, downloads)
	def DrawTransfersLists(self, window):
		try:
			if self.mucous.mode != "transfer":
				return
			# Cleanup stale windows
			if window in self.windows["border"]:
				del self.windows["border"][window]
			s = self.dimensions[window]
			win = self.windows["border"][window] = curses.newwin(s["height"]+2, s["width"]+2, s["top"]-1, s["left"]-1)
			
			if mucous_config["mucous"]["transbox"] == "tabbed":
				win.attron(self.mucous.colors["green"])
				win.border()
				if window == "uploads":
					uattr = self.mucous.colors["green"] | curses.A_BOLD
					uuattr = self.mucous.colors["green"] | curses.A_BOLD | curses.A_UNDERLINE
					duattr = self.mucous.colors["green"] | curses.A_UNDERLINE
					dattr = self.mucous.colors["green"]
						
					
				elif window == "downloads":
					uattr = self.mucous.colors["green"] 
					uuattr = self.mucous.colors["green"] | curses.A_UNDERLINE
					duattr = self.mucous.colors["green"] | curses.A_BOLD  | curses.A_UNDERLINE
					dattr = self.mucous.colors["green"] | curses.A_BOLD
					
				pos = 3
				win.addstr(0, pos, "<", dattr)
				pos += 1
				u = " Uploading Transfers "
				win.addstr(0, pos, u,  uuattr)
				pos += len(u)
				win.addstr(0, pos, ">", dattr)
				pos += 2
				win.addstr(0, pos, "<", dattr)
				pos += 1
				d = " Downloading Transfers "
				win.addstr(0, pos, d,  duattr)
				pos += len(d)
				win.addstr(0, pos, ">", dattr)
				
			else:
				if self.current == "uploads" and window == "uploads":
					win.attron(self.mucous.colors["green"])
					win.border()
					win.addstr(0, 3, "< Uploading Transfers >", curses.A_BOLD|self.mucous.colors["green"])
				elif self.current == "uploads" and window == "downloads":
					win.border()
					win.addstr(0, 3, "< Downloading Transfers >", curses.A_BOLD)
					
				elif self.current == "downloads" and window == "downloads":
					win.attron(self.mucous.colors["green"])
					win.border()
					win.addstr(0, 3, "< Downloading Transfers >", curses.A_BOLD|self.mucous.colors["green"])
				elif self.current == "downloads" and window == "uploads":
					win.border()
					win.addstr(0, 3, "< Uploading Transfers >", curses.A_BOLD)
				win.addch(0, 29, curses.ACS_TTEE )
				win.addch(0, 29, curses.ACS_TTEE )
				win.addch(0, 40, curses.ACS_TTEE )
				if window == "downloads":
					win.addch(0, 45, curses.ACS_TTEE )
				
	
	
			self.scrolling[self.current] = 0
		except Exception, e:
			self.mucous.Help.Log("debug", "DrawTransfersLists: " + str(e))
			
	## Draw Download List Contents 
	# @param self Transfers (Class)
	def DownloadManager(self):
		try:
			if self.mucous.mode != "transfer":
				return
			if self.current != "downloads" and mucous_config["mucous"]["transbox"] != "split":
				return
			
			dtw = self.windows["text"]["downloads"]
			w = self.dimensions["downloads"]

			finallist = self.ListCompact("downloads")
			s = self.scrolling["downloads"]
			start = self.dimensions["downloads"]["start"]

			try:
				if self.speed == True:
					swting = "Numb","Speed"," Size "," Username ","  Status  "," Que","  Path"
				else:
					swting = "Numb","Perc "," Size "," Username ","  Status  "," Que","  Path"
				
				dtw.erase()
				length = 0
				if self.current == "downloads":
					hattr = self.mucous.colors["green"] | curses.A_REVERSE
					hattr1 = self.mucous.colors["green"]
				else:
					hattr = self.mucous.colors["blafgcyabg"]
					hattr1 = curses.A_NORMAL  
				for i in swting:
					length += len(i)
					dtw.addstr(i, hattr)
					if i is not swting[-1]:
						dtw.addch(curses.ACS_VLINE, hattr1)
						length += 1
				filler = ((self.mucous.w-2 - length) * " ")
				dtw.addstr(filler, hattr)

				
			except:
				pass
			try:
				
				if finallist == []:
					dtw.addstr("\nNo transfers in this category, hit INSERT to switch to another.")
					dtw.noutrefresh()
					return
				count = 0
				for transfers in finallist:
					if transfers == None:
						continue
					
					if transfers[1] == 1:
						sattr = self.mucous.colors["green"] | curses.A_BOLD
					elif transfers[1] == 0:
						sattr = self.mucous.colors["magenta"] | curses.A_BOLD
					elif transfers[1] in (2, 3, 4, 5, 6, 8, 9):
						sattr = self.mucous.colors["yellow"]| curses.A_BOLD
					elif transfers[1] in (10, 11, 12, 13, 14):
						sattr = self.mucous.colors["red"] | curses.A_BOLD
					else:
						sattr = curses.color_pair(0) | curses.A_BOLD
					attr = curses.A_NORMAL
					attr1 = curses.A_NORMAL
					if count + start == s:
						attr = curses.A_REVERSE | curses.A_BOLD
						attr1 = curses.A_NORMAL | curses.A_BOLD
						sattr = curses.A_REVERSE | curses.A_BOLD | sattr

					try:
						dtw.addstr(self.mucous.encode_language(transfers[0])[:4], attr)
						dtw.addch(curses.ACS_VLINE, attr1)
						dtw.addstr(self.mucous.encode_language(transfers[0])[5:10], attr)
						dtw.addch(curses.ACS_VLINE, attr1)
						dtw.addstr(self.mucous.encode_language(transfers[0])[11:17], attr)
						dtw.addch(curses.ACS_VLINE, attr1)
						dtw.addstr(self.mucous.encode_language(transfers[0])[18:28], attr)
						dtw.addch(curses.ACS_VLINE, attr1)
						dtw.addstr(self.mucous.encode_language(transfers[0])[29:39], sattr)
						dtw.addch(curses.ACS_VLINE, attr1)
						dtw.addstr(self.mucous.encode_language(transfers[0])[40:44], attr)
						dtw.addch(curses.ACS_VLINE, attr1)
						dtw.addstr(self.mucous.encode_language(transfers[0])[45:w["width"]], attr)
						
					except :
						pass
					count += 1
			except Exception, e:
				self.mucous.Help.Log("debug", "Download log: " + str(e))
			dtw.noutrefresh()

		except Exception, e:
			self.mucous.Help.Log("debug", "Download Manager: " + str(e))
	## Draw Upload List Contents 
	# @param self Transfers (Class)
	def UploadManager(self):
		try: 
			if self.mucous.mode != "transfer":
				return
			if self.current != "uploads" and mucous_config["mucous"]["transbox"] != "split":
				return

			utw = self.windows["text"]["uploads"]
			w = self.dimensions["uploads"]
			
			finallist = self.ListCompact("uploads")
			s = self.scrolling["uploads"]
			start = self.dimensions["uploads"]["start"]
			try:
				if self.speed == True:
					swting = "Numb","Speed"," Size "," Username ","  Status  ","  Path"
				else:
					swting = "Numb","Perc "," Size "," Username ","  Status  ","  Path"
				utw.erase()
				length = 0
				if self.current == "uploads":
					hattr = self.mucous.colors["green"] | curses.A_REVERSE
					hattr1 = self.mucous.colors["green"]
				else:
					hattr = self.mucous.colors["blafgcyabg"]
					hattr1 = curses.A_NORMAL  
				for i in swting:
					length += len(i)
					utw.addstr(i, hattr)
					if i is not swting[-1]:
						utw.addch(curses.ACS_VLINE, hattr1)
						length += 1
				filler = ((self.mucous.w-2 - length) * " ")
				utw.addstr(filler, hattr)
			except:
				pass
				
			try:
				if finallist == []:
					utw.addstr("\nNo transfers in this category, hit INSERT to switch to another.")
					utw.noutrefresh()
					return
				count = 0
				for transfers in finallist:
					if transfers == None:
						continue
					
					if transfers[1] == 1:
						sattr = self.mucous.colors["green"] | curses.A_BOLD
					elif transfers[1] == 0:
						sattr = self.mucous.colors["magenta"] | curses.A_BOLD
					elif transfers[1] in (10, 11, 12, 13, 14):
						sattr = self.mucous.colors["red"] | curses.A_BOLD
					else:
						sattr = curses.color_pair(0) | curses.A_BOLD
					
					if count + start == s:
						attr = curses.A_REVERSE | curses.A_BOLD
						attr1 = curses.A_NORMAL | curses.A_BOLD
						sattr = curses.A_REVERSE | curses.A_BOLD | sattr
					else:
						attr = curses.A_NORMAL 
						attr1 = curses.A_NORMAL
					try:
						utw.addstr(self.mucous.encode_language(transfers[0])[:4], attr)
						utw.addch(curses.ACS_VLINE, attr1)
						utw.addstr(self.mucous.encode_language(transfers[0])[5:10], attr)
						utw.addch(curses.ACS_VLINE, attr1)
						utw.addstr(self.mucous.encode_language(transfers[0])[11:17], attr)
						utw.addch(curses.ACS_VLINE, attr1)
						utw.addstr(self.mucous.encode_language(transfers[0])[18:28], attr)
						utw.addch(curses.ACS_VLINE, attr1)
						utw.addstr(self.mucous.encode_language(transfers[0])[29:39], sattr)
						utw.addch(curses.ACS_VLINE, attr1)
						utw.addstr(self.mucous.encode_language(transfers[0])[40:w["width"]], attr)

					except:
						pass
					count += 1
					
			except:
				pass
			utw.noutrefresh()
		except Exception, e:
			self.mucous.Help.Log("debug", "Upload Manager: " + str(e))
			
	## Merge transfer stats into a single string
	# @param self Transfers (Class)
	# @param tran transfer string (uploads, downloads)
	# @param user_path tuple (user, path )
	# @param num transfer number
	# @return line, status
	def TransferItem(self, tran, user_path, num):
		try:
			vals = self.transfers[tran][user_path]
			transfer, user, path, status, error, filepos, filesize, rate, place = vals
			path = self.mucous.dlang(path)

			if filesize:
				filefrmt  = self.mucous.FormatData.byte_format(filesize)
				if len(filefrmt) < 6:
					filefrmt = ' ' * (6-len(filefrmt)) + filefrmt

			else:
				percent = '  0'
				filefrmt = '0 Bits'
			n =  ((4 - len(str(num))) * " ") + str(num)
			u =  user[:10] + ((10 - len(user[:10])) * " ")
			if status == 14 :
				cut_status = self.mucous.dlang(error)[:10]
			else:	
				cut_status = self.states[status][:10]
			if len(cut_status) < 10:
				cut_status += (10-len(cut_status)) *" "
			
			if tran == "downloads":
				if place == 4294967295:
					place = ""
				else:
					place = str(place)
				if len(place) < 4:
					cut_place = (" " * (4 -(len(place) )) )+ place
				else:
					cut_place = place[:3] + "~"

			if self.speed == True:
				#Speed
				ratefrmt  = self.mucous.FormatData.byte_format(rate)
				if len(ratefrmt) < 5:
					ratefrmt += ' '* (5-len(ratefrmt))
				
				if tran == "downloads":
					line = "%s|%s|%s|%s|%s|%s|%s" % (str(n), ratefrmt[:5], filefrmt , u, cut_status, cut_place, path[-self.mucous.w+45+2:])
				else:
					line = "%s|%s|%s|%s|%s|%s" % (str(n), ratefrmt[:5], filefrmt , u, cut_status,  path[-self.mucous.w+40+2:])
			else:
				# Percent
				if filesize != 0:
					percent = str(100 * filepos / filesize)
					percent =  ((3 - len(percent)) * " ") + percent
				else: percent = '  0'
				
				if tran == "downloads":
					line = "%s| %s%%|%s|%s|%s|%s|%s" % (str(n), percent[:5] , filefrmt , u, cut_status, cut_place, path[-self.mucous.w+45+2:])
				else:
					line = "%s| %s%%|%s|%s|%s|%s" % (str(n), percent[:5] , filefrmt , u, cut_status,  path[-self.mucous.w+40+2:])
			line += ((self.mucous.w-2 - len(line)) * " ")
			return line, status
		except Exception, e:
			self.mucous.Help.Log("debug", "Transfer Item: "+tran +": " + str(e))

	
	## Mouse Coordinates in the Transfers Modes (Outside windows, on the borders)
	# @param self is Transfers (Class)
	# @param x is the horizontal position from the left
	# @param y is the vertical postion from the top
	# @param z is unimportant
	# @param event is the mouse event (button, doubleclick, etc) represented by a number
	def Mouse(self, x,y,z,event):
		try:
			up = self.scrolling[self.current]
			if mucous_config["mucous"]["transbox"]=="split":
				u = self.dimensions["uploads"]
				d = self.dimensions["downloads"]
				
				w = None
				
				if y >= u["top"]+1 and y <= u["top"] + u["height"] and x >= u["left"] and x < u["left"] +u["width"]:
					if self.current != "uploads":
						self.current = "uploads"
						self.ModeTransfers()
					w = u
					#y -= w["top"]+1
				elif y >= d["top"]+1 and y <= d["top"] + d["height"] and x >= d["left"] and x < d["left"] +d["width"]:
					if self.current != "downloads":
						self.current = "downloads"
						self.ModeTransfers()
					w = d

				if w != None:
					if self.MouseTransferWindow(x, y, z, event, w) == 1:
						return

			else:
				if y == 1:
					if x >=2 and x < 26:
						self.current="uploads"
					elif x >=27 and x < 40:	
						self.current="downloads"
					self.ModeTransfers()
					return
					
				if self.current == "uploads":
					w = self.dimensions["uploads"]
				else:
					w = self.dimensions["downloads"]
				r = self.MouseTransferWindow(x, y, z, event, w)
				if r == 1:
					return	
		except Exception, e:
			self.mucous.Help.Log("debug", "Transfers.Mouse: " +str(e) )
	
	## Mouse Coordinates in a Transfers Window
	# @param self is Transfers (Class)
	# @param x is the horizontal position from the left
	# @param y is the vertical postion from the top
	# @param z is unimportant
	# @param event is the mouse event (button, doubleclick, etc) represented by a number
	# @param w is the curses window
	# @return 0 or 1
	def MouseTransferWindow(self, x, y, z, event, w):
		try:
			if y >= w["top"]+1 and y < w["top"] + w["height"] and x >= w["left"] and x < w["left"] +w["width"]:
							
				y -= w["top"] +1
				if y  + w["start"] in range(len( self.get_transfers_list() )):
					if self.mucous.mode in ("chat", "private", "info", "search", "browse", "transfer"):
						mode = self.current
						self.scrolling[mode] = y  + w["start"]
	
				
				if self.current == "downloads":
					self.DownloadManager()
					curses.doupdate()
				else:
					self.UploadManager()
					curses.doupdate()
				if event in ( 4096, 16384):
					if self.get_transfers_list() != []:
						self.mucous.PopupMenu.Create("transfers", 0, True)
				return 1
			elif y == w["top"] + w["height"]:
				if x >=2 and x < 18:
					if mucous_config["mucous"]["transbox"]=="split":
						mucous_config["mucous"]["transbox"]="tabbed"
					elif mucous_config["mucous"]["transbox"]=="tabbed":
						mucous_config["mucous"]["transbox"]="split"
					self.ModeTransfers()
					return
				elif x >= 20:
					if x >=20 and x < 28:
						self.sort = 'all'
					elif x >=28 and x < 39:
						self.sort = 'active'
					elif x >=39 and x < 50:
						self.sort = 'queued'	
					elif x >=50 and x < 58:
						self.sort = 'finished'
					elif x >=63 and x < 75:
						self.sort = 'failed'
					self.ModeTransfers()
					return 1
			return 0
		except Exception, e:
			self.mucous.Help.Log("debug", "MouseTransferWindow: " + str(e))
			
	## Get the transfer number of the currently selected transfer 
	# @param self is Transfers (Class)
	# @param this_list This lists
	# @return number
	def get_transfer_number(self, this_list):
		try:
			if self.current != "downloads":
				mode = "uploads"
			else:
				mode = "downloads"
			number = None
			username = this_list[self.scrolling[mode]][1] 
			path = this_list[self.scrolling[mode]][2]
			
			userpath = (username, path)
			
			
			count = 1
			transfer = None
			for user, path  in self.sorted_transfer_list[mode]:
				if (user, path) == userpath:
					#transfer = count
					number = count
					break
				count += 1
			return number
		except Exception, e:
			self.mucous.Help.Log("debug", "get_transfer_number: " + str(e))

	## Get the transfer list (status limited to Transfers.sort)  
	#:: format of each item in the list is [upload, username, path, status, error, filepos, filesize, rate] 
	# @param self is Transfers (Class)
	# @return this_list
	def get_transfers_list(self):
		try:
			this_list = []
			
			if self.sort == 'active':
				status_list = (1, 2, 3, 4, 5, 6, 8, 9,)
			elif self.sort == 'all':
				status_list = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,  14)
			elif self.sort == 'finished':
				status_list = (0, 99999)
			elif self.sort == 'queued':
				status_list = (7, 99999)
			elif self.sort == 'failed':
				status_list = (  10, 11, 12, 13)
			if self.current == "uploads":
				
				for username, path in self.sorted_transfer_list["uploads"]:
					vals = self.transfers["uploads"][(username, path)]
					upload, username, path, status, error, filepos, filesize, rate = vals[0], vals[1], vals[2], vals[3], vals[4], vals[5], vals[6], vals[7]
					if status in status_list:
						this_list.append(vals)
						
			elif self.current == "downloads":
				#self.mucous.Help.Log("debug", self.sorted_transfer_list["downloads"])
				for username, path in self.sorted_transfer_list["downloads"]:
					vals = self.transfers["downloads"][(username, path)]
					upload, username, path, status, error, filepos, filesize, rate = vals[0], vals[1], vals[2], vals[3], vals[4], vals[5], vals[6], vals[7]
					if status in status_list:
						this_list.append(vals)
			#this_list.sort(key=str.lower)
			return this_list
		except Exception, e:
			self.mucous.Help.Log("debug", "get_transfers_list: " + str(e))
			



## Private Chat tabs
#			
class PrivateChat:
	## Constructor
	# @param self PrivateChat (class)
	# @param mucous Mucous (class)
	def __init__(self, mucous):
		## @var mucous 
		# Mucous (Class)
		self.mucous = mucous
		## @var current
		# Currently shown user's private chat
		self.current = None
		## @var users 
		# Users whose info we have
		self.users = []
		## @var logs
		# dict of users with lists of old + new chat messages
		self.logs = {}
		## @var windows
		# dict containing instances of curses windows
		self.windows = {}
		## @var dimensions
		# dict containing placement data for windows
		self.dimensions = {}
		## @var scrolling
		# vertical scroll position
		self.scrolling = -1
		
	## Create window & tabs and draw them
	# @param self PrivateChat (class)
	def Mode(self):
		self.mucous.mode = "private"
		self.mucous.PopupMenu.show = False
		try:
			# Cleanup stale windows
			if "text" in self.windows:
				del self.windows["text"]
				
			w = self.dimensions = {"height": self.mucous.h-8, "width": self.mucous.w, "top": 4, "left": 0}

			tw =  self.windows["text"] = curses.newwin(w["height"], w["width"], w["top"], w["left"])				
			
			tw.scrollok(0)
			tw.idlok(1)
			ibw = self.mucous.windows["inputborder"]
			self.scrolling = -1 
			self.Draw()
			if self.current != None:
				self.mucous.set_edit_title("Send message to: " + self.current)
				try:
					blah = None
					if "encoding.users" in self.mucous.config:
						if self.current in self.mucous.config["encoding.users"]:
							blah = self.mucous.config["encoding.users"][self.current]
						else:
							blah = self.mucous.config["encoding"]["network"]
					if blah != None:
						ibw.addstr(0, self.mucous.w-17-len(blah)-4, "<" + (" " *( len(blah) +2) )+  ">")
						ibw.addstr(0, self.mucous.w-17-len(blah)-2, blah, self.mucous.colors["cyan"] | curses.A_BOLD)
					ibw.addstr(0, self.mucous.w-10, "< ")
					ibw.addstr(0, self.mucous.w-8, "Close ", self.mucous.colors["cyan"] | curses.A_BOLD)
					ibw.addstr(0, self.mucous.w-2, ">")
				except:
					pass
				ibw.noutrefresh()
				self.mucous.windows["input"].noutrefresh()
				self.mucous.Alerts.Check()
	
			else:
				self.mucous.set_edit_title("Set a user to Private Message")
				self.mucous.HotKeyBar()
	
			if self.mucous.Alerts.log == "New PM" or self.mucous.Alerts.log[:5] =="PM: ":
				self.mucous.Alerts.setStatus("")
			pmusers = self.logs.keys()
			pmusers.sort(key=str.lower)
			self.mucous.DrawTabs(pmusers, self.current)
			
			
		except Exception, e:
			self.mucous.Help.Log("debug", "PrivateChat.Mode: " +str(e))
		curses.doupdate()
		
	## Close a user's chat
	# @param self PrivateChat (class)
	# @param user username
	def Close(self, user):
		try:
			if user in self.logs.keys():
				del self.logs[user]
			if self.logs.keys() != []:
				for users in self.logs.keys():
					self.current = users
					break
			else:
				self.current = None
			if user in self.mucous.Alerts.alert["PRIVATE"]:
				self.mucous.Alert.alert["PRIVATE"].remove(user)
			if self.mucous.mode == 'private':
				self.Mode()
		except Exception, e:
			self.mucous.Help.Log("debug", "PrivateChat.Close: %s" % str(e))
	
	## Draw chat text
	# @param self PrivateChat (class)
	def Draw(self):
		try:
			scrolltext = "private"
			w = self.dimensions
			tw = self.windows["text"]
			tw.erase()
			if self.current == None:
				# Instructions
				
				for lines in self.mucous.Help.log["private"]:
					try:
						lines, ls = self.mucous.FormatData.StringAddBlanks(lines, w)
						#tw.addstr(self.mucous.dlang(lines))
						tw.addstr(self.mucous.dlang(lines))
					except Exception, e:
						self.mucous.Help.Log("debug", "private display: " + str(e))
				tw.noutrefresh()
				return
					
			# Private chat log
			if self.current not in self.logs:
				tw.noutrefresh()
				return

			listcolors = {}
			wrapped_lines = []
			merged_lines = []
			for timestamp, user, message in self.logs[self.current]:
				message_clean = ""
				for a in message:
					if curses.ascii.isctrl(a):
						a = curses.ascii.unctrl(a)
					message_clean += a
				message = self.mucous.dlang(message_clean)
				if message[:4] == "/me ":
					color = self.mucous.colors['green']
					merged_lines = "%s * %s %s"% (timestamp, user, message[4:]) 
				elif user == '':
					color = self.mucous.colors['cyan']
					merged_lines = "%s %s"% (timestamp, message)
				else:
					color = curses.A_NORMAL
					merged_lines = "%s [%s] %s"% (timestamp, user, message) 
				list_of_strings = self.mucous.FormatData.StringCutWidth(merged_lines, w)
				for line in list_of_strings:
					wrapped_lines.append(line)
					listcolors[line] = color
			if len(self.logs[self.current]):
				del merged_lines
				del list_of_strings
			
			if self.scrolling == -1:
				self.scrolling = len(wrapped_lines)	
			
			clipped_list, self.scrolling, w["start"] = self.mucous.FormatData.scrollbox(wrapped_lines, self.scrolling, w["height"])
			
			
			attrs = curses.A_BOLD #| curses.A_UNDERLINE
			attr = curses.A_NORMAL
			count = 0
			for lines in clipped_list:
				color = listcolors[lines]
				try:
					lines, ls = self.mucous.FormatData.StringAddBlanks(lines, w)
					if count + w["start"] == self.scrolling:
						tw.addstr(self.mucous.dlang(lines), attrs | color )
					else:
						tw.addstr(self.mucous.dlang(lines), attr | color )
					count += 1
				except Exception, e:
					#self.mucous.Help.Log("debug", "private display: " + str(e))
					pass
			tw.noutrefresh()
		except Exception, e:
			self.mucous.Help.Log("debug", "PrivateChat.Draw: " + str(e))
			
	## Recieved a Private Message
	# @param self PrivateChat (class)
	# @param direction 0 == incoming; 1 == outgoing
	# @param timestamp (we use our own)
	# @param user username
	# @param message text
	def Recieved(self,direction, timestamp, user, message):
		try:
			
			ctcpversion = 0
			if message == curses.ascii.ctrl("A")+"VERSION"+curses.ascii.ctrl("A"):
				message = "CTCP VERSION"
				ctcpversion = 1
			
			if user not in self.logs.keys():
				self.logs[user] = []
				if mucous_config["mucous"]["logging"] in ("yes"):
					self.ImportLogs(user)
				
			if mucous_config["mucous"]["logging"] in ("yes"):
				if direction == 0:
					self.mucous.FileLog("private", time.strftime("%d %b %Y %H:%M:%S"), user, "["+user+"]\t"+ message )
				elif direction == 1:
					self.mucous.FileLog("private", time.strftime("%d %b %Y %H:%M:%S"), user, "["+self.mucous.username+"]\t"+ message )
			
			if self.current == None:
				self.current = user
			
			self.Log(direction, user, message)
			
			
				
			if ctcpversion == 1 and direction == 0:
				if mucous_config["mucous"]["extra_requests"] == "Yes":
					self.Send(user, "Mucous %s" % Version)
			
			if self.mucous.mode != "private":
				self.mucous.Alerts.Add(user, "PRIVATE")
				#self.Alerts.setStatus("New PM")
				#if user not in self.Alerts.alert["PRIVATE"]:
					#self.Alerts.alert["PRIVATE"].append(user)
				self.mucous.HotKeyBar()
				self.mucous.Beep()
				
			elif self.mucous.mode == "private" and self.current != user:
				self.mucous.Alerts.Add(user, "PRIVATE")
				self.mucous.HotKeyBar()
				self.mucous.Beep()
				
			if self.current == None:
				self.current = user
				if self.mucous.mode == "private":
					self.Mode()
			elif self.current == user:
				if self.mucous.mode == "private":
					self.Mode()
			elif self.current != user and self.current != None:
				pmusers = self.logs.keys()
				pmusers.sort(key=str.lower)
				self.mucous.DrawTabs(pmusers, self.current)
				#self.mucous.Alerts.setStatus("PM: "+user)
				
			
		except Exception ,e:
			self.mucous.Help.Log("debug", "PrivateChat.Recieved: " + str(e))
			
	## Send Private Message 
	# @param self PrivateChat (class)
	# @param user username
	# @param message text
	def SendEncoded(self, user, message):
		try:
			self.mucous.SendMessage(messages.PrivateMessage(1, user, self.mucous.dencode_language(message)))
		except:
			pass
		
	## Split messages with newlines before sending message 
	# @param self PrivateChat (class)
	# @param user username
	# @param message string
	def Send(self, user, message):
		try:
			#Username is already utf-8ified
			
			lang = mucous_config["mucous"]["language"]
			if '\\n' in message:
				
				splited =  message.split('\\n')
				if len(splited) > 7:
					for i in range(8):
						self.SendEncoded(user, splited[i])
				else:
					for i in range(len(splited)):
						self.SendEncoded(user,  splited[i])
				

			elif '\n' in message:
				splited =  message.split('\n')
				
				if len(splited) > 5:
					for i in range(5):
						self.SendEncoded(user,  splited[i])
				else:
					for i in range(len(splited)):
						self.SendEncoded(user,  splited[i])
			else:
				self.SendEncoded(user, message)
		
			if message == curses.ascii.ctrl("A")+"VERSION"+curses.ascii.ctrl("A"):
				message = "CTCP VERSION"
			if mucous_config["mucous"]["logging"] in ("yes"):
				self.mucous.FileLog("private", time.strftime("%d %b %Y %H:%M:%S"), user, "["+self.mucous.username+"]\t" +message )
			#pmtype = "outgoing"
			self.Log(1, user, message)
			
			if self.mucous.Alerts.log == "New PM":
				self.mucous.Alerts.setStatus("")
				
			if self.current == None:
				self.current = user
				if self.mucous.mode == "private":
					self.Mode()
			elif self.current == user:
				if self.mucous.mode == "private":
					self.Mode()
			elif self.current != user and self.current != None:
				pmusers = self.logs.keys()
				pmusers.sort(key=str.lower)
				self.mucous.DrawTabs(pmusers, self.current)
				
		except Exception ,e:
			self.mucous.Help.Log("debug", "PrivateChat.Send: " + str(e))
			
			
	## Split messages with newlines before sending message 
	# @param self PrivateChat (class)
	# @param user username
	def Start(self, user):
		try:
			self.current = user
			if user not in self.logs.keys():
				self.logs[user] = []
				if mucous_config["mucous"]["logging"] in ("yes"):
					self.ImportLogs(user)
				
			if self.mucous.mode == 'private':
				self.Mode()
		except Exception, e:
			self.mucous.Help.Log("debug", "PrivateChat.Start: " + str(e))
			
	## Append Private Message to Chat Log
	# @param self PrivateChat (class)
	# @param direction 0 == incoming; 1 == outgoing
	# @param user username
	# @param message text
	def Log(self, direction, user, message):
		try:
			timestamp = time.strftime("%H:%M:%S")
			if user not in self.logs.keys():
				self.logs[user]=['']
	
			if message[:4] == "/me ":
				if direction:
					self.logs[user].append([timestamp, self.mucous.username,  message])
				else:
					self.logs[user].append([timestamp, user, message])
			else:
				
				if direction:
					self.logs[user].append([timestamp, self.mucous.username, message])
				else:
					self.logs[user].append([timestamp, user, message])
					
			
				
		except Exception, e:
			self.mucous.Help.Log( "debug", "PrivateChat.Log: " + str(e))
			
	## Read old Logfiles and import them to the chat log
	# @param self PrivateChat (class)
	# @param username username
	def ImportLogs(self, username):
		try:
			# Read from Private Chat Logs
			if "\\" in username: username = username.replace("/", "\\")
			if os.path.exists(os.path.expanduser(mucous_config["mucous"]["log_dir"])+"/private"+"/"+username):
				path = os.path.expanduser(mucous_config["mucous"]["log_dir"])+"/private"+"/"+username
				f = open(path, "r")
				a = f.read()
				f.close()
				lines = a.split("\n" )
				numlines = -30
				if len(lines) <= abs(numlines):
					numlines = 0
				for line in lines[numlines:]:
					if line == "":
						continue
					timex = line[12:20]
					user = line[22:]
					if line.find("\t") == -1:
						# old format
						user = user[:user.find("]")]
						message = line[21+len(user)+3:]
					else:
						# new format with Tab
						user = user[:user.find("\t")-1]
						message = line[line.find("\t")+1:]
						
					self.logs[username].append([timex, user, message])
				
				self.logs[username].append([time.strftime("%H:%M:%S"), "", "------ Old Chat Above ------"])
		except Exception,e:
			self.mucous.Help.Log("debug", "PrivateChat.ImportLogs: " +str( e) )
	## Mouse Coordinates in the Private Chat Mode
	# @param self is PrivateChat (class)
	# @param x is the horizontal position from the left
	# @param y is the vertical postion from the top
	# @param z is unimportant
	# @param event is the mouse event (button, doubleclick, etc) represented by a number
	def Mouse(self, x,y,z,event):
		try:
			if self.current == None:
				return
			if y in (2, 3, 4):
				if len(self.logs.keys()) > 1:
					pmusers =  self.logs.keys()
					pmusers.sort(key=str.lower)
					self.current, match = self.mucous.MouseClickTab(x, self.current)
					if match == None:
						s = pmusers.index(self.current)
						self.current = pmusers[s-1]
					self.Start(self.current)
					self.Mode()
					
			if y == self.mucous.h-3 or y == self.mucous.h-4:
				if x>= self.mucous.w-27 and x < self.mucous.w-18:
					self.mucous.PopupMenu.Create("encoding", 0, True)
				elif x >=self.mucous.w-10 and x < self.mucous.w-1:
					self.Close(self.current)
		except Exception, e:
			self.mucous.Help.Log("debug", "PrivateChat.Mouse: " +str(e) )
			
## Driver handle
## @param driver Museek driver bindings
class Networking(driver.Driver):
	## Constructor
	# @param self Networking (Driver Class)
	# @param mucous Mucous (Class)
	def __init__(self, mucous):
		driver.Driver.__init__(self)
		## @var mucous
		# Mucous (Class)
		self.mucous = mucous
		
	## Connect to museekd, password, a museekd socket need to be set
	# @param self Networking (Driver Class)
	# If mucous cannot connect, enter a loop which allows commands to be inputted
	def connect(self):
		try:
			keys = []
			
			while 1:
				
				try:
					if not self.mucous.invalidpass:
						if mucous_config["connection"]["passw"] != None:
							
							self.mucous.NickTimer.cancel()
							self.mucous.NickTimer = threading.Timer(10.0, self.mucous.ThreadNickCheck)
							self.mucous.NickTimer.start()
							driver.Driver.connect(self, mucous_config["connection"]["interface"],  mucous_config["connection"]["passw"], messages.EM_CHAT |  messages.EM_USERINFO| messages.EM_PRIVATE| messages.EM_TRANSFERS  | messages.EM_USERSHARES | messages.EM_CONFIG |  messages.EM_INTERESTS) 
							
							break
						else:
							raise Exception,  "IdASS"
					else:
						raise Exception,  "INVPASS"
						
	
				except Exception, e:
					self.mucous.mode = "debug"
					self.mucous.Help.Mode()
					if self.mucous.NickTimer != None:
						self.mucous.NickTimer.cancel()
					if e == "INVPASS":
						self.mucous.Help.Log("status", "Incorrect Password, try another.")
					elif e == [111, "Connection refused"]:
						self.mucous.Help.Log("status", e[1] +", make sure the daemon is running, or change the interface.")
					self.mucous.Help.Log("debug", "Connection failed, try changing your interface or password")
					for lines in self.mucous.Help.log["connect"]:
						self.mucous.Help.Log("status", lines)
					q = "42"
					while q == "42":
						# Run Commands while offline
						sleep(0.01)
						try:
							c = self.mucous.stdscr.getkey(self.mucous.h-3, self.mucous.edit.length+1)
							keys.append(c)
						except:
							pass
	
						while keys:
							c, keys = keys[0], keys[1:]
							
							try:
								if self.mucous.edit.process(c):
									line = self.mucous.edit.line
									yes = self.mucous.InputCommands(line)
									
									if yes == 0:
										q = 33
										break
									elif yes == 2:
										return
									else:
										self.mucous.edit.reset()
							except:
								pass
					break
		except Exception, e:
			self.mucous.Help.Log("debug", "Connect "+str( e) )
			
	## Recieve Messages from Museekd and collect new key presses
	# @param self Networking (Driver Class)
	def process(self):

		keys = []
		
		while 1:
			try:
				c = self.mucous.stdscr.getkey(self.mucous.h-3, self.mucous.edit.length+1)
		
				keys.append(c)
			except:
				pass

			if not keys:
				d = 1000
			else:
				d = 0
			if self.socket != None:
				r, w, x = select.select([self.socket, sys.stdin], [], [self.socket], d)
				
			else:
				sleep(0.01)
			if self.socket in r:
				driver.Driver.process(self)

			if sys.stdin in r:
				try:
					c = self.mucous.stdscr.getkey(self.mucous.h-3, self.mucous.edit.length+1)
					keys.append(c)
					
				except Exception, e:
					pass
			while keys:
				
				c, keys = keys[0], keys[1:]
				try:
					
					if self.mucous.edit.process(c):
						self.mucous.line = self.mucous.edit.line
						yes = self.mucous.InputCommands(self.mucous.line)
						
						if yes == 0:
							break
						elif yes == 2:
							# Exit
							return
						else:
							self.mucous.edit.reset()
							
				except Exception, e:
					self.mucous.Help.Log("debug", "Processing... " + str(e))
 		
	## Recieved Ping from museekd
	# @param self Networking (Driver Class)
	def cb_ping(self):
		self.mucous.Help.Log("debug", "Recieved ping from daemon...")
		
	## Recieved Login Error from museekd
	# @param self Networking (Driver Class)
	# @param reason is a string containing the reason for login failure
	def cb_login_error(self, reason):
		try:
			self.mucous.Spl["connected"] = 0
			if reason == "INVPASS":
				self.mucous.invalidpass = True
				self.mucous.Help.Log("status", "couldn't log in: Invalid Password")
				self.connect()
			else:
				self.mucous.invalidpass = False
				self.mucous.Help.Log("status", "couldn't log in: " + reason)
		except Exception,e:
			self.mucous.Help.Log("debug", "cb_login_error: " + str(e))
			
	## Recieved Login Okay from museekd
	# @param self Networking (Driver Class)
	def cb_login_ok(self):
		try:
			self.mucous.invalidpass = False
			self.mucous.Spl["connected"] = 1
			self.mucous.Help.Log("status", "Logging into Museek at "+ mucous_config["connection"]["interface"])
			self.mucous.timeout_timer = threading.Timer(self.mucous.timeout_time, self.mucous.AwayTimeout)
			self.mucous.timeout_timer.start()
		except Exception,e:
			self.mucous.Help.Log("debug", "cb_login_ok: " + str(e))
		
	## Museekd notified that we are disconnected
	# @param self Networking (Driver Class)
	def cb_disconnected(self):
		try:
			if self.mucous.Spl["connected"] == 1:
				try:
					driver.Driver.close(self)
				except:
					pass
			self.mucous.Spl["connected"] = 0
			self.mucous.logs["onlinestatus"]="Closed"
			self.mucous.Muscan.timer.cancel()
			self.mucous.NickTimer.cancel()
			self.mucous.ticker_timer.cancel()
			self.mucous.retry_timer.cancel()
			self.mucous.clear_timer.cancel()
			self.mucous.timeout_timer.cancel()
			
			osw = self.mucous.windows["border"]["onlinestatus"]
			osw.erase()
			osw.addstr(self.mucous.logs["onlinestatus"], self.mucous.colors["red"] | curses.A_BOLD |curses.A_REVERSE)
			osw.refresh()

			
			for room in self.mucous.ChatRooms.rooms.keys():
				msg = ("--- Disconnected from the Museek Daemon ---")
				self.mucous.ChatRooms.AppendChat("Status", room, '!!!!', msg)
				self.mucous.ChatRooms.rooms[room] = {}
				self.mucous.ChatRooms.tickers[room] = {}
			uploadlist = []
			self.mucous.Transfers.uploads = {}
			self.mucous.Transfers.downloads = {}
			self.mucous.Transfers.transfers["downloads"] = {}
			self.mucous.Transfers.transfers["uploads"] = {}
			self.mucous.config = {}
			

			if self.mucous.mode == "chat":
				self.mucous.ChatRooms.Mode()
			elif self.mucous.mode == "transfer":
				self.mucous.Transfers.ModeTransfers()
			self.mucous.TerminalTitle()
			self.mucous.Transfers.DrawUploadCount("0")
			self.mucous.Transfers.DrawDownloadCount("0")

			self.mucous.refresh_windows()
		except Exception,e:
			self.mucous.Help.Log("debug", "cb_disconnected: " + str(e))
			
	## Museekd sent us a status message
	# @param self Networking (Driver Class)
	# @param type is a bool; False if the message relates to the Server / True for Peer
	# @param message is the message string
	def cb_status_message(self, type, message):
		try:
			if type == 1:
				stype = "Peer"
			elif type == 0:
				stype = "Server"
			self.mucous.Help.Log("status", "%s Message: %s" % (stype, message))
		except Exception,e:
			self.mucous.Help.Log("debug", "cb_status_message: " +str( e) )
				
	## Museekd sent us the server state and our username
	# @param self Networking (Driver Class)
	# @param state is a bool; False if disconnected from the server / True if connected
	# @param username is a string
	def cb_server_state(self, state, username):
		try:
			self.mucous.username = username
			un = self.mucous.windows["border"]["username"]
			osw = self.mucous.windows["border"]["onlinestatus"]
			un.erase()
			un.addstr(self.mucous.dlang(self.mucous.username[:15]), self.mucous.colors["blafgcyabg"] )
			un.refresh()
		
			self.mucous.Transfers.DrawUploadCount("0")
			self.mucous.Transfers.DrawDownloadCount("0")
			self.mucous.Search.Count(0)
		
			if state:
# 				self.mucous.Help.Log("status", "Connected to Server, username: " + username)
				
				self.mucous.logs["onlinestatus"]="Online"
				
	
				if self.mucous.ChatRooms.rooms.keys():
					for room in self.mucous.ChatRooms.rooms.keys():
						msg = ("--- Connected ---")
						self.mucous.ChatRooms.AppendChat("Status", room, '!!!!', msg)
				
			else:
				self.mucous.Help.Log("status", "Museek is not connected to Soulseek")
	
				self.mucous.logs["onlinestatus"]="Offline"
				
				
	
				if self.mucous.ChatRooms.rooms.keys():
					for room in self.mucous.ChatRooms.rooms.keys():
						msg = ("--- Disconnected from the Server ---")
						self.mucous.ChatRooms.AppendChat("Status", room, '!!!!', msg)
				uploadlist = []
				self.mucous.Transfers.uploads = {}
				self.mucous.Transfers.transfers["downloads"] = {}
				self.mucous.Transfers.transfers["uploads"] = {}
				for room in self.mucous.ChatRooms.rooms.keys():
					self.mucous.ChatRooms.rooms[room] = []
				if self.mucous.mode == "chat":
					self.mucous.ChatRooms.Mode()
				elif self.mucous.mode == "transfer":
					self.mucous.Transfers.ModeTransfers()

			osw.erase()
			osw.addstr(self.mucous.dlang(self.mucous.logs["onlinestatus"]), self.mucous.colors["blafgcyabg"] )
			osw.refresh()
			
		except Exception,e:
			self.mucous.Help.Log("debug", "cb_server_state: " +str( e) )
		self.mucous.TerminalTitle()
		
	## Time left of server privileges
	# @param self Networking (Driver Class)
	# @param time_left Seconds of privileges left
	def cb_server_privileges(self, time_left):
		try: 
			time = time_left
			hours_i = time/3600
			minutes_i = time/60
			seconds_i = time - (60 * minutes_i)
			if minutes_i > 59:
				minutes_i = time/60 - (60 * hours_i)
				
			days = hours_i/24
			hours = hours_i - (days*24)
			if time:
				stime = 'You have %d Days, %2.2d:%2.2d:%2.2d of privileges left' % (days, hours, minutes_i, seconds_i)
			else:
				stime = 'You have no global privileges.'
			self.mucous.Help.Log("status", stime)
		except Exception,e:
			self.mucous.Help.Log("debug", "cb_server_privileges: " +str( e) )
		
	## Recieved Room List
	# @param self Networking (Driver Class)
	# @param roomlist dict of [rooms][users][stats]
	def cb_room_list(self, roomlist):
		try:
			for name in  roomlist:
				alpha_list[name] = roomlist[name]
			
			self.mucous.RoomsList.rooms = {}
			
			for x, y in alpha_list.items():
				self.mucous.RoomsList.rooms[x] = y
				
			if self.mucous.mode=="roomlist":
				self.mucous.RoomsList.Mode()
		except Exception, e:
			self.mucous.Help.Log("debug", "CB Room List" + str(e))
			
	## Got Global Recommendations
	# @param self Networking (Driver Class)
	# @param recommendations list of recommendations [item, number of recommends] 
	def cb_get_global_recommendations(self, recommendations):
		try:
			self.mucous.Recommendations.data["recommendations"] = SortedDict()
			for rec, num in recommendations.items():
				self.mucous.Recommendations.data["recommendations"] [rec] = num
			if self.mucous.mode == "lists" and self.mucous.UsersLists.current == "interests":
				self.mucous.Recommendations.DrawInterests()
		except Exception, e:
			self.mucous.Help.Log("debug", "CB Get Global Recommendations" + str(e))
	
	## Got Similar Users list
	# @param self Networking (Driver Class)
	# @param users List of format [username, status=(0,1,2)]
	def cb_get_similar_users(self, users):
		try:
			
			self.mucous.Recommendations.data["similar_users"] = SortedDict()
			for rec, num in users.items():
				self.mucous.Recommendations.data["similar_users"][rec] = num
			if self.mucous.mode == "lists" and self.mucous.UsersLists.current == "interests":
				self.mucous.Recommendations.DrawInterests()
		except Exception, e:
			self.mucous.Help.Log("debug", "CB Similar Users" + str(e))
	
	## Got Personal Recommendations
	# @param self Networking (Driver Class)
	# @param recommendations list of recommendations [item, number of recommends]
	def cb_get_recommendations(self, recommendations):
		try:
			self.mucous.Recommendations.data["recommendations"] = SortedDict()
			for rec, num in recommendations.items():
				self.mucous.Recommendations.data["recommendations"] [rec] = num
			if self.mucous.mode == "lists" and self.mucous.UsersLists.current == "interests":
				self.mucous.Recommendations.DrawInterests()
		except Exception, e:
			self.mucous.Help.Log("debug", "CB Get  Recommendations" + str(e))
	
	## Got Similar Users list for an Item
	# @param self Networking (Driver Class)
	# @param item string
	# @param users List of format [username, status=(0,1,2)]
	def cb_get_item_similar_users(self, item, users):
		try:
			self.mucous.Recommendations.data["similar_users"] = SortedDict()
			for rec, num in users.items():
				self.mucous.Recommendations.data["similar_users"][rec] = num
			if self.mucous.mode == "lists" and self.mucous.UsersLists.current == "interests":
				self.mucous.Recommendations.DrawInterests()
		except Exception, e:
			self.mucous.Help.Log("debug", "CB Item Similar Users" + str(e))
	
	## Got Recommendations for an Item
	# @param self Networking (Driver Class)
	# @param item string
	# @param recommendations list of recommendations [item, number of recommends]
	def cb_get_item_recommendations(self, item, recommendations):
		try:

			self.mucous.Recommendations.data["recommendations"] = SortedDict()
			for rec, num in recommendations.items():
				self.mucous.Recommendations.data["recommendations"] [rec] = num
			if self.mucous.mode == "lists" and self.mucous.UsersLists.current == "interests":
				self.mucous.Recommendations.DrawInterests()
		except Exception, e:
			self.mucous.Help.Log("debug", "CB Get Item Recommendations" + str(e))

	## Someone said something in a Chat Room
	# @param self Networking (Driver Class)
	# @param room Chat Room
	# @param user Username
	# @param text message
	def cb_room_said(self, room, user, text):
		try:
			#text = text.replace('\n', " ").replace('\t', "     ")
			text = text.replace('\t', "     ")
			
			
	
			if text[:4] == "/me ":
				self.mucous.ChatRooms.AppendChat("Me", room, user, text[4:])
				if self.mucous.username in text[4:]:
					if self.mucous.mode != "chat":
						self.mucous.Alerts.setStatus(room)
						
						self.mucous.Alerts.alert["CHAT"][room] = "nick"
						self.mucous.Beep()
					elif self.mucous.mode == "chat" and self.mucous.ChatRooms.current != room:
						self.mucous.Alerts.setStatus(room[:14])
						self.mucous.Alerts.alert["CHAT"][room] = "nick"
						self.mucous.Beep()
					
				else:
					if self.mucous.mode != "chat":
						self.mucous.Alerts.setStatus("%s" % room)
						if room not in self.mucous.Alerts.alert["CHAT"]:
							self.mucous.Alerts.alert["CHAT"][room] = "normal"
					elif self.mucous.mode == "chat" and self.mucous.ChatRooms.current != room:
						self.mucous.Alerts.setStatus(room)
						if room not in self.mucous.Alerts.alert["CHAT"]:
							self.mucous.Alerts.alert["CHAT"][room] = "normal"
			else:
				if self.mucous.username in text:
					self.mucous.ChatRooms.AppendChat("Mentioned", room, user, text)
					if self.mucous.mode != "chat":
						self.mucous.Alerts.setStatus(room)
						self.mucous.Beep()
						self.mucous.Alerts.alert["CHAT"][room] = "nick"
					elif self.mucous.mode == "chat" and self.mucous.ChatRooms.current != room:
						self.mucous.Alerts.setStatus(room)
						self.mucous.Beep()
						self.mucous.Alerts.alert["CHAT"][room] = "nick"
	
				else:
					self.mucous.ChatRooms.AppendChat("Normal", room, user, text)
					if self.mucous.mode != "chat":
						self.mucous.Alerts.setStatus( room)
						if room not in self.mucous.Alerts.alert["CHAT"]:
							self.mucous.Alerts.alert["CHAT"][room] = "normal"
	
					elif self.mucous.mode == "chat" and self.mucous.ChatRooms.current != room:
						self.mucous.Alerts.setStatus(room)
						if room not in self.mucous.Alerts.alert["CHAT"]:
							self.mucous.Alerts.alert["CHAT"][room] = "normal"
			self.mucous.HotKeyBar()
						
			if mucous_config["mucous"]["logging"] == "yes":
				message = "[%s]\t%s" % (user, text)
				self.mucous.FileLog("rooms", time.strftime("%d %b %Y %H:%M:%S"), room, message )
		except Exception, e:
			self.mucous.Help.Log("debug", "CB Room Said" + str(e))
	
	## Recieved Room state 
	# @param self Networking (Driver Class)
	# @param roomlist Dict of rooms and the number of users in them
	# @param joinedrooms Dict of Rooms we have joined
	# @param tickers Dict of tickers [room][user] = ticker 
	def cb_room_state(self, roomlist, joinedrooms, tickers):
		try:
			for rooms1, numbers in roomlist.items():
				self.mucous.RoomsList.rooms[rooms1] = numbers
			
			for room in joinedrooms:
				self.mucous.ChatRooms.Joined(room, joinedrooms[room], tickers[room])
			
			joined = self.mucous.ChatRooms.rooms.keys()
			joined.sort(key=str.lower)
			
			if joined == []:
				return
			
			if mucous_config["rooms"]["default_room"] != None:
				if mucous_config["rooms"]["default_room"] in joined:
					self.mucous.ChatRooms.current = mucous_config["rooms"]["default_room"]
					self.mucous.ChatRooms.Change(mucous_config["rooms"]["default_room"])
				else:
					self.mucous.ChatRooms.JoinRoom(mucous_config["rooms"]["default_room"])
					self.mucous.ChatRooms.Change(joined[0])

			else:
				self.mucous.ChatRooms.current = joined[0]
				self.mucous.ChatRooms.Change(joined[0])

		except Exception, e:
			self.mucous.Help.Log("debug", "CB Room state" + str(e))
				
	## We Joined a room
	# @param self Networking (Driver Class)
	# @param room Room name
	# @param users Dict of users in the room
	def cb_room_joined(self, room, users):
		try:
			self.mucous.ChatRooms.Joined(room, users)
			#self.mucous.ChatRooms.tickers[room] = {}
			#if room not in self.mucous.ChatRooms.logs["rooms"]:
				#self.mucous.ChatRooms.logs["rooms"][room] = []
				#self.mucous.ChatRooms.logs["roomstatus"][room] = []
				#self.mucous.ChatRooms.OldLogs(room)
				
			#for users, stats in list_of_users.items():
				#self.mucous.user["statistics"][users] = stats[1], stats[2 ], stats[3], stats[4] #avgspeed, numdownloads, numfiles, numdirs
				#self.mucous.user["status"][users] = stats[0] # online status
			
			#self.mucous.ChatRooms.rooms[room] = list_of_users.keys()
			if self.mucous.ChatRooms.current == None or self.mucous.ChatRooms.current == room:
				self.mucous.ChatRooms.Change(room)
			curses.doupdate()
		except Exception, e:
			self.mucous.Help.Log("debug", "CB Room Joined: " + str(e))
			
	## We left a room
	# @param self Networking (Driver Class)
	# @param room Room name
	def cb_room_left(self, room):
		try:
			self.mucous.ChatRooms.Left(room)	
		except Exception, e:
			self.mucous.Help.Log("debug", "CB Room Left" + str(e))
			
	## A user joined a room we are in
	# @param self Networking (Driver Class)
	# @param room Room name
	# @param user User name
	# @param data status, speed, downloads, files, dirs, other
	def cb_room_user_joined(self, room, user, data):
		try:
			status, speed, downloads, files, dirs, other = data 
			s = self.mucous.ChatRooms.dimensions["chat"]
			did = "join"
			what = data
			if self.mucous.config !=  {}: 
				if "ignored" in self.mucous.config.keys(): 
					if user not in self.mucous.config["ignored"].keys():
						self.mucous.ChatRooms.AppendStatus(user, room, did, what)
			if user not in self.mucous.ChatRooms.rooms[room]:
				self.mucous.ChatRooms.rooms[room].append(user)
			self.mucous.user["statistics"][user] = speed, downloads, files, dirs
			self.mucous.user["status"][user] = status
			# correct placement in roombox
			
			if self.mucous.mode == "chat" and self.mucous.ChatRooms.current == room:
				if self.mucous.ChatRooms.selected  == "roombox":
					self.mucous.ChatRooms.rooms[room].sort(key=str.lower)
					if self.mucous.ChatRooms.rooms[room].index(user) < self.mucous.ChatRooms.scrolling[self.mucous.ChatRooms[self.mucous.selected]]:
						self.mucous.ChatRooms.scrolling[self.mucous.ChatRooms[self.mucous.selected]] += 1

				self.mucous.ChatRooms.DrawBox()
				for lines in self.mucous.ChatRooms.logs["rooms"][self.mucous.ChatRooms.current][ len(self.mucous.ChatRooms.logs["rooms"][self.mucous.ChatRooms.current]) - s["height"]:]:
					# Update Chat history if user changes status
					if lines[2] == user:
						self.mucous.ChatRooms.Change(self.mucous.ChatRooms.current)
						break
				curses.doupdate()
		except Exception, e:
			self.mucous.Help.Log("debug", "CB Room User Joined" + str(e))
			
	## A user left a room we are in
	# @param self Networking (Driver Class)
	# @param room Room name
	# @param user User name
	def cb_room_user_left(self, room, user):
		try:
			did = "left"
			what = None
			if self.mucous.config !=  {}: 
				if "ignored" in self.mucous.config.keys(): 
					if user not in self.mucous.config["ignored"].keys():
						self.mucous.ChatRooms.AppendStatus(user, room, did, what)
			# correct placement in roombox
			if  self.mucous.mode == "chat" and self.mucous.ChatRooms.selected  == "roombox":
				self.mucous.ChatRooms.rooms[room].sort(key=str.lower)
				if self.mucous.ChatRooms.rooms[room].index(user) < self.mucous.ChatRooms.scrolling[self.mucous.ChatRooms.selected]:
					self.mucous.ChatRooms.scrolling[self.mucous.ChatRooms.selected] -= 1
			if user in self.mucous.ChatRooms.rooms[room]:
				self.mucous.ChatRooms.rooms[room].remove(user)
			if room in self.mucous.ChatRooms.tickers:
				if user in self.mucous.ChatRooms.tickers[room]:
					del self.mucous.ChatRooms.tickers[room][user]
			if self.mucous.mode == "chat" and self.mucous.ChatRooms.current == room:
				self.mucous.ChatRooms.DrawBox()
				for lines in self.mucous.ChatRooms.logs["rooms"][room][len(self.mucous.ChatRooms.logs["rooms"][self.mucous.ChatRooms.current]) - self.mucous.ChatRooms.dimensions["chat"]["height"]:]:
					# Update Chat history if user changes status
					if lines[2] == user:
						self.mucous.ChatRooms.Change(room)
						break
				curses.doupdate()
		except Exception, e:
			self.mucous.Help.Log("debug", "CB Room User Left" + str(e))
			
	## A user's status changed
	# @param self Networking (Driver Class)
	# @param user User name
	# @param status (1=away|2=online|3=offline)
	def cb_peer_status(self, user, status):
		try:
			if status == 1: what = "away"
			elif status == 2: what = "online"
			elif status == 0: what = "offline"
			
			if user in self.mucous.user["status"]:
				if self.mucous.user["status"][user] == status:
					return
				else: 
					self.mucous.user["status"][user] = status
			else:
				self.mucous.user["status"][user] = status

			room = None
			did = "change"
			if self.mucous.config !=  {}: 
				if "ignored" in self.mucous.config.keys(): 
					if user not in self.mucous.config["ignored"].keys():
						self.mucous.ChatRooms.AppendStatus(user, room, did, what)
						
			if self.mucous.mode == "chat":
				if self.mucous.ChatRooms.current != None:
					if user in self.mucous.ChatRooms.rooms[self.mucous.ChatRooms.current]:
						self.mucous.ChatRooms.DrawBox()
						curses.doupdate()
			elif self.mucous.mode in ("private", "info", "browse", "lists"):
				self.mucous.ModeReload(user)
		except Exception, e:
			self.mucous.Help.Log("debug", "CB Peer Status" + str(e))
			
	## Recieved a user's info
	# @param self Networking (Driver Class)
	# @param user the Username
	# @param info the description
	# @param picture the image, if it exists
	# @param uploads number of uploads slots
	# @param queue Length of queue
	# @param slotsfree has free slots?	
	def cb_user_info(self, user, info, picture, uploads, queue, slotsfree):
		try:
			
			self.mucous.Userinfo.Recieved(user, info, picture, uploads, queue, slotsfree)

		except Exception, e:
			self.mucous.Help.Log( "debug", "cb_user_info: " + str(e))
	
	## Recieved a user's ip and port from the server
	# @param self Networking (Driver Class)
	# @param user the Username
	# @param ip ip address
	# @param port user's listen port
	def cb_peer_address(self, user, ip, port):
		try:
			if user not in self.mucous.requests["ip"]:
				return
			self.mucous.requests["ip"].remove(user)
			
			if geoip_fail==0:
				try:
					country =  gi.country_name_by_addr( str(ip) )
					self.mucous.Help.Log("status", "%s's IP: %s Port: %s Country: %s"  % (user, str(ip), str(port), country) )
				except Exception, e:
					self.mucous.Help.Log("debug", "CB Peer Address: " + str(e))
			else:
				self.mucous.Help.Log("status","%s's IP: %s Port: %s"  % (user, str(ip), str(port)) )
			if self.mucous.mode != "info":
				self.mucous.Alerts.setStatus("New IP")
		except Exception, e:
			self.mucous.Help.Log( "debug", "cb_peer_address: " + str(e))
			
	## Recieved peer stats from museekd
	# @param self Networking (Driver Class)
	# @param user the Username
	# @param avgspeed Average Speed of user
	# @param numdownloads Number of files user has downloaded
	# @param numfiles Number of files share
	# @param numdirs Number of directories shared
	def cb_peer_stats(self, user, avgspeed, numdownloads, numfiles, numdirs):
		try:
			self.mucous.user["statistics"][user] = avgspeed, numdownloads, numfiles, numdirs
			if user in self.mucous.requests["statistics"]:
	
				self.mucous.Help.Log("status", "Peer Stats for: %s Speed: %.2f Kbyte/s :: Downloads: %s :: Files: %s :: Directories: %s" % (user, (avgspeed/1024.0), numdownloads, numfiles, numdirs) )
				
				self.mucous.requests["statistics"].remove(user)

			if user == self.mucous.username:
				self.mucous.data["mystats"] = user,  avgspeed, numdownloads, numfiles, numdirs
				if self.mucous.mode == "setup":
					self.mucous.Setup.Mode()
		except Exception, e:
			self.mucous.Help.Log( "debug", "cb_peer_stats: " + str(e))
			
	## Recieved private message from the server
	# @param self Networking (Driver Class)
	# @param direction 0 == incoming; 1 == outgoing
	# @param timestamp (we use our own)
	# @param user username
	# @param message text
	def cb_private_message(self, direction, timestamp, user, message):
		try:
			
			self.mucous.PrivateChat.Recieved(direction, timestamp, user, message)
			
				
		except Exception, e:
			self.mucous.Help.Log( "debug", "cb_private_message: " + str(e))
				
	## Recieved a notification from the server of your away status
	# @param self Networking (Driver Class)
	# @param status away=1/online=0
	def cb_server_status_set(self, status):
		try:
			self.mucous.Spl["status"] = status
			if status:
				stat = "Away"
			else:
				stat = "Online"
			
			self.mucous.logs["onlinestatus"]=stat
			osw = self.mucous.windows["border"]["onlinestatus"]
			try:
				osw.erase()
				osw.addstr(self.mucous.dlang(self.mucous.logs["onlinestatus"]), self.mucous.colors["blafgcyabg"] )
				
			except:
				pass
			osw.refresh()
			self.mucous.TerminalTitle()
		except Exception, e:
			self.mucous.Help.Log( "debug", "cb_server_status_set: " + str(e))
			
	## Recieved list of tickers for room
	# @param self Networking (Driver Class)
	# @param room Room name
	# @param tickers Dict of Users and Tickers
	def cb_room_tickers(self, room, tickers):
		
		try:
			for message, user in tickers.items():
				self.mucous.ChatRooms.tickers[room][user] = message
		except Exception, e:
			self.mucous.Help.Log( "debug", "cb_room_tickers: " + str(e))
			
	## A user in room set their ticker to message
	# @param self Networking (Driver Class)
	# @param room Room name
	# @param user User name
	# @param message ticker
	def cb_room_ticker_set(self, room, user, message):
		try:
			what = message
			did = "ticker"
			if self.mucous.config !=  {}: 
				if "ignored" in self.mucous.config.keys(): 
					if user not in self.mucous.config["ignored"].keys():
						self.mucous.ChatRooms.AppendStatus(user, room, did, what)
			if room in self.mucous.ChatRooms.tickers.keys():
				self.mucous.ChatRooms.tickers[room][user] = message
					
		except Exception, e:
			self.mucous.Help.Log( "debug", "cb_room_ticker_set: " + str(e))
			
	## New Search ticket recieved
	# @param self Networking (Driver Class)
	# @param query string searched for
	# @param ticket unique number associated with search
	def cb_search_ticket(self, query, ticket):
		try:
			self.mucous.Search.NewTicket(query, ticket)

		except Exception, e:
			self.mucous.Help.Log( "debug", "cb_search_ticket: " + str(e))
	
	## Recieved search results from a user
	# @param self Networking (Driver Class)
	# @param ticket unique number (used to organize results)
	# @param user username of user with results
	# @param free is there a free slot open? (True/False)
	# @param speed average speed of user
	# @param queue length of queue
	# @param results list of files [path, size, extension, list of attributes(bitrate, length, unused)]
	def cb_search_results(self, ticket, user, free, speed, queue, results):
		# search results
		try:
			self.mucous.Search.NewResults(ticket, user, free, speed, queue,results)
		except Exception, e:
			self.mucous.Help.Log("debug", "CB User Shares: " + str(e))

	## Recieved a user's shares
	# @param self Networking (Driver Class)
	# @param user Username
	# @param shares Dict of shares
	def cb_user_shares(self, user, shares):
		try:
			self.mucous.BrowseShares.Recieved(user, shares)
					
		except Exception, e:
			self.mucous.Help.Log("debug", "cb_search_results: " + str(e))

	## Recieved Transfer State from museekd
	# @param self Networking (Driver Class)
	# @param downloads list of instances of transfers
	# @param uploads list of instances of transfers
	def cb_transfer_state(self, downloads, uploads):
		try:
			for transfer in uploads:
				self.mucous.Transfers.transfers["uploads"][(transfer.user, transfer.path)] =  [transfer.is_upload, transfer.user, transfer.path, int(transfer.state), transfer.error, transfer.filepos, transfer.filesize, transfer.rate, transfer.place]
			self.mucous.Transfers.DrawUploadCount(str(len(self.mucous.Transfers.transfers["uploads"].keys())))
			
			for transfer in downloads:
				self.mucous.Transfers.transfers["downloads"][(transfer.user, transfer.path)] =  [transfer.is_upload, transfer.user, transfer.path, int(transfer.state), transfer.error, transfer.filepos, transfer.filesize, transfer.rate, transfer.place]
	
			self.mucous.Transfers.DrawDownloadCount(str(len(self.mucous.Transfers.transfers["downloads"].keys())))		
			if self.mucous.mode == "transfer":
				if mucous_config["mucous"]["transbox"] == "split":
					self.mucous.Transfers.UploadManager()
					self.mucous.Transfers.DownloadManager()
					curses.doupdate()
				else:
					if self.mucous.Transfers.Transfers.current == "uploads":
						self.mucous.Transfers.UploadManager()
						curses.doupdate()
					else:
						self.mucous.Transfers.DownloadManager()
						curses.doupdate()
			if mucous_config["mucous"]["auto-retry"] == "yes":
				self.mucous.retry_timer.cancel()
				self.mucous.retry_timer = threading.Timer(30.0, self.mucous.ThreadTransfersRetry)
				self.mucous.retry_timer.start()
			if mucous_config["mucous"]["auto-clear"] == "yes":
				self.mucous.clear_timer.cancel()
				self.mucous.clear_timer = threading.Timer(30.0, self.mucous.ThreadTransfersClear)
				self.mucous.clear_timer.start()
		except Exception, e:
			self.mucous.Help.Log("debug", "cb_transfer_state: " + str(e))
		
	## Recieved A Transfer update
	# @param self Networking (Driver Class)
	# @param transfer transfer instance
	def cb_transfer_update(self, transfer):
		try:
			if transfer.is_upload:
				self.mucous.Transfers.transfers["uploads"][(transfer.user, transfer.path)] =   [transfer.is_upload, transfer.user, transfer.path, int(transfer.state), transfer.error, transfer.filepos, transfer.filesize, transfer.rate, transfer.place]
				if self.mucous.mode == "transfer":
					if mucous_config["mucous"]["transbox"] == "split":
						self.mucous.Transfers.UploadManager()
						curses.doupdate()
					else:
						if self.mucous.Transfers.current == "uploads":
							self.mucous.Transfers.UploadManager()
							curses.doupdate()
				self.mucous.Transfers.DrawUploadCount(str(len(self.mucous.Transfers.transfers["uploads"].keys())))
			else:
		
				self.mucous.Transfers.transfers["downloads"][(transfer.user, transfer.path)] =  [transfer.is_upload, transfer.user, transfer.path, int(transfer.state), transfer.error, transfer.filepos, transfer.filesize, transfer.rate, transfer.place]
				if self.mucous.mode == "transfer":
					if mucous_config["mucous"]["transbox"] == "split":
						self.mucous.Transfers.DownloadManager()
						curses.doupdate()
					else:
						if self.mucous.Transfers.current == "uploads":
							pass
						else:
							self.mucous.Transfers.DownloadManager()
							curses.doupdate()
				self.mucous.Transfers.DrawDownloadCount(str(len(self.mucous.Transfers.transfers["downloads"].keys())))
			if self.mucous.mode == "transfer":
				if self.mucous.PopupMenu.show == True:
					self.mucous.PopupMenu.Create()
		except Exception, e:
			self.mucous.Help.Log("debug", "cb_transfer_update: " + str(e))
	## Removed a transfer
	# @param self Networking (Driver Class)
	# @param transfer transfer instance
	def cb_transfer_remove(self, transfer):
		try:
			user_path = transfer[1], transfer[2]
			if transfer[0]:
				del self.mucous.Transfers.transfers["uploads"][user_path]
				if self.mucous.mode == "transfer":
					if mucous_config["mucous"]["transbox"] == "split":
						self.mucous.Transfers.UploadManager()
						curses.doupdate()
					else:
						if self.mucous.Transfers.current == "uploads":
							self.mucous.Transfers.UploadManager()
							curses.doupdate()
				self.mucous.Transfers.DrawUploadCount(str(len(self.mucous.Transfers.transfers["uploads"].keys())))
						
			else:
				del self.mucous.Transfers.transfers["downloads"][user_path]
				if self.mucous.mode == "transfer":
					if mucous_config["mucous"]["transbox"] == "split":
						self.mucous.Transfers.DownloadManager()
						curses.doupdate()
					else:
						if self.mucous.Transfers.current == "uploads":
							pass
						else:
							self.mucous.DownloadManager()
							curses.doupdate()
				self.mucous.Transfers.DrawDownloadCount(str(len(self.mucous.Transfers.transfers["downloads"].keys())))
		except Exception, e:
			self.mucous.Help.Log("debug", "cb_transfer_remove: " + str(e))
	
	## Set a key/value in Mucous.config
	# @param self Networking (Driver Class)
	# @param domain parent of key
	# @param key to be modified
	# @param value key's new value
	def cb_config_set(self, domain, key, value):
		try:
			if key in self.mucous.config[domain].keys():
				if not domain.startswith("museeq"):
					self.mucous.Help.Log("status", "Modified <"+key+"> in <" +domain+"> to <"+value + ">")
				self.mucous.config[domain][key] = value
			else:
				if value == '' and domain is not "userinfo" and not domain.startswith("museeq"):
					self.mucous.Help.Log("status", "Added <"+key+"> to <" +domain+">")
				else:
					self.mucous.Help.Log("status", "Added <"+key+"> to <" +domain+"> and set to <"+value+">")
				self.mucous.config[domain][key] = value
			self.mucous.ConfigUpdateDisplay(domain)
		except Exception, e:
			self.mucous.Help.Log("debug", "cb_config_set: " + str(e))
			
	## Delete a key from Mucous.config
	# @param self Networking (Driver Class)
	# @param domain parent of key 
	# @param key to be removed
	def cb_config_remove(self, domain, key):
		try:
			if key in self.mucous.config[domain].keys():
				self.mucous.Help.Log("status", "Removed <"+key+"> from <" +domain+">")
				del self.mucous.config[domain][key]
			self.mucous.ConfigUpdateDisplay(domain)
		except Exception, e:
			self.mucous.Help.Log("debug", "cb_config_remove: " + str(e))
	
	## Recieved a copy of museekd's config
	# copy it to Mucous.config at connection
	# @param self Networking (Driver Class)
	# @param museek_config copy of config for internal use
	def cb_config_state(self, museek_config):
		try:
			self.mucous.config = museek_config.copy()
			self.mucous.Help.Log("status", "Server is at: "+self.mucous.config["server"]["host"]+":"+self.mucous.config["server"]["port"])
			self.mucous.UsersLists.ListBuddy()
			self.mucous.UsersLists.ListBan()
			self.mucous.UsersLists.ListIgnore()
			self.mucous.refresh_windows()
			self.mucous.Spl["museekconfigfile"] = os.path.expanduser("~/.museekd/config.xml")
			if self.mucous.config["shares"]["database"] != "":
				pos = self.mucous.config["shares"]["database"].rfind(".")
				file = self.mucous.config["shares"]["database"][:33]+".xml"
				if os.path.exists(file):
					self.mucous.Spl["museekconfigfile"] = file
		except Exception, e:
			self.mucous.Help.Log("debug", "cb_config_state: " + str(e))
	# -- ^ Museek Messages ^

## Main class
class Mucous:
	## Constructor
	## @author daelstorm
	## @brief Subclass driver.Driver, load default variables, create interface, attempt connection to museekd
	# @param self Mucous (class)
	def __init__(self):
		## @var config
		# config copied from museekd
		self.config = {}
		## @var usernames
		# Dict of special usernames
		self.usernames = {"privileges": None }
		## @var username
		# Your username
		self.username = None
		## @var Spl
		# Special Variables
		self.Spl = {"title": None,  "status": None, "connected": 0, \
		"history_count": 0, "ticker_room": None, "ticker_num":  0, \
		"museekconfigfile": ""}
		## @var data
		# data dict (variable storage)
		self.data = {   "mystats": [], }
		## @var logs
		# store lists of data here
		self.logs = {"tab_completion": [], "search_count": ["Results: ", 0], "history": [],  "onlinestatus": "Offline",     }
		## @var activeitems
		# Tab button positions
		self.activeitems = {"positions": {}}
		## @var requests
		# dict of users with requested data
		self.requests = {"ip":[],  "statistics": []}
		## @var mode
		# which part of Mucous is displayed
		self.mode = "chat"
		## @var user
		# Dicts of User status and statistics
		self.user = { "status": {}, "statistics": {}  }
		## @var windows
		# Curses window instances 
		self.windows = {"text": {}, "border": {}, "browse": {}, "tab": {} }
		## @var dimensions
		# Window dimensions / coordinates
		self.dimensions = {}
		## @var D
		# Networking (Class)
		self.D = Networking(self)
		## @var Help
		# Help (Class)
		self.Help = Help(self)
		## @var FormatData
		# FormatData (Class)
		self.FormatData = FormatData(self)
		## @var PopupMenu
		# PopupMenu (Class)
		self.PopupMenu = PopupMenu(self)
		## @var Muscan
		# Muscan (Class)
		self.Muscan = Muscan(self)
		## @var Userinfo
		# Userinfo (Class)
		self.Userinfo = Userinfo(self)
		## @var ChatRooms
		# ChatRooms (Class)
		self.ChatRooms = ChatRooms(self)
		## @var PrivateChat
		# PrivateChat (Class)
		self.PrivateChat = PrivateChat(self)
		## @var BrowseShares
		# BrowseShares (Class)
		self.BrowseShares = BrowseShares(self)
		## @var RoomsList
		# RoomsList (Class)
		self.RoomsList = RoomsList(self)
		## @var Recommendations
		# Recommendations (Class)
		self.Recommendations = Recommendations(self)
		## @var Setup
		# Setup (Class)
		self.Setup = Setup(self)
		## @var UsersLists
		# UsersLists (Class)
		self.UsersLists = UsersLists(self)
		
		## @var Search
		# Search (Class)
		self.Search = Search(self)
		
		## @var Alerts
		# Alerts (Class)
		self.Alerts = Alerts(self)
		## @var Transfers
		# Transfers (Class)
		self.Transfers = Transfers(self)
		
		## @var url
		# A Url collected from chat logs
		self.url = None
		## @var timedout
		# Away status timed out after a period of user inactivity
		self.timedout = False
		## @var listline
		# Tab Completion Line (split into a list)
		self.listline = []
		## @var keepit
		# Keep autocompletion list while tabbing
		self.keepit = []

		## @var invalidpass
		# If True, password to museekd was invalid 
		self.invalidpass = False
		## @var line
		# Input Line
		self.line = "" 
		
		## @var encodings
		# List of encodings, used in encodings popup :: Recommended: ISO-8859-1
		# UTF-16 AND ISO-8859-12 crash Mucous
		# UTF-8 is bad, since it's usually the original encoding being converted from
		self.encodings  = ['iso-8859-1', 'iso-8859-2', 'iso-8859-3', 'iso-8859-4', 'iso-8859-5', 'iso-8859-6', 'iso-8859-7', 'iso-8859-8', 'iso-8859-9', 'iso-8859-10', 'iso-8859-11', 'iso-8859-13', 'iso-8859-14', 'iso-8859-15', 'utf-8', 'utf-7',  'ascii']
		if "language" in mucous_config["mucous"]:
			if mucous_config["mucous"]["language"] not in self.encodings:
				mucous_config["mucous"]["language"] = "iso-8859-1"
		else:
			mucous_config["mucous"]["language"] = "iso-8859-1"
		## @var retry_timer
		# Retry failed transfers :: Calls: ThreadTransfersRetry
		self.retry_timer = threading.Timer(30.0, self.ThreadTransfersRetry)
		## @var clear_timer
		# Clear tramsfers timer :: Calls: Mucous.ThreadTransfersClear
		self.clear_timer = threading.Timer(30.0, self.ThreadTransfersClear)
		## @var NickTimer
		# Clear tramsfers timer :: Calls: Mucous.ThreadTransfersClear
		self.NickTimer = threading.Timer(10.0, self.ThreadNickCheck)
		## @var timeout_time
		# How long before away timer starts (900 seconds)
		self.timeout_time =  900 * 1.0
		## @var timeout_timer
		# AutoAway time instance 
		self.timeout_timer = threading.Timer(self.timeout_time, self.AwayTimeout)
		if mucous_config["tickers"]["ticker_cycle"] == "yes":
			time = float(mucous_config["tickers"]["cycletime"])
		if mucous_config["tickers"]["ticker_scroll"] == "yes":
			time = float(mucous_config["tickers"]["scrolltime"])
		
		
		if "ticker_cycle" in mucous_config["tickers"].keys():
			pass
		else:
			mucous_config["tickers"]["ticker_cycle"] = "yes"
		## @var commandlist
		# List of /commands (for Tab-completion)
		self.commandlist =  ["/me", "/j", "/join", "/p", "/part", "/l", "/leave", "/talk", "/say", "/alias", "/list", "/users", \
"/cd",  "/get", "/getdir", "/nick", "/privs", "/privileges", "/giveprivs",\
"/help", "/info",  "/autojoin", "/roombox", "/autoaway", "/transbox", "/roomlist", "/roomlistrefresh", \
"/inrooms", "/pm",  "/msg", "/np", "/npset", "/npcheck", "/browsewidth", \
"/npprefix", "/tickroom", "/tickcycle",  "/listtick", "/tickers", "/interface", "/password",\
"/save", "/connect", "/disconnect", "/autobuddy", "/autoclear", "/autoretry", "/privbuddy", "/onlybuddy",\
"/slots","/buddy", "/unbuddy",  "/ban", "/banlist", "/beep", "/trust", "/distrust", "/unban", "/nuke", "/unnuke",\
"/ignore", "/unignore",  "/unhide",  "/userinfo", "/ip", "/stat", "/away", "/abortup", "/percent", \
"/abortdown",  "/removeup", "/removedown", "/retry", "/retryall", "/clearup", "/cleardown", "/clearroom", "/clearsearchs", "/url", "/urlreader", "/urlcustom",\
"/search", "/searchfor", "/searchbuddy", "/searchroom", "/download", "/downdir", "/browse",\
"/browseuser", "/browsesearch", "/browsedown",  "/downuser",\
"/downpath", "/downpathdir",  "/chat", "/ignorelist", "/banlist", "/transfer", "/transfers", "/private",\
"/buddylist", "/setup", "/quit", "/logging", "/logdir", "/reloadshares", "/rescanshares", "/version", "/extra", \
"/logout", "/login", "/like", "/donotlike", "/donothate", "/hate", "/similar", "/globalrex", "/recommendations", "/rex", "/itemsimilar", "/itemrex", "/uploadto", "/upload", "/ctcpversion", "/defaulttick", "/settemptick", "/settick "]
		
		for alias in mucous_config["aliases"].keys():
			self.commandlist.append("/"+alias)
		## @var stdscr
		# Curses screen Startup
		self.stdscr = curses.initscr()
		#curses.flushinp()
		#curses.setupterm()
		#self.log["help"].append(str(curses.termattrs() ) )
		#self.log["help"].append(str(curses.termname() ))
		curses.meta(1)
		h, w = self.stdscr.getmaxyx()
		#h,w = struct.unpack("HHHH", fcntl.ioctl(sys.stdout.fileno(),termios.TIOCGWINSZ, struct.pack("HHHH", 0, 0, 0, 0)))[:2]
		if  h <=7 or w <=37:
			self.stdscr.keypad(1)
			curses.echo()
			curses.endwin()
			print "Console kinda small, resize it, please"
			sys.exit()
		#---------------
		
		curses.start_color()
		curses.mousemask(curses.ALL_MOUSE_EVENTS)
		curses.mouseinterval(110)
		## @var colors
		# Dict of color pairs
		self.colors = {}
		if curses.has_colors() == True:
			try:
				curses.use_default_colors()
				curses.can_change_color()
				curses.init_pair(1, curses.COLOR_RED, -1)
				curses.init_pair(2, curses.COLOR_YELLOW, -1)
				curses.init_pair(3, curses.COLOR_CYAN, -1)
				curses.init_pair(4, curses.COLOR_BLUE, -1)
				curses.init_pair(5, curses.COLOR_GREEN, -1)
				curses.init_pair(6, curses.COLOR_BLACK, -1)
				curses.init_pair(7, curses.COLOR_WHITE, -1)
				curses.init_pair(8, curses.COLOR_MAGENTA, -1)
				curses.init_pair(9, 0, curses.COLOR_CYAN)
				curses.init_pair(10, curses.COLOR_GREEN, curses.COLOR_BLACK )
				curses.init_pair(11, curses.COLOR_YELLOW, curses.COLOR_BLUE)
				curses.init_pair(12, curses.COLOR_BLACK, curses.COLOR_WHITE)
			except AttributeError:
				curses.init_pair(1, curses.COLOR_RED, 0)
				curses.init_pair(2, curses.COLOR_YELLOW, 0)
				curses.init_pair(3, curses.COLOR_CYAN, 0)
				curses.init_pair(4, curses.COLOR_BLUE, 0)
				curses.init_pair(5, curses.COLOR_GREEN, 0)
				curses.init_pair(6, curses.COLOR_BLACK, curses.COLOR_WHITE)
				curses.init_pair(7, curses.COLOR_WHITE, 0)
				curses.init_pair(8, curses.COLOR_MAGENTA, 0)
				curses.init_pair(9, 0, curses.COLOR_CYAN)
				curses.init_pair(10, curses.COLOR_GREEN, curses.COLOR_BLACK )
				curses.init_pair(11, curses.COLOR_YELLOW, curses.COLOR_BLUE)
				curses.init_pair(12, curses.COLOR_BLACK, curses.COLOR_WHITE)
				
			self.colors["red"] = curses.color_pair(1)
			self.colors["yellow"] = curses.color_pair(2)
			self.colors["cyan"] =  curses.color_pair(3)
			self.colors["blue"] = curses.color_pair(4)
			self.colors["green"] =  curses.color_pair(5)
			self.colors["black"] = curses.color_pair(6)
			self.colors["white"] = curses.color_pair(7)
			self.colors["magenta"] = curses.color_pair(8)
			self.colors["cybg"] = curses.color_pair(9)
			self.colors["greenbg"] = curses.color_pair(10)
			self.colors["hotkey"] = curses.color_pair(11)
			self.colors["blafgcyabg"] = curses.color_pair(12)
		else:
			self.colors["blafgcyabg"]  = self.colors["hotkey"] = self.colors["greenbg"] = self.colors["cybg"] = self.colors["magenta"] = self.colors["white"] =self.colors["black"]  = self.colors["cyan"] =  self.colors["yellow"] =self.colors["blue"]  =self.colors["green"] = self.colors["red"] =  curses.color_pair(0)
			#Disable cursor (bad idea)
# 			curses.curs_set(0)
		
		while 1:
			try:
				curses.noecho()
			except:
				pass
			try:
				curses.cbreak()
			except:
				pass
			self.stdscr.keypad(1)
			try:
				 self.line = self.Build()
			except Exception, e:
				self.Help.Log("debug", str(e) )
				sleep(0.5)
			if self.D.socket is None:
				self.D.connect()
			try:
				self.D.process()
			except select.error, e:
				self.line = self.Build()
				# Terminal resized
			except Exception, e:
				self.Help.Mode()
				self.Help.Log("status", "Shutting Down Mucous.. " +str(e) )
				sleep(1)
				self.shutdown()
				
	
	
	## Create curses parent window, get terminal size, draw windows
	# @param self Mucous (class)
	# @return line
	def Build(self):
# 		h, w = struct.unpack("HHHH", fcntl.ioctl(sys.stdout.fileno(),termios.TIOCGWINSZ, struct.pack("HHHH", 0, 0, 0, 0)))[:2]
# 		os.environ["LINES"] = str(h)
# 		os.environ["COLUMNS"] =str(w)

		try:
			self.stdscr = curses.initscr()
			self.stdscr.erase()
			self.stdscr.refresh()
			## @var h
			# Height of terminal / curses screen
			## @var w
			# Width of terminal / curses screen
			self.h, self.w = self.stdscr.getmaxyx()
			# Clean stale windows
			if "input" in self.windows:
				del self.windows["input"]
			if "inputborder" in self.windows:
				del self.windows["inputborder"]
				
			w = self.dimensions["input"] = {"height":1, "width":self.w-2, "top":self.h-3, "left":1}	
			bi = self.windows["inputborder"] = curses.newwin(w["height"]+2, w["width"]+2, w["top"]-1, w["left"]-1)
			bi.attron(self.colors["blue"])
			bi.border()
			bi.refresh()
			
			self.windows["input"] = bi.subwin(w["height"], w["width"], w["top"], w["left"])
			self.windows["input"].attroff(self.colors["blue"])
			self.ModeTopbar()

			self.PopupMenu.show  = False
		except Exception, e:
			self.Help.Log("debug", "Build: " + str(e))
		try:
			if self.mode == "chat":
				self.ChatRooms.Mode()
			elif self.mode == "private":
				self.PrivateChat.Mode()
			elif self.mode == "browse":
				self.BrowseShares.Mode()
			elif self.mode == "transfer":
				self.Transfers.ModeTransfers()
			elif self.mode == "info":
				self.Userinfo.Mode()
			elif self.mode == "search":
				self.Search.Mode()
			elif self.mode == "lists":
				self.UsersLists.ModeLists()
			elif self.mode == "roomlist":
				self.RoomsList.Mode()
			elif self.mode == "setup":
				self.Setup.Default()
			elif self.mode in ("debug", "help"):
				self.Help.Mode()
				
		except Exception, e:
			self.Help.Log("debug", "Build part 2: " + str(e))
			curses.doupdate()
		try:
			## @var edit
			# CharacterParse (Class)
			self.edit = CharacterParse(self)

			self.stdscr.nodelay(1)
				
		except Exception, e:
			self.Help.Log("debug", "Build: " + str(e))
		return self.line
	
	## Close mucous after disconnecting from museekd
	def shutdown(self):
		try:
			self.disconnect()
			# Quit		
			self.NickTimer.cancel()
			self.ChatRooms.ticker_timer.cancel()
			self.Muscan.timer.cancel()
			self.retry_timer.cancel()
			self.clear_timer.cancel()
		except Exception, e:
			self.Help.Log("debug", "shutdown: " + str(e))
		self.stdscr.keypad(0)
		curses.nocbreak()
		curses.echo()
		curses.endwin()
	
		os._exit(0)
	
	## Disconnect from museekd
	# @param self Mucous (class)
	def disconnect(self):
		
		try:
			if self.Spl["connected"] == 1:
				driver.Driver.close(self.D)
		except Exception,e:
			self.Help.Log("debug", "disconnect: " + str(e))
	
	
	## Failsafe Sending of messages to Museekd
	# @param self Mucous (class)
	# @param message messages instance
	def SendMessage(self, message):
		try:
			if self.Spl["connected"] == 0: return
			self.D.send(message)
		except Exception, e:
			self.Help.Log("debug", "SendMessage: " + str(e))

	## Toggle the logging of chat messages to disk 
	# @param self Mucous (class)
	def ToggleLogging(self):
		try:
			if "logging" in mucous_config["mucous"]:
				if str(mucous_config["mucous"]["logging"]) not in ("yes", "no"):
					mucous_config["mucous"]["logging"] = "yes"
				else:
					if str(mucous_config["mucous"]["logging"]) == "yes":
						mucous_config["mucous"]["logging"] = "no"
					else:
						mucous_config["mucous"]["logging"] = "yes"
			else:
				if str(mucous_config["mucous"]["logging"]) == "yes":
					mucous_config["mucous"]["logging"] = "no"
				else:
					mucous_config["mucous"]["logging"] = "yes"
					
			if str(mucous_config["mucous"]["logging"]) == "yes":
				self.Help.Log("status", "Logging Chat is now Enabled.")
			else:
				self.Help.Log("status", "Logging Chat is now Disabled.")
		except Exception,e:
			self.Help.Log("debug", "ToggleLogging: " + str(e))
			
	## Toggle alerts making beeps
	# @param self Mucous (class)
	def ToggleBeep(self):
		try:
			if str(mucous_config["mucous"]["beep"]) == "yes":
				mucous_config["mucous"]["beep"] = "no"
			else:
				mucous_config["mucous"]["beep"] = "yes"
			if self.mode=="setup":
				self.Setup.Mode()
		except Exception, e:
			self.Help.Log("debug", "ToggleBeep: "+str(e))
	
	## Toggle Away Status
	# @param self Mucous (class)
	def ToggleAwayStatus(self):
		try:
			if self.Spl["status"] == 0:
				self.SendMessage(messages.SetStatus(1))
			elif self.Spl["status"] == 1:
				self.SendMessage(messages.SetStatus(0))
		except Exception,e:
			self.Help.Log("debug", "ToggleAwayStatus: " +str( e) )
	## Display Mucous version and away status in the terminal title, if possible
	# :: May cause display corruption
	# @param self Mucous (class)
	def TerminalTitle(self):
		# Changes Terminal's Title when Away Status changes
		try:
			if os.path.expandvars("$SHELL") in  ("/bin/bash", "/bin/sh"):
				if str(curses.termname() ) != "linux":
					os.system("echo -ne \"\033]0;Mucous %s: %s\007\" " %(Version, self.logs["onlinestatus"] ))
		except Exception,e:
			self.Help.Log("debug", "TerminalTitle: " +str( e) )
			
	## Emit pcspeaker style beep, if enabled
	# @param self Mucous (class)
	def Beep(self):
		try:
			if str(mucous_config["mucous"]["beep"]) == "yes":
				if os.path.expandvars("$SHELL") in  ("/bin/bash", "/bin/sh"):
					os.system("echo -ne \\\\a " )
		except Exception,e:
			self.Help.Log("debug", "beep: " + str(e))
			
	## Redraw windows if user is in the current mode :: called on peer status updates
	# @param self Mucous (class)
	# @param user Username
	def ModeReload(self, user):
		
		if self.mode == "private":
			if user in self.PrivateChat.logs.keys():
				self.PrivateChat.Mode()
		elif self.mode == "chat":
			if user in self.ChatRooms.rooms[self.ChatRooms.current]:
				self.ChatRooms.Mode()
		elif self.mode == "info":
			if user in self.Userinfo.users:
				self.Userinfo.Mode()
		elif self.mode == "lists":
			if self.UsersLists.current in self.config.keys():
				if user in self.config[self.UsersLists.current].keys():
					self.UsersLists.ModeLists()
		elif self.mode == "browse":
			if user in self.BrowseShares.users:
				self.BrowseShares.Mode()
		elif self.mode == "search":
			if user in self.Search.tickets.keys():
				self.Search.Mode()
		elif self.mode == "transfers":
			self.Transfers.ModeTransfers()
		elif self.mode == "roomlist":
			self.RoomsList.Mode()
		elif self.mode == "setup":
			self.Setup.Default()
		elif self.mode in ("help", "debug", "status"):
			self.Help.Mode()
			

	## Add new/replace old keys in Mucous.config
	# @param self Mucous (class)
	# @param changetype type of change (Ex: buddy, unignore)
	# @param username the username of user being modified 
	# @param value comment
	def ModifyConfig(self, changetype, username, value):
		try:
			
			username = self.dlang(username)
			if changetype == "buddy":
				if username not in self.config["buddies"].keys():
					self.SendMessage(messages.ConfigSet("buddies", username, "buddied by mucous"))
					
			elif changetype == "unbuddy":
				if username in self.config["buddies"].keys():
					self.SendMessage(messages.ConfigRemove("buddies", username))
				else:
					self.Help.Log("status", "User not in buddy list: %s" % username)
			elif changetype == "ban":
				if username not in self.config["banned"].keys():
					self.SendMessage(messages.ConfigSet("banned", username, "banned by mucous"))
			elif changetype == "trusted":
				if username not in self.config["trusted"].keys():
					self.SendMessage(messages.ConfigSet("trusted", username, ""))
			elif changetype == "unban":
				if username in self.config["banned"].keys():
					self.SendMessage(messages.ConfigRemove("banned", username))
				else:
					self.Help.Log("status", "User not in ban list: %s" % username)
			elif changetype == "ignore":
				if username not in self.config["ignored"].keys():
					self.SendMessage(messages.ConfigSet("ignored", username, ""))
					self.Help.Log("status", "Ignored: %s" % username)
			elif changetype == "unignore":
				if username in self.config["ignored"].keys():
					self.SendMessage(messages.ConfigRemove("ignored", username))
				else:
					self.Help.Log("status", "User not in ignore list: %s" % username)
			elif changetype == "autojoin":
				room = username
				if room not in self.config["autojoin"].keys():
					self.SendMessage(messages.ConfigSet("autojoin", room, ""))
				else:
					self.SendMessage(messages.ConfigRemove("autojoin", room))
	
			elif changetype == "unautojoin":
				room = username
				if room in self.config["autojoin"].keys():
					self.SendMessage(messages.ConfigRemove("autojoin", room))
				else:
					self.SendMessage(messages.ConfigSet("autojoin", room, ""))
			elif changetype == "trust":
				if username not in self.config["trusted"].keys():
					self.SendMessage(messages.ConfigSet("trusted", username,  ""))
			elif changetype == "distrust":
				if username in self.config["trusted"].keys():
					self.SendMessage(messages.ConfigRemove("trusted", username))
		except Exception, e:
			self.Help.Log("debug", "ModifyConfig: " + str(e))
			
	## Update windows if a config change effects them
	# @param self Mucous (class)
	# @param domain which domain the config change was in
	def ConfigUpdateDisplay(self, domain):
		try:
			if domain in ("buddies", "banned", "trusted", "ignored",  "autojoin", "trusted"):
				if self.mode == "lists":
					if self.UsersLists.current == "buddied":
						self.UsersLists.ModeBuddy()
					elif self.UsersLists.current == "banned":
						self.UsersLists.ModeBan()
					elif self.UsersLists.current == "ignored":
						self.UsersLists.ModeIgnore()
					elif self.UsersLists.current == "trusted":
						self.UsersLists.ModeTrust()
				elif self.mode == "chat" :
					self.ChatRooms.DrawBox()
					
				if self.PopupMenu.show == True:
					self.PopupMenu.Draw()
					
			elif domain in ("interests.like", "interests.hate"):
				if self.mode == "lists" and self.UsersLists.current == "interests":
					self.Recommendations.ModeInterests()
			elif domain in ("clients", "transfers", "server", "interfaces", "interfaces.bind", "userinfo") and self.mode == "setup":
				self.Setup.Mode()
			elif domain in ("encoding.users", "encoding" ) and self.mode == "browse":
				self.BrowseShares.Mode()
			elif domain in ("encoding.users" ) and self.mode == "private":	
				self.PrivateChat.Mode()
			elif domain in ("encoding.rooms" ) and self.mode == "chat":
				self.ChatRooms.Mode()
		except Exception, e:
			self.Help.Log("debug", "ConfigUpdateDisplay: " + str(e))
		
		
	## Autobuddy a user you're downloading from
	# :: Valid if mucous_config["mucous"]["autobuddy"] is True
	# @param self Mucous (Class)
	# @param user Username
	def AutobuddyUser(self, user):
		if user == None:
			return
		if mucous_config["mucous"]["autobuddy"]  != "yes":
			return
		if not self.config["buddies"].has_key(user):
			self.SendMessage(messages.ConfigSet("buddies", user, "buddied by mucous"))
			self.Help.Log("status", "Auto-Buddied: %s" % user)
	
	
	## Append list of users in room to status (help mode) log
	# @param self Mucous (Class)
	# @param room Room Name 
	def show_nick_list(self, room):
		try:
			## @var colorednicks
			# display names in status log
			self.colorednicks = {}
			
			if self.ChatRooms.rooms[room] == None:
				return
			
			self.colorednicks[room] = []
			alphanicks=[]
			alphanicks = self.ChatRooms.rooms[room]
			alphanicks.sort(key=str.lower)
			self.Help.Log("status", "Users in " + room)
			for username in alphanicks:
				if username == self.username:
					self.colorednicks[room].append([username, "Me"])
				elif username not in self.ChatRooms.rooms[room]:
					self.colorednicks[room].append([username, "Left"])
				elif username in self.config["banned"]:
					self.colorednicks[room].append([username, "Banned"])
				elif username in self.config["buddies"]:
					self.colorednicks[room].append([username, "Buddies" ])
				else:
					self.colorednicks[room].append([username, "Normal"])
				self.colorednicks[room].append([" ["+str(self.user["statistics"][username])+"]", "Normal"])
				line = username + (" " * (30 - len(username)) ) + "Files: " + str(self.user["statistics"][username][2])
				
				#line = "%s": [%s] Files" % (username,  )
				self.Help.Log("status", line)
				if username is not alphanicks[-1]:
					self.colorednicks[room].append([", ", "NotLast"])
			mtype = "List"
			user = "!!!!"
			msg = self.colorednicks[room]
			
			#self.ChatRooms.AppendChat("List", room, '!!!!', msg)
		except Exception, e:
			self.Help.Log("debug", "show_nick_list: " + str(e))
			
	## Create Tab Completion List
	# @param self Mucous (Class)
	def InputCompletionList(self):
		try:
			usercompletionlist = {}
			if "buddies" in self.config:
				for users in self.config["buddies"].keys():
					usercompletionlist[self.dlang(users)] = 0
			if "banned" in self.config:
				for users in self.config["banned"].keys():
					usercompletionlist[self.dlang(users)] = 0
			if "ignored" in self.config:
				for users in self.config["ignored"].keys():
					usercompletionlist[self.dlang(users)] = 0
			
			#if self.mode == "chat":
				# Autocomplete users in the current room only
			if self.ChatRooms.rooms.keys() != []:
				for user in self.ChatRooms.rooms[self.ChatRooms.current]:
					usercompletionlist[self.dlang(user)] = 0
			#elif self.mode == "private":
			pmusers = self.PrivateChat.logs.keys()
			for user in pmusers:
				usercompletionlist[self.dlang(user)] = 0
			if self.mode == "transfers":
				if self.Transfers.transfers["uploads"].keys() != []:
					for userpath, values in self.Transfers.transfers["uploads"].items():
						usercompletionlist[self.dlang(values[1])] = 0
				if self.Transfers.transfers["downloads"].keys() != []:
					for userpath, values in self.Transfers.transfers["downloads"].items():
						usercompletionlist[self.dlang(values[1])] = 0
			elif self.mode == "browse":
				if self.BrowseShares.current != None:
					if self.BrowseShares.current in self.BrowseShares.results:
						for dirs in self.BrowseShares.results[self.BrowseShares.current].keys():
							usercompletionlist[self.dlang(dirs)] = 0
			for values in self.commandlist:
				usercompletionlist[self.dlang(values)] = 0
				
			if usercompletionlist.keys() != []:
				self.logs["tab_completion"] = usercompletionlist.keys()
				self.logs["tab_completion"].sort(key=str.lower)
			else:
				self.logs["tab_completion"] = []
		except Exception, e:
			self.Help.Log("debug", "InputCompletionList: " + str(e))
			
	## Here's where scrolling works
	# @param self Mucous (Class)
	# @return list / Nothing
	def ScrollText(self):
		try:
			color_added = None
			scrolltext = None
			scrollnum = None
			position = None
			scrollchange = 0
			if self.mode not in ( "transfer", "search", "help", "debug", "info", "private", "lists", "roomlist", "chat", "browse"):
				return 
			if self.mode == "chat":
				if self.ChatRooms.selected == "chatroom":
					scrollnum = self.ChatRooms.scrolling["chatroom"]
					w = self.ChatRooms.dimensions["chat"]
					if self.ChatRooms.current != None:
						selected_log = self.ChatRooms.logs["rooms"][self.ChatRooms.current]
						 
					else: 
						self.ChatRooms.DrawChatWin()
						self.ChatRooms.windows["text"]["chat"].refresh()
						return
				elif self.ChatRooms.selected == "roombox":
					scrollnum = self.ChatRooms.scrolling["roombox"]
					w = self.ChatRooms.dimensions["roombox"]
					selected_log = self.ChatRooms.logs["roombox"][self.ChatRooms.current]
				elif self.ChatRooms.selected == "roomstatus":
					scrollnum = self.ChatRooms.scrolling["roomstatus"]
					#scrolltext = "roomstatus"
					w = self.ChatRooms.dimensions["roomstatus"]
					selected_log = self.ChatRooms.logs["roomstatus"][self.ChatRooms.current]
				scrolldiff = w["height"]
			elif self.mode == "browse":
				scrollnum = self.BrowseShares.scrolling[self.BrowseShares.selected]
				scrolldiff =self.BrowseShares.dimensions["browse"]["height"]
			elif self.mode in ("debug", "help"):
				scrollnum = self.Help.scrolling[self.mode]
				scrolldiff = self.Help.dimensions["help"]["height"]
			elif self.mode ==  "private":
				scrollnum = self.PrivateChat.scrolling
				scrolldiff = self.PrivateChat.dimensions["height"]
				
			elif self.mode == "info":
				if self.Userinfo.current == None:
					scrollnum = self.Userinfo.scrolling_status
				else:
					scrollnum = self.Userinfo.scrolling[self.Userinfo.current]
				scrolldiff = self.Userinfo.dimensions["info"]["height"]
			elif self.mode == "search":
				scrollnum = self.Search.scrolling
				scrolldiff = self.Search.dimensions["height"]
				
			elif self.mode == "lists":
				if self.UsersLists.current == "interests":
					scrollnum = self.Recommendations.scrolling[self.Recommendations.selected]
					scrolldiff = self.Recommendations.dimensions[self.Recommendations.selected]["height"]
				else:
					scrollnum = self.UsersLists.scrolling[self.UsersLists.current]
					scrolldiff = self.UsersLists.dimensions[self.UsersLists.current]["height"]
					
			elif self.mode == "roomlist":
				scrollnum = self.RoomsList.scrolling
				scrolldiff = self.RoomsList.dimensions["height"]
			elif self.mode == "transfer":
				scrollnum = self.Transfers.scrolling[self.Transfers.current]
				scrolldiff = self.Transfers.dimensions[self.Transfers.current]["height"]-1
				
			if scrolltext != None:
				position = self.scrolling[scrolltext]
			if scrollnum != None:
				position = scrollnum
			if key == "KEY_UP":	
				position -= 1
				scrollchange = -1
			elif key == "KEY_DOWN":
				position += 1
				scrollchange = 1
			elif key == "KEY_PPAGE":
				position -= scrolldiff
				scrollchange = -scrolldiff 
				
				# upload or download window height - one line for heading
			elif key == "KEY_NPAGE":
				position += scrolldiff
				scrollchange = scrolldiff
			if position < 0:
				position = 0
			
			if scrolltext != None:
				self.scrolling[scrolltext] = position
			if scrollnum != None:
				self.UpdateScrollNum(position)
				
			if self.mode == "chat":
				if self.ChatRooms.selected  == "chatroom":
					#start -= 1
					self.ChatRooms.FormatChatText()
				elif self.ChatRooms.selected  == "roombox":
					self.ChatRooms.FormatBox()
				elif self.ChatRooms.selected  == "roomstatus":
					self.ChatRooms.DrawStatusText()
					
			elif self.mode == "browse":

				if self.BrowseShares.selected == "directories":
					self.BrowseShares.FormatBrowse(True)
				else:
					self.BrowseShares.FormatBrowse(False)
				curses.doupdate()
			elif self.mode == "info":
				self.Userinfo.DrawText()
			elif self.mode == "private":
				self.PrivateChat.Draw()
			elif self.mode == "search":
				self.Search.Draw()
			elif self.mode == "lists":
				if self.UsersLists.current != "interests":
					self.UsersLists.SelectLists()
				else:
					self.Recommendations.DrawInterests()
		
				return
			elif self.mode == "roomlist":
				self.RoomsList.Format()
				return self.RoomsList.sizedrooms[self.RoomsList.scrolling]
			elif self.mode in ("help", "debug"):
				self.Help.Format()
			elif self.mode == "transfer":
				if self.Transfers.current == "uploads":
					self.Transfers.UploadManager()
					curses.doupdate()
				elif self.Transfers.current == "downloads":
					self.Transfers.DownloadManager()
					curses.doupdate()
				
		except Exception, e:
			self.Help.Log("debug", "ScrollText: " + str(e))
	# ---v  KEYS v
	
	## Update Scrolling Numbers
	# @param self Mucous (Class)
	# @param num scrolling number
	def UpdateScrollNum(self, num):
		try:
			if self.mode == "private":
				self.PrivateChat.scrolling = num
			elif self.mode == "search":
				self.Search.scrolling = num
			elif self.mode == "roomlist":
				self.RoomsList.scrolling = num
			elif self.mode == "browse":
				self.BrowseShares.scrolling[self.BrowseShares.selected] = num
			elif self.mode == "info":
				if self.Userinfo.current == None:
					self.Userinfo.scrolling_status = num
				else:
					self.Userinfo.scrolling[self.Userinfo.current] = num
			elif self.mode == "lists":
				if self.UsersLists.current == "interests":
					self.Recommendations.scrolling[self.Recommendations.selected] = num
				else:
					self.UsersLists.scrolling[self.UsersLists.current] = num
			elif self.mode == "transfer":
				#if self.Transfers.current == "interests":
				self.Transfers.scrolling[self.Transfers.current] = num
			elif self.mode == "chat":
				self.ChatRooms.scrolling[self.ChatRooms.selected] = num
			elif self.mode in ("debug", "help"):
				self.Help.scrolling[self.mode] = num
		except Exception, e:
			self.Help.Log("debug", "UpdateScrollNum: " + str(e))
			
	## Complete command, word, or user in line
	# @param self Mucous (Class)
	# @param line string containing the entire line
	# @param part line segment we are in
	# @param firsttab (0/1) (do not rebuild and match the completion list if 1)
	# @param listline line split into a list
	# @param pos horizontal Postion in line
	# @return listline, firsttab, part, pos
	def InputTabCompletion(self, line, part, firsttab, listline, pos):
		try:
			self.listline = listline
			
			if firsttab ==0:
				self.InputCompletionList()
				
			if self.logs["tab_completion"] == []:
				return self.listline, firsttab, part, pos
				
			if self.mode not in ("roomlist", "chat", "lists", "info", "private", "browse", "transfer", "setup", "search", "help", "debug", "status"):
				return self.listline, firsttab, part, pos
			if len(part) <= 0:
				return self.listline, 0, part, pos
			if firsttab ==0:
				self.keepit=[]
				if self.mode == "roomlist":
					for words in self.RoomsList.rooms.keys():
						if words.upper().startswith(part[0:1].upper()):
							self.keepit.append(words)
				else:
					for words in self.logs["tab_completion"]:
						if part[0:1] == '/':
							# Be more picky with /commands
							if len(words) > len(part):
								if words.upper().startswith(part.upper()):
									self.keepit.append(words)
							
						else:
							if words.upper().startswith(part.upper()):
								self.keepit.append(words)
				self.keepit.sort(key=str.lower)
			firsttab +=1

			currentword = self.listline[pos]	
			lw = len(currentword)

			if currentword.upper().startswith(part.upper()):
				
				for words in self.keepit:
					self.listline[pos] = self.keepit[0]
					z = self.keepit[0]
					self.keepit.remove(self.keepit[0])
					self.keepit.append(z)


					break
				else:
					
					firsttab = 0
			else:
				firsttab = 0

			return self.listline, firsttab, part, pos

		except Exception, e:
			self.Help.Log("debug", "InputTabCompletion: " + str(e))
			
	## Previously inputted messages
	# @param self Mucous (Class)
	# @param key KEY_UP or KEY_DOWN
	# @param line current line
	# @param history_count position in the history log
	# @return line, history_count
	def InputHistory(self, key, line, history_count):
		try:
			self.Spl["history_count"] = history_count
			if line not in self.logs["history"] and line !='' and not line.isspace():
				self.logs["history"].append(line)
				
			if len(self.logs["history"]) == 0:
				# return current line and current position
				return line, self.Spl["history_count"]
			
			if key == "KEY_UP":
				self.Spl["history_count"] += 1
			elif key == "KEY_DOWN":
				self.Spl["history_count"] -= 1
	
			last_line = len(self.logs["history"]) -1 - self.Spl["history_count"]
			if last_line < 0:
				last_line = len(self.logs["history"]) -1
				self.Spl["history_count"] = 0
			elif last_line > len(self.logs["history"]) -1:
				last_line = len(self.logs["history"]) -1
				self.Spl["history_count"] += 1
			line = self.logs["history"][ last_line]
			# return old line and line's position
			return line, self.Spl["history_count"]
		except Exception, e:
			self.Help.Log("debug", "history: " + str(e))
	
	## Redraw windows for current mode
	# @param self is Mucous (Class)
	def refresh_windows(self):
		
		try:
			if self.mode =="transfer":
				if mucous_config["mucous"]["transbox"]=="split":
					
					self.Transfers.windows["border"]["uploads"].redrawwin()
					self.Transfers.windows["border"]["uploads"].refresh()
					self.Transfers.windows["border"]["downloads"].redrawwin()
					self.Transfers.windows["border"]["downloads"].refresh()
				else:
					if self.Transfers.current == "downloads":
						self.Transfers.windows["border"]["downloads"].redrawwin()
						self.Transfers.windows["border"]["downloads"].refresh()
					elif self.Transfers.current == "uploads":
						self.Transfers.windows["border"]["uploads"].redrawwin()
						self.Transfers.windows["border"]["uploads"].refresh()
			elif self.mode == "lists":
				self.UsersLists.windows["border"][self.UsersLists.current].redrawwin()
				self.UsersLists.windows["border"][self.UsersLists.current].refresh()
				self.UsersLists.windows["text"][self.UsersLists.current].redrawwin()
				self.UsersLists.windows["text"][self.UsersLists.current].refresh()
			elif self.mode == "chat":
				self.ChatRooms.windows["border"]["chat"].redrawwin()
				self.ChatRooms.windows["border"]["chat"].refresh()
				self.ChatRooms.windows["text"]["chat"].redrawwin()
				self.ChatRooms.windows["text"]["chat"].refresh()
				if self.ChatRooms.shape not in ("chat-only",  "nostatuslog"):
					if "roomstatus" in self.ChatRooms.windows["border"]: 
						self.ChatRooms.windows["border"]["roomstatus"].redrawwin()
						self.ChatRooms.windows["border"]["roomstatus"].refresh()
					if "roomstatus" in self.ChatRooms.windows["text"]:
						self.ChatRooms.windows["text"]["roomstatus"].redrawwin()
						self.ChatRooms.windows["text"]["roomstatus"].refresh()
				if self.ChatRooms.shape not in ( "noroombox", "chat-only"):
					self.ChatRooms.windows["border"]["roombox"].redrawwin()
					self.ChatRooms.windows["border"]["roombox"].refresh()
			elif self.mode == "search":
				#self.BrowseShares.DrawBrowseWin()
				self.Search.FormatResults(self.Search.current)
				curses.doupdate()		
			elif self.mode == "browse":
				self.BrowseShares.DrawBrowseWin()
				self.BrowseShares.FormatBrowse()
				curses.doupdate()
			elif self.mode == "setup":
				self.Setup.Mode()
			elif self.mode == "info":
				self.Userinfo.Mode()
			else:
				pass
			self.windows["inputborder"].redrawwin()
			self.windows["inputborder"].refresh()
		except Exception,e:
			self.Help.Log("debug", "Refresh Windows: "+str(e))

			

	## Clicked on the tab selector
	# @param self is Mucous (Class)
	# @param x Horizontal position
	# @param chosen Mode we are in
	# @return chose, match
	def MouseClickTab(self, x, chosen):
		try:
			choz = self.activeitems["positions"][chosen]
			match = None
			if x >= choz[0] and x < choz[1]:
				# do nothing if chose search is clicked
				return chosen, 'yes'
			else:
				for key, pos in self.activeitems["positions"].items():
					if x >= pos[0]   and x < pos[1] :
						match = 'yes'
						break
			if match != None:
				return key, match
			else:
				return chosen, None
		except Exception, e:
			self.Help.Log("debug", "MouseClickTab: " +str(e) )
		
	## Mouse Coordinates: Switch modes or options in position matches requirements
	# @param self is Mucous (Class)
	# @param line is a text string
	# @return  line / Nothing
	def MouseXY(self, line):
		
		try:
			(id,x,y,z,event) = curses.getmouse()
			#self.Help.Log("debug", "%d %d %d %d %d" % (id, x, y, z,event))
			if event in (1, 128, 8192):
				# Ignore PRESSED and RELEASED
				return
			if x in range(8) and y == 0:
				if self.Spl["connected"] == 0:
					self.D.connect()
				elif self.Spl["connected"] == 1:
					self.ToggleAwayStatus()
				return
		# 1Chat 2Private 3Transfers 4Search 5Info 6Browse 7Users 8Rooms 9Setup 10Help
			if y >= self.h-1:
				# clickable mode switching
				if x >= 0 and x < 7:
					self.ChatRooms.Mode()
				elif x >= 7 and x < 16:
					self.PrivateChat.Mode()
				elif x >= 16 and x < 27:
					self.Transfers.ModeTransfers()
				elif x >= 27 and x < 35:
					self.Search.Mode()
				elif x >= 35 and x < 41:
					self.Userinfo.Mode()
				elif x >= 41 and x < 49:
					self.BrowseShares.Mode()
				elif x >= 49 and x < 56:
					self.UsersLists.ModeLists()
				elif x >= 56 and x < 63:
					self.RoomsList.Mode()
				elif x >= 63 and x < 70:
					self.Setup.Default()
				elif x >= 70 and x < 76:
					self.Help.Mode()
				return
				
			if self.PopupMenu.show == True and self.PopupMenu.current != None:
				p = self.PopupMenu.menus[self.PopupMenu.current]
				#width = self.PopupMenu.menus[self.PopupMenu.current]["width"]
				#top = self.PopupMenu.menus[self.PopupMenu.current]["top"]
				#height = self.PopupMenu.menus[self.PopupMenu.current]["height"]
				#left = self.PopupMenu.menus[self.PopupMenu.current]["left"]
				if x >= p["left"] and x < p["left"]+p["width"] and y >= p["top"] and y < p["top"]+p["height"]:
					self.PopupMenu.Mouse(x, y, event)
					return
				else:
					self.PopupMenu.Clear()
					
			if self.mode == "chat":
				self.ChatRooms.MouseChat(x,y,z,event)
			elif self.mode == "private":
				# Clickable private message switch
				return self.PrivateChat.Mouse(x,y,z,event)
			elif self.mode == "browse":
				return self.BrowseShares.MouseBrowse(x,y,z,event)
			elif self.mode == "info":
				# Clickable user info tabs
				return self.Userinfo.Mouse(x,y,z,event)
			elif self.mode == "search":
				return self.Search.Mouse(x,y,z,event)
			elif self.mode == "roomlist":
				# ROOMLIST BUTTONS
				return self.RoomsList.Mouse(x,y,z,event)
			elif self.mode == "lists":
				return self.UsersLists.Mouse(x,y,z,event)
			elif self.mode == "transfer":
				# TRANSFERS BUTTONS
				# Clickable transfer type switcher
				return self.Transfers.Mouse(x,y,z,event)
			elif self.mode == "setup":
				return self.Setup.Mouse(x,y,z,event)
				

			elif self.mode in ("help", "debug"):
				if y == self.Help.dimensions["help"]["top"]-1:
					if x >= 4 and x <= 16 and self.mode != "help":
						self.mode = "help"
						self.Help.Mode()
					elif x >= 18 and x <= 31 and self.mode != "debug":
						self.mode = "debug"
						self.Help.Mode()
			# END OF MOUSE
			return line
		except Exception, e:
			self.Help.Log("debug", "MouseXY: "+str(e) )
	
	## Parse Entry box for commands
	# @param self is mucous
	# @param line is a text string
	# @return Nothing / 0 / 1 /2 
	def InputCommands(self, line):
		try:
			if line[:1] != "/" or line[:2] == '//' or line[:4] == '/me ':
				if self.Spl["title"] and line:
					self.InputText(line)
				return
			#if line[:1] == "/" and line[:4] != "/me " and line[:2] != '//':
			
			if line == "/quit" or line == "/exit":
				config_manager.update_config()
				self.shutdown()
				return 2
			elif line[:11] == "/disconnect":
				self.disconnect()
			elif line == "/debug":
				self.mode = "debug"
				self.Help.Mode()
			elif line[:5] == "/help":
				self.mode = "help"
				self.Help.Mode()
				if line[5:] == " chat":
					for line in self.Help.log["chat"]:
						self.Help.Log("help", line)
				elif line[5:] == " mode":
					for line in self.Help.log["modes"]:
						self.Help.Log("help", line)
				elif line[5:] == " user":
					for line in self.Help.log["user"]:
						self.Help.Log("help", line)
				elif line[5:] == " search":
					for line in self.Help.log["search"]:
						self.Help.Log("help", line)
				elif line[5:] == " browse":
					for line in self.Help.log["browse"]:
						self.Help.Log("help", line)
				elif line[5:] == " transfer":
					for line in self.Help.log["transfer"]:
						self.Help.Log("help", line)
				elif line[5:] == " ticker":
					for line in self.Help.log["tickers"]:
						self.Help.Log("help", line)
				elif line[5:] == " download":
					for line in self.Help.log["download"]:
						self.Help.Log("help", line)
				elif line[5:] == "":
					for line in self.Help.log["helpcommands"]:
						self.Help.Log("help", line)
				elif line[5:] == " keys":
					for line in self.Help.log["keys"]:
						self.Help.Log("help", line)
				elif line[5:] == " connect":
					for line in self.Help.log["connect"]:
						self.Help.Log("help", line)
				elif line[5:] == " setup":
					for line in self.Help.log["setup"]:
						self.Help.Log("help", line)
				try:
					self.edit.reset()
				except:
					pass
				'''
				Chatrooms
				'''
			elif line[:6] == "/talk ": 
				self.ChatRooms.Change(line[6:])
				
			elif line[:6] == "/join ":
				self.ChatRooms.JoinRoom(line[6:])
				
			elif line[:3] == "/j ":
				self.ChatRooms.JoinRoom(line[3:])
				
			elif line in ("/part", "/p", "/l", "/leave"):
				self.ChatRooms.Leave()
				
				
			elif line[:6] == "/part ":
				for room in self.ChatRooms.rooms.keys():
					if self.dlang( line[6:] ) == room:
						self.SendMessage(messages.LeaveRoom(room))
						
			elif line[:7] == "/leave ":
				for room in self.ChatRooms.rooms.keys():
					if self.dlang( line[7:] ) == room:
						self.SendMessage(messages.LeaveRoom(room))
				
			elif line[:10] == "/autojoin " and line[10:] != '':
				if line[10:] in self.ChatRooms.rooms.keys():
					room = line[10:]
					self.ModifyConfig("autojoin", room, '')
				else:
					self.Help.Log("status", "You aren't in room: %s" % line[5:])
					
			elif line == "/autojoin":
				if self.ChatRooms.current != None:
					room = self.ChatRooms.current
					self.ModifyConfig("autojoin", room, '')
					
			elif line == "/extra":
				
				if mucous_config["mucous"]["extra_requests"] == "Yes":
					mucous_config["mucous"]["extra_requests"] = "No"
				elif mucous_config["mucous"]["extra_requests"] == "No":
					mucous_config["mucous"]["extra_requests"] = "Yes"
				if mucous_config["mucous"]["extra_requests"] not in ("Yes", "No"):
					mucous_config["mucous"]["extra_requests"] = "No"
				self.Help.Log("status", "Extra CTCP-like version requests are responded to? %s"  % mucous_config["mucous"]["extra_requests"] )
				
			elif line[:4] == "/ut ":
				try:
					num = int(line[4:])
					for username, path in self.Transfers.downloads[num].items():
						self.SendMessage(messages.TransferUpdate(username, path) )
				except:
					return
					
			elif line == "/beep":
				self.ToggleBeep()
			elif line =="/ping":
				self.SendMessage(messages.Ping(1) )
			elif line[:6] == "/close":
				user = None
				if line[6:7] == " " and line[7:] != '':
					user == line[7:]
					
				if self.mode == 'private':
					if user != None: this_user = user
					else: this_user = self.PrivateChat.current
					if this_user != None:
						self.PrivateChat.Close(this_user)
						
				elif self.mode == 'chat':
					if user != None: room = user
					else: room = self.ChatRooms.current
					if room in self.ChatRooms.rooms.keys():
						self.SendMessage(messages.LeaveRoom(room))
						
				elif self.mode == 'info':
					if user != None: this_user = user
					else: this_user = self.Userinfo.current
					if this_user != None:
						self.Userinfo.Close(this_user)
						
				elif self.mode == 'browse':
					if user != None: this_user = user
					else: this_user = self.BrowseShares.current
					if this_user != "default__":
						self.Close(this_user)
						
				elif self.mode =='search':
					if self.Search.current != None:
						self.Search.Close(self.Search.current)

			elif line[:4] == "/pm " and line[4:] != '':
				self.PrivateChat.current = line[4:]
				self.PrivateChat.Start(self.PrivateChat.current)
				if self.mode == 'private':
					self.PrivateChat.Mode()

					
			elif line[:5] == "/msg " and line[5:] != '':
				if self.PrivateChat.current != None:
					message = line[5:]
					
					self.PrivateChat.Send(self.PrivateChat.current, message)
				else:
					self.mode = "debug"
					self.ModeHelp()
					self.Help.Log("status", "Set a user to message with /pm!")
					
			elif line == "/autoaway":
				aa = mucous_config["mucous"]["autoaway"]
				if aa == "yes":
					aa = "no"
				elif aa == "no":
					aa = "yes"
				mucous_config["mucous"]["autoaway"] = aa
				self.Help.Log("status", "Autoaway is On? " + aa )
			elif line[:5] == "/away":
				self.ToggleAwayStatus()
					
			elif line[:5] == "/say " and line[5:] !='':
				# /say <room> /me is hungry
				sine = line[5:]
				splited = sine.split(' ')
				if len(splited) > 1:
					
					if splited[0] in self.ChatRooms.rooms.keys():
						room = splited[0]
						if splited[1].isspace():
							pass
						else:
							message = string.join(map(str, splited[1:]))
							self.ChatRooms.SayInChat(room, message)
					else:
						if len(splited) > 2:
							s = ''
							n = 0
							
							#self.Help.Log("debug", str(splited))
							for i in range(len(splited)):
								if i == 0:
									s =splited[i]
								else:
									s += ' ' +splited[i]
								n += 1
								if s in self.ChatRooms.rooms.keys():
									break
		
							if s not in self.ChatRooms.rooms.keys():
								self.Help.Log("debug", s)
								pass
							else:
								room = s
								message = string.join(map(str, splited[n:]))
								if message.isspace():
									pass
								else:
									self.ChatRooms.SayInChat(room, message)
							
		
			elif line[:4] == "/url" and line[4:] == '':
				self.url = None
				logfile = None
				if self.mode == "chat" and self.ChatRooms.current != None:
					logfile = []
					for line in self.ChatRooms.logs["rooms"][self.ChatRooms.current]:
						logfile.append(line)
				elif self.mode == "private" and self.PrivateChat.current != None:
					logfile = []
					for line in self.PrivateChat.logs[self.PrivateChat.current]:
						logfile.append(line)
				if logfile != None:
					lene = len(logfile)
					logfile.reverse()
					if self.mode == "chat":
						for line in logfile:
							if "://" in line[3]:
								urline = line[3].split(" ")
								for x in urline:
									if "://" in x: self.url = x
									break
								break
					elif self.mode == "private":
						for timestamp, user, message in logfile:
							if "://" not in message:
								continue
							urline = message.split(" ")
							for x in urline:
								if "://" in x:
									 self.url = x
									 break
							break
						
		
				if self.url != None:
					urlr = mucous_config["mucous"]["url reader"]
					if  urlr == "links":
						if os.path.expandvars("$TERM") != "linux" and os.path.exists("/usr/bin/links"):
							os.system("xterm -e 'TERM=xterm-color links "+self.url +"' &")
					elif urlr == "elinks":
						if os.path.expandvars("$TERM") != "linux" and os.path.exists("/usr/bin/elinks"):
							os.system("xterm -e 'TERM=xterm-color elinks "+self.url +"' &")
					elif urlr == "lynx":
						if os.path.expandvars("$TERM") != "linux" and os.path.exists("/usr/bin/lynx"):
							os.system("xterm -e 'TERM=xterm-color lynx "+self.url +"' &")	
					elif urlr == "firefox":
						os.system("firefox -a firefox -remote 'openURL("+self.url +",new-tab)' &")
					elif urlr == "custom":
						os.system(mucous_config["mucous"]["url custom prefix"]+self.url+mucous_config["mucous"]["url custom suffix"]+" &")
						
			elif line[:11] == "/urlreader " and line[11:] != '':
				mucous_config["mucous"]["url reader"] = line[11:]
			elif line[:11] == "/urlcustom " and line[11:] != '':
				if "$" in line[11:]:
					custom = line[11:].split("$")
					if len(custom) > 1 and len(custom) < 3:
						mucous_config["mucous"]["url custom prefix"] = custom[0]
						mucous_config["mucous"]["url custom suffix"] = custom[1]
					elif len(custom) == 1:
						mucous_config["mucous"]["url custom prefix"] = custom[0]
						mucous_config["mucous"]["url custom suffix"] = ''
			elif line[:3] == "/np" and line[3:] == '':
				self.NowPlaying()
				
			elif line[:3] == "/w " and line[3:] != '' or line[:8] == "/window " and line[8:] != "":	
				if line[:3] == "/w ":
					num = line[3:]
				elif line[:8] == "/window ":
					num = line[8:]
				
				if num.isdigit() == 0:
					return
				
				if num == "1":
					self.ChatRooms.Mode()
				elif num == "2":
					self.PrivateChat.Mode()
				elif num == "3":
					self.Transfers.ModeTransfers()
				elif num == "4":
					self.Search.Mode()
				elif num == "5":
					self.Userinfo.Mode()
				elif num == "6":
					self.BrowseShares.Mode()
				elif num == "7":
					self.UsersLists.ModeLists()
				elif num == "8":
					self.RoomsList.Mode()
				elif num == "9":
					self.Setup.Default()
				elif num == "10":
					self.Help.Mode()
						
			elif line[:7] == "/npset " and line[7:] != '':
				mucous_config["mucous"]["now-playing"] =line[7:]
				
			elif line[:8] == "/npcheck" and line[8:] == '':
				if "now-playing" in mucous_config["mucous"].keys():
					self.Help.Log("status", "Now playing command is: "+ str(mucous_config["mucous"]["now-playing"]))
				
			elif line[:10] == "/npprefix " and line[10:] != '':
				mucous_config["mucous"]["now-playing-prefix"] = line[10:]
				
			elif line == "/npprefix":
				if "now-playing-prefix" in mucous_config["mucous"]:
					mucous_config["mucous"]["now-playing-prefix"] = None
			elif line in ("/rescan", "/rescanshares"):
				self.Muscan.Command(["muscan", "-v"])
				
				self.Help.Log("status", "Updating normal shares with muscan, don't forget to Reload them.")
			elif line in ("/rescanbuddy"):
				self.Muscan.Command(["muscan", "-b", "-v"])
				self.Help.Log("status", "Updating buddy shares with muscan, don't forget to Reload them.")
					
			elif line in ("/reload", "/reloadshares"):
				self.SendMessage(messages.ReloadShares() )
						
			elif line == "/redraw":
				self.line = self.Build()
				
			elif line == "/logging":
				self.ToggleLogging()
				
				if self.mode=="setup":
					self.Setup.Mode()
			elif line[:8] == "/logdir ":
				path = line[8:]
				if not path.isspace() and path != "":
					if os.path.exists(os.path.expanduser(path)):
						mucous_config["mucous"]["log_dir"] = os.path.expanduser(path)
						self.Help.Log("debug", "Logs directory set to: %s" % path)
					else:
						self.Help.Log("debug", "Path for logs directory, %s, doesn't exist" % path)
				'''
				User Information
				'''
			elif line[:10] == "/userinfo " and line[10:] != '':
				user = self.dlang( line[10:] ) 
				self.Userinfo.Get(user)
				
					
			elif line[:3] == "/tc":
				self.InputCompletionList()
			elif line[:10] == "/language ":
				mucous_config["mucous"]["language"] = line[10:]
				
			elif line[:4] == "/ip " and line[4:] != '':
				try:
					
					user  = self.dlang( str(line[4:]) )
					self.requests["ip"].append(user)
					self.SendMessage(messages.PeerAddress(user))
				except Exception, e:
					self.Help.Log("debug", e)
					
			elif line == "/ip":
				try:
					if self.mode == "private" and self.PrivateChat.current != None:
						user  =  self.PrivateChat.current
						self.requests["ip"].append(user)
						self.SendMessage(messages.PeerAddress(user))
				except Exception, e:
					self.Help.Log("debug", e)
					
			elif line[:6] == "/stat " and line[6:] != '':
				user = self.dlang( str(line[6:]) )
				self.requests["statistics"].append(user)
				self.SendMessage(messages.PeerStats(user))
			elif line[:8] == "/status " and line[8:] != '':
				user = self.dlang( str(line[8:]) )
				self.requests["statistics"].append(user)
				self.SendMessage(messages.PeerStatus(user))
				'''
				MODE SELECTIONS
				'''
			
			elif line == "/chat" :
				self.ChatRooms.Mode()
		
			elif line == "/private"  or line == "/privatechat":
				self.PrivateChat.Mode()
		
			elif line[:7] == "/search"  and line[7:] == '':
				self.Search.Mode()
		
			elif line == "/transfer"  or line == "/transfers":
				self.Transfers.ModeTransfers()
		
			elif line == "/info":
				self.Userinfo.Mode()
				
			elif line == "/browse":
				self.BrowseShares.Mode()
					
			elif line == "/buddylist" :
				self.UsersLists.current = "buddied"
				self.UsersLists.ModeLists()
			elif line == "/trustlist" :
				self.UsersLists.current = "trusted"
				self.UsersLists.ModeLists()	
			elif line == "/banlist" :
				self.UsersLists.current = "banned"
				self.UsersLists.ModeLists()
				
			elif line == "/ignorelist" :
				self.UsersLists.current = "ignored"
				self.UsersLists.ModeLists()
				
			elif line == "/interests" :
				self.UsersLists.current = "interests"
				self.UsersLists.ModeLists()
				
			elif line[:6] == "/setup"   and line[6:] == '':
				self.Setup.Default()
				
				'''
				CONFIG
				'''
			elif line == "/save":
				config_manager.update_config()
				self.mode = "debug"
				self.Help.Mode()
				self.Help.Log("status", "Config Saved")
			elif line[:11] == "/interface " and line[11:] != "":
				mucous_config["connection"]["interface"] = line[11:]
				self.Help.Log("status", "Museekd interface set to: " + line[11:])
		
			elif line[:10] == "/password " and line[10:] != "":
				mucous_config["connection"]["passw"] = line[10:]
				self.Help.Log("status", "New password set")
			elif line[:13] == "/ctcpversion ":
				user = line[13:]
				if user != "" and user.isspace() == False:
					self.PrivateChat.Send(user, curses.ascii.ctrl("A")+"VERSION"+curses.ascii.ctrl("A"))
			elif line == "/version":
				self.mode = "debug"
				self.Help.Mode()
				self.Help.Log("status", "Mucous version: %s" % Version)
			elif line[:8] == "/connect":
				if self.Spl["connected"] == 0:
					self.invalidpass = False
					self.line =""
					self.edit.reset()
					self.D.connect()
					
					return 0
				else:
					self.Help.Log("status", "Already connected... aborting connection attempt.")
				'''
				Tickers
				'''
			elif line[:9] == "/tickroom":
				if line[9:] == '':
					self.Spl["ticker_room"] =  self.ChatRooms.current
				elif line[9:10] == " " and line[10:] != '':
					self.Spl["ticker_room"] = line[10:]
			elif line == "/showtickers":
				self.ChatRooms.ToggleTickersDisplay()
			elif line == "/tickers" :
				self.ChatRooms.ToggleTickers()
			elif line[:13] == "/defaulttick " and line[13:] != '':
				message = line[13:]
				self.SendMessage(messages.ConfigSet("default-ticker", "ticker", message))
				
			elif line[:13] == "/settemptick " and line[13:] != '':
				if self.Spl["ticker_room"] != None:
					message = line[13:]
					self.SendMessage(messages.RoomTickerSet(self.Spl["ticker_room"], message))
				else:
					self.Help.Log("status", "Choose a room with /tickroom, first.") 		
			elif line[:9] == "/settick " and line[9:] != '':
				if self.Spl["ticker_room"] != None:
					message = line[9:]
					self.SendMessage(messages.ConfigSet("tickers", self.Spl["ticker_room"], message))
					self.SendMessage(messages.RoomTickerSet(self.Spl["ticker_room"], message))
				else:
					self.Help.Log("status", "Choose a room with /tickroom, first.") 
				'''
				List tickers in current room or selected rooms
				'''
			
			elif line[:9] == "/listtick":
				if line [9:] == '':
					woom = self.ChatRooms.current
				else:
					woom = line[10:]
					
				alpha_list  = SortedDict()
				for rooms12 in self.ChatRooms.tickers:
					alpha_list[rooms12] = self.ChatRooms.tickers[rooms12]
				#if mucous_config["tickers"]["tickers_enabled"] == 'yes':
				for rooms13, ticks in alpha_list.items():
					if rooms13 == woom:
						ttickers =[]
						ttickers = ticks.keys()
						if ttickers != []:
							self.Help.Log("status", "Tickers in room: "+str(rooms13))
						ttickers.sort(key=str.lower)
						for names in ttickers:
							self.Help.Log("status", " ["+str(names)+'] '+str(ticks[names]))
		
		
				'''
				User Management
				'''
			elif line[:5] == "/ban " and line[5:] != '':
				username = line[5:]
				self.ModifyConfig("ban", username, '')
				
				
			elif line[:7] == "/unban " and line[7:] != '':
				username = line[7:]
				self.ModifyConfig("unban", username, '')
				
					
			elif line[:8] == "/ignore " and line[8:] != '':
				username = line[8:]
				self.ModifyConfig("ignore", username, '')
				
			elif line[:10] == "/unignore " and line[10:] != '':
				username = str(line[10:])
				self.ModifyConfig("unignore", username, '')
						
			elif line[:7] == "/buddy " and line[7:] != '':
				username = str(line[7:])
				self.ModifyConfig("buddy", username, '')
				
			elif line[:9] == "/unbuddy " and line[9:] != '':
				username = str(line[9:])
				self.ModifyConfig("unbuddy", username, '')
				
			elif line[:6] == "/nuke " and line[6:] != '':
				username = str(line[6:])
				self.ModifyConfig("ban", username, '')
				self.ModifyConfig("ignore", username, '')
				
				self.Help.Log("status", "Nuked: %s" % username)
				
			elif line[:8] == "/unnuke " and line[8:] != '':
				username = str(line[8:])
				if username in self.config["ignored"].keys():
					self.ModifyConfig("unignore", username, '')
				if username in self.config["banned"].keys():
					self.ModifyConfig("unban", username, '')
					
				self.Help.Log("status", "Irradiated: %s" % username)
				
			elif line[:7] == "/trust ":
				username = line[7:]
				self.ModifyConfig("trust", username, '')
			elif line[:10] == "/distrust ":	
				username = line[10:]
				self.ModifyConfig("distrust", username, '')
				
			elif line == "/autobuddy":
				if mucous_config["mucous"]["autobuddy"]  == "yes":
					mucous_config["mucous"]["autobuddy"] = "no"
					self.Help.Log("status", "AutoBuddy Disabled")
				elif mucous_config["mucous"]["autobuddy"]  == "no":
					mucous_config["mucous"]["autobuddy"] = "yes"
					self.Help.Log("status", "AutoBuddy Enabled")
				if self.mode == "setup":
					self.Setup.Mode()
			elif line == "/autoclear":
				if str(mucous_config["mucous"]["auto-clear"]) == "yes":
					mucous_config["mucous"]["auto-clear"] = "no"
				else:
					mucous_config["mucous"]["auto-clear"] = "yes"
				if self.mode == "setup":
					self.Setup.Mode()
			elif line == "/autoretry":
				if str(mucous_config["mucous"]["auto-retry"]) == "yes":
					mucous_config["mucous"]["auto-retry"] = "no"
				else:
					mucous_config["mucous"]["auto-retry"] = "yes"
				if self.mode == "setup":
					self.Setup.Mode()
				'''
				List Users in room
				'''
			elif line[:5] == "/list":
				if line [5:6] == ' ':
					woom = line[6:]
				else:
					woom = self.ChatRooms.current
				if woom != None:
					self.show_nick_list(woom)
					
			elif line[:6] == "/users":
				if line [6:7] == ' ':
					woom = line[7:]
				else:
					woom = self.ChatRooms.current
				if woom != None:
					self.show_nick_list(woom)
					
			elif line == "/roombox":
				self.ChatRooms.ChatLayout()
				
			elif line == "/login":
				self.SendMessage(messages.ConnectServer())
				
			elif line == "/logout":
				self.SendMessage(messages.DisconnectServer())
				
			elif line == "/globalrex":
				self.SendMessage(messages.GetGlobalRecommendations())

				
			elif line in ("/rex", "/recommendations"):
				self.SendMessage(messages.GetRecommendations())
				
			elif line[:10] == "/uploadto ":
				user = line[10:]
				if user.isspace() == 0 and user != "":
					self.Transfers.username = user
					
			elif line[:8] == "/upload":
				path = line[8:]
				if self.Transfers.username == None:
					return
				if path.isspace() != 0 and path == "":
					return
				self.Transfers.RetryUpload(self.Transfers.username, path)
					
			elif line in ("/similar", "/similarusers"):
				self.SendMessage(messages.GetSimilarUsers())
				
			elif line[:9] == "/itemrex ":
				if line[9:] != "" and line[9:].isspace() == 0:
					item = line[9:]
					self.SendMessage(messages.GetItemRecommendations(item))
					
			elif line[:13] == "/itemsimilar ":
				if line[13:] != "" and line[13:].isspace() == 0:
					item = line[13:]
					self.SendMessage(messages.GetItemSimilarUsers(item))
					
			elif line[:6] == "/like ":
				interest = line[6:]
				self.Recommendations.LikedAdd(interest)
					
			elif line[:6] == "/hate ":
				interest = line[6:]
				self.Recommendations.HatedAdd(interest)
					
			elif line[:11] == "/donotlike ":
				interest = line[11:]
				if interest in self.config["interests.like"]:
					self.Recommendations.LikedRemove(interest)
					
			elif line[:11] == "/donothate ":
				interest = line[11:]
				if interest in self.config["interests.hate"]:
					self.Recommendations.HatedRemove(interest)
					
			elif line == "/transbox":
				if mucous_config["mucous"]["transbox"]=="split":
					mucous_config["mucous"]["transbox"]="tabbed"
				elif mucous_config["mucous"]["transbox"]=="tabbed":
					mucous_config["mucous"]["transbox"]="split"
				self.Transfers.ModeTransfers()
				'''
				List Rooms whose number of users is greater than the number you input
				'''
			elif line[:9] == "/roomlist":
				
				if line[9:] == '':
					self.RoomsList.Mode()
				elif line[9:] == 'refresh':
					self.SendMessage(messages.RoomList())
					
			elif line in ("/privs", "/privileges"):
				self.SendMessage(messages.CheckPrivileges())
				
			elif line[:11] == "/giveprivs " :
				try:
					self.usernames["privileges"]  = str(line[11:])
					self.set_edit_title( "% Give Privileges to " + self.usernames["privileges"])
				except Exception, e:
					self.Help.Log("debug", str(e))
				#self.SendMessage(messages.GivePrivileges("daelstorm", 20))
				
			elif line[:8] == "/inrooms" and line[8:] == '':
				w = ''
				for room in self.ChatRooms.rooms.keys():
					w += room + ', '
					
				self.Help.Log("status", "You are in: %s" %w[:-2])
				
				'''
				Manual Download
				'''	
			elif line[:10] == "/downuser " and  line[10:] != '':
				self.Transfers.ModeTransfers()
				self.Transfers.downloaduser = line[10:]
				self.set_edit_title("% % User: "+line[10:] + " (input download path) % %")
				
			elif line[:12] == "/setdowndir " and  line[12:] != '':
				self.Transfers.ModeTransfers()
				self.Transfers.downloaddirectory = line[12:]
				self.set_edit_title("Download directory set to: "+self.Transfers.downloaddirectory )
						
			elif line[:10] == "/downpath " and line[10:] != '':
				path = line[10:]
				user = self.Transfers.downloaduser
				self.DownloadFileTo(user, path)
					
			elif line[:13] == "/downpathdir " and line[13:] != '':
				directory = line[13:]
				user = self.Transfers.downloaduser
				self.Transfers.FolderDownload(user, directory)
	
				'''
				Search Globally for files & Download them
				'''
			elif line[:11] == "/searchfor " and line[11:] != '':
				query = line[11:]
				if query not in ('mp3', ' ') and len(query) > 2:
					self.SendMessage(messages.Search(0, query))
					
				else:
					self.Search.Stats("status", "Query \""+ query+"\" was ignored", "default__", 0)
					
			elif line[:12] == "/searchuser " and line[12:] != '':
				self.Search.username = user = line[12:]
				if self.mode=='search':
					self.Search.Mode()
			elif line[:13] == "/searchbuddy " and line[13:] != '':
				query = line[13:]
				self.SendMessage(messages.Search(1, query))
			elif line[:12] == "/searchroom " and line[12:] != '':
				query = line[12:]
				self.SendMessage(messages.Search(2, query))
					
			elif line[:10] == "/download " or line[:9] == "/downdir ":
				linput = None
				if line[:10] == "/download " and line[10:] != '':
					dtype = "file"
					linput = line[10:]
				elif line[:9] == "/downdir "  and line[9:] != '':
					dtype = "dir"
					linput = line[9:]
				if linput == None or not linput.isdigit():
					self.Help.Log("status", "Enter an Integer")
					
				else:
					if self.mode == "search":
						user, path = self.Search.GetDownloadFromNum(linput)
						
					elif self.mode == "browse":	
						user, path = self.BrowseShares.GetDownloadFromNum(linput)
					else:
						return
					
					if dtype == "file":
						self.Transfers.RetryDownload(user, path)
					elif dtype == "dir":
						self.Transfers.FolderDownload(user, path)
						
						
			elif line[:8] == "/filter " and line[8:] != '':
				
				self.Search.sfilter = line[8:]
				if self.mode=='search':
					self.Search.Mode()
			elif line == "/filter":
				self.Search.sfilter=None
				if self.mode=='search':
					self.Search.Mode()
				'''
				Browse Shares & Download from them
				'''
			elif line[:4] == "/cd " and line[4:] != '':
				self.ChangeDir(line[4:])
				
	
				
			elif line[:4] == "/get" and line[4:] != '':
				linput = None
				if line[:5] == "/get " and line[5:] != '':
					dtype = "file"
					linput = line[5:]
				elif line[:8] == "/getdir "  and line[8:] != '':
					dtype = "dir"
					linput = line[8:]
				if linput == None or not linput.isdigit():
					self.Help.Log("status", "Enter an Integer")
					
				else:
					if self.mode == "search":
						user, path = self.Search.GetDownloadFromNum(linput)
						
					elif self.mode == "browse":	
						user, path = self.BrowseShares.GetDownloadFromNum(linput)
					else:
						return
					
					if dtype == "file":
						self.Transfers.RetryDownload(user, path)
					elif dtype == "dir":
						self.Transfers.FolderDownload(user, path)
						
			elif line[:13] == "/browsewidth " and line[13:] != "":
				if line[13:].isdigit():
					width = int(line[13:])
					if width > self.w-20:
						width = self.w-20
					if width < 20:
						width = 20 
					mucous_config["mucous"]["browse_width"] = width
					
					if self.mode == "browse":
						self.BrowseShares.Mode()
					
			elif line[:12] == "/browseuser " or line[:7] == "/buser ":
				user = None
				if line[:12] == "/browseuser " and line[12:] != '':
					user = line[12:]
				elif line[:7] == "/buser " and line[7:] != '':
					user = line[7:]
				if user != None:
					self.BrowseShares.Get(user)
					
			elif line[:14] == "/browsesearch " or line[:9] == "/bsearch ":
				l_input = None
				if line[:14] == "/browsesearch " and line[14:] != '':
					l_input = line[14:]
				elif line[:9] == "/bsearch " and line[9:] != '':
					l_input = line[9:]
				if l_input != None:
					self.BrowseShares.bfilter = re.compile('.*' +str(l_input) + '.*', re.DOTALL | re.I)
					self.BrowseShares.FormatBrowse()
					curses.doupdate()
					
			elif line == "/browsesearch" or line == "/bsearch":
				self.BrowseShares.bfilter = None
				self.BrowseShares.FormatBrowse()
				curses.doupdate()
				'''
				Manage Transfers
				'''
			elif line[:8] == "/abortd " or line[:11] == "/abortdown ":
				transfer = None
				if line[:8] == "/abortd " and line[8:] != '':
					if line[8:].isdigit():
						transfer = int(line[8:])
					else:
						self.Help.Log("status", "Enter an Integer")
				elif line[:11] == "/abortdown " and line[11:] != '':
					try:
						transfer = int(line[11:])
					except:
						self.Help.Log("status", "Enter an Integer")
				
				user, path = self.Transfers.GetDownloadFromNum(transfer)
				self.Transfers.AbortDownload(user, path)
					
			elif line[:8] == "/abortu " or line[:9] == "/abortup ":
				transfer = None
				if line[:8] == "/abortu " and line[8:] != '':
					try:
						transfer = int(line[8:])
					except:
						self.Help.Log("status", "Enter an Integer")
				elif line[:9] == "/abortup " and line[9:] != '':
					try:
						transfer = int(line[9:])
					except:
						self.Help.Log("status", "Enter an Integer")
				user, path = self.Transfers.GetUploadFromNum(transfer)
				self.Transfers.AbortUpload(user, path)
				
			elif line[:9] == "/removeu " or line[:10] == "/removeup ":
				transfer = None
				if line[:9] == "/removeu " and line[9:] != '':
					try:
						transfer = int(line[9:])
					except:
						self.Help.Log("status", "Enter an Integer")
				elif line[:10] == "/removeup " and line[10:] != '':
					try:
						transfer = int(line[10:])
					except:
						self.Help.Log("status", "Enter an Integer")
				user, path = self.Transfers.GetUploadFromNum(transfer)
				self.Transfers.ClearUpload(user, path)
				
					
		
			elif line[:9] == "/removed " or line[:12] == "/removedown ":
				transfer = None
				if line[:9] == "/removed " and line[9:] != '':
					try:
						transfer = int(line[9:])
					except:
						self.Help.Log("status", "Enter an Integer")
				elif line[:12] == "/removedown " and line[12:] != '':
					try:
						transfer = int(line[12:])
					except:
						self.Help.Log("status", "Enter an Integer")
				user, path = self.Transfers.GetDownloadFromNum(transfer)
				self.Transfers.ClearDownload(user, path)
				

			elif line[:7] == "/retry " and line[7:] != '':
				transfer = None
				try:
					transfer = int(line[7:])
				except:
					self.Help.Log("status", "Enter an Integer")
				user, path = self.Transfers.GetDownloadFromNum(transfer)
				self.Transfers.RetryDownload(user, path)
						
			elif line[:9] == "/retryall":
				self.Transfers.RetryAllDownloads()
		
			elif line[:7] == "/slots " and line[7:] != "":
				slots = None
				try:
					slots = int(line[7:])
				except:
					self.Help.Log("status", "Enter an Integer")
				if slots != None:
					self.SendMessage(messages.ConfigSet("transfers", "upload_slots", str(slots)))
		
			elif line[:10] == "/privbuddy":
				if self.config["transfers"]["privilege_buddies"] == "true":
					self.SendMessage(messages.ConfigSet("transfers", "privilege_buddies", "false"))
					
				elif self.config["transfers"]["privilege_buddies"] == "false":
					self.SendMessage(messages.ConfigSet("transfers", "privilege_buddies", "true"))
					
					
			elif line[:10] == "/onlybuddy":
				if self.config["transfers"]["only_buddies"] == "true":
					self.SendMessage(messages.ConfigSet("transfers", "only_buddies", "false"))
				elif self.config["transfers"]["only_buddies"] == "false":
					self.SendMessage(messages.ConfigSet("transfers", "only_buddies", "true"))
		
			elif line[:7] == "/unhide":
				if self.Setup.password == True:
					self.Setup.password = False
				elif self.Setup.password == False:
					self.Setup.password = True
				if self.mode == "setup":
					self.Setup.Mode()
			elif line[:10] == "/buddyall":
				self.Help.Log("status", "Buddying ALL users currently transferring to or from you.")
				currentusersintransferlist = {}
				for userpath, values in self.Transfers.transfers["uploads"].items():
					currentusersintransferlist[values[1]] = 0
				for userpath, values in self.Transfers.transfers["downloads"].items():
					currentusersintransferlist[values[1]] = 0
				for username in currentusersintransferlist.keys():
					if username not in self.config["buddies"].keys():
						self.SendMessage(messages.ConfigSet("buddies", username, "Buddied by mucous"))
						
			elif line[:6] == "/nick " and line[6:] != '':
				if self.username != None:
					self.SendMessage(messages.ConfigSet("server", "username", line[6:]))
			elif line == "/clearsearchs":
				self.Search.Clear()
				
			elif line[:8] == "/clearup":
				self.Transfers.ClearAllUploads()
				
			elif line == "/percent":
				if self.Transfers.speed == True:
					self.Transfers.speed = False
				elif self.Transfers.speed == False:
					self.Transfers.speed = True
				self.Transfers.ModeTransfers()
				
			elif line[:10] == "/cleardown":
				self.Transfers.ClearAllDownloads()
					
			elif line[:10] == "/clearroom":
				if line[10:] == '':
					
					self.ChatRooms.logs["rooms"][self.ChatRooms.current] = []
					if self.mode == "chat":
						self.ChatRooms.Mode()
				elif line[10:11] == ' ' and line[11:] != '':
					if line[11:] in self.ChatRooms.logs["rooms"].keys():
						self.ChatRooms.logs["rooms"][line[11:]] = []
						if self.mode == "chat":
							self.ChatRooms.Mode()
			elif line == "/aliases":
				self.Help.Log("status", "Aliases:")
				for alias in mucous_config["aliases"].keys():
					self.Help.Log("status", "/"+alias+": "+str(mucous_config["aliases"][alias]))
					self.Help.Log("status", "")
					
			elif line[:7] == "/alias " and line[7:] != '':
				if line[7:].find(" ") != -1:
					splited = line[7:].split(" ")
					if len(splited) > 1:
						alias = splited[0]
						splited = splited[1:]
						if splited[0] != None:
							message = ''
							for i in splited:
								if i != splited[0]:
									message += ' ' +i
								else:
									message += i
							mucous_config["aliases"][alias] = str(message)
							if alias in mucous_config["aliases"].keys():
								self.Help.Log("status", "Modified alias: "+alias)
							else:
								self.Help.Log("status", "Created alias: "+alias)
							if "/"+alias not in self.commandlist:
								self.commandlist.append("/"+alias)
				else: 
					return 0
				
			elif line[:9] == "/unalias " and line[9:] != '':
				alias = line[9:]
				if alias in mucous_config["aliases"].keys():
					self.Help.Log("status", "Deleted alias: "+alias)
					del mucous_config["aliases"][str(alias)]
					if "/"+alias in self.commandlist:
						self.commandlist.remove("/"+alias)
						
			elif line[:1] == "/":
				is_alias = 0
				if  line[1:] in mucous_config["aliases"].keys():
					alias = line[1:]
					is_alias = 1
					if self.mode == "chat" and self.ChatRooms.current != None:
						self.ChatRooms.SayInChat( self.ChatRooms.current, mucous_config["aliases"][alias])
						
					elif self.mode == "private" and self.PrivateChat.current != None:
						self.PrivateChat.Send( self.PrivateChat.current, mucous_config["aliases"][alias])
						
				if not is_alias:
					return 0
				
			else:
				return 1
			
				
			
		except Exception,e:
			self.Help.Log("debug", 'commands: ' + str(e))
		pass
					
	## Special Function that parses the input line, if it's not a command
	# @param self is Mucous (Class)
	# @param line is a text string
	def InputText(self, line):
		## Special Input Box for Downloading Manually
		# escape //
		if line[:2] == '//':
			line = line[1:]
		# Manual Download input box
		if self.Spl["title"][:10] == '% % User: ' and line != '':
			if self.Transfers.downloaduser != None and self.Transfers.downloaduser != '':
				path = line
				self.SendMessage(messages.DownloadFile(self.Transfers.downloaduser, path))
				self.Help.Log("status", "Trying to Download: " + path+" from "+ self.Transfers.downloaduser)
		# Ticker set input box
		elif self.Spl["title"][:12] == '% Set ticker' and line != '':
			self.SendMessage(messages.RoomTickerSet(self.Spl["ticker_room"], line))
			
		elif self.Spl["title"]== '% Give Privileges to ' + str(self.usernames["privileges"]) and line != '':
			try:
				days = int(line)
				self.SendMessage(messages.GivePrivileges(self.usernames["privileges"], days))
				self.usernames["privileges"] = None
				if self.mode == "chat":
					self.set_edit_title(self.ChatRooms.current)
			except:
				self.Help.Log("debug", "Enter the Number of days of privileges you wish to give " + self.usernames["privileges"])
	
		else:
			if line != '':
				if self.mode == "chat":
					#Normal Chat Room Message
					if self.ChatRooms.current:
						self.ChatRooms.SayInChat( self.ChatRooms.current, line)
				elif self.mode == "private":
					#Normal Private Messaging
					if self.PrivateChat.current != None:
						# Private Message
						self.PrivateChat.Send(self.PrivateChat.current, line)
					else:
						# Set user to message
						self.PrivateChat.current = self.dlang( line)
						self.set_edit_title("Send message to: " + self.PrivateChat.current)
						self.PrivateChat.Start(self.PrivateChat.current)
						
						
				elif self.mode == "search":
					
					if len(line) > 2 and line != 'mp3':
						# Normal Search
						query = line
						if self.Search.method == "globally":
							self.SendMessage(messages.Search(0, query ))
							
						# Buddies Search
						elif self.Search.method == "buddies":
							self.SendMessage(messages.Search(1, query ))
						# Rooms Search	
						elif self.Search.method == "rooms":	
							self.SendMessage(messages.Search(2, query ))
						elif self.Search.method == "user":
							if self.Search.username != None:
								self.SendMessage(messages.UserSearch(self.Search.username, query ))
						elif self.Search.method == "wishlist":	
							self.SendMessage(messages.WishListSearch(query ))
				elif self.mode == "browse":
					# Browse User's shares
					if line[:3] == "cd ":
						self.ChangeDir(line[3:])
						return 1

					elif line[:3] == "get" and line[3:] != '':
						linput = None
						if line[:4] == "get " and line[4:] != '':
							dtype = "file"
							linput = line[4:]
						elif line[:7] == "getdir "  and line[7:] != '':
							dtype = "dir"
							linput = line[7:]
						if linput == None or not linput.isdigit():
							self.Help.Log("status", "Enter an Integer")
							
						else:
							user, path = self.BrowseShares.GetDownloadFromNum(linput)
							if dtype == "file":
								self.Transfers.RetryDownload(user, path)
							elif dtype == "dir":
								self.Transfers.FolderDownload(user, path)
					
					
					self.BrowseShares.Get(line)
					
					
				elif self.mode == "info":
					# Get User's UserInfo and PeerStats
					user = self.dlang(line)
					self.Userinfo.Get(user)
					
					self.SendMessage(messages.PeerStats(user))
					
				elif self.mode == "lists":
					if self.UsersLists.current == "buddied":
						self.ModifyConfig("buddy", line, '')
					elif self.UsersLists.current == "banned":
						self.ModifyConfig("ban", line, '')
					elif self.UsersLists.current == "ignored":
						self.ModifyConfig("ignore", line, '')
					elif self.UsersLists.current == "trusted":
						self.ModifyConfig("trusted", line, '')
					elif self.UsersLists.current == "interests":
						self.Recommendations.InputInterests(line)
				elif self.mode == "roomlist":
					self.ChatRooms.JoinRoom(line)
				elif self.mode == "setup":
					self.Setup.InputSetup(line)
				
		try:
			self.edit.reset()
		except:
			pass

	## Do various things, based on what input was recieved
	# @param self is Mucous (Class)
	# @param key keypress
	# @param line edit bar's contents
	def InputFunctions(self, key, line):
		try:
			if key == "KEY_RESIZE":
				self.line = line 
				self.stdscr.keypad(1)
				self.Build()
				
			elif key == "KEY_MOUSE":
				line = self.MouseXY(line)
					
			elif key in ("KEY_UP",  "KEY_DOWN", "KEY_PPAGE", "KEY_NPAGE"):
				if self.PopupMenu.show == True:
					if key =="KEY_UP":
						key = "menu_up"
					elif key =="KEY_DOWN":
						key = "menu_down"
				else:
					sline = self.ScrollText()
					if sline != None:
						line = sline
	
			elif key == "KEY_F(1)":
				if self.mode != "chat": self.ChatRooms.Mode()
				return
			elif key == "KEY_F(2)":
				if self.mode != "private": self.PrivateChat.Mode()
				return
			elif key == "KEY_F(3)":
				if self.mode != "transfer": self.Transfers.ModeTransfers()
				return
			elif key == "KEY_F(4)":
				if self.mode != "search": self.Search.Mode()
				return
			elif key == "KEY_F(5)":
				if self.mode != "info": self.Userinfo.Mode()
				return
			elif key == "KEY_F(6)":
				if self.mode != "browse": self.BrowseShares.Mode()
				return
			elif key == "KEY_F(7)":
				if self.mode != "lists": self.UsersLists.ModeLists()
				return
			elif key == "KEY_F(8)":
				if self.mode != "roomlist": self.RoomsList.Mode()
				return
			elif key == "KEY_F(9)":
				if self.mode != "setup": self.Setup.Default()
				return
			elif key == "KEY_F(10)":
				if self.mode not in ("help", "debug", "status") : self.Help.Mode()
				return
			elif key == chr(10) or key == "KEY_ENTER":
				if line not in self.logs["history"] and line !='':
					self.logs["history"].append(line)
			elif key in ("popup"):
				if self.PopupMenu.show == True:
					self.PopupMenu.Clear()
				else:
					self.PopupMenu.show = True
					if self.mode == "chat":
						if self.ChatRooms.shape not in ( "noroombox", "chat-only"):
							self.PopupMenu.Create("roombox", 0)
						else:
							return
					elif self.mode == "lists":
						self.PopupMenu.Create("lists", 0)
					elif self.mode == "transfer":
						self.PopupMenu.Create("transfers", 0)
					elif self.mode == "search":
						if self.Search.current != "default__":
							self.PopupMenu.Create("search", 0)
					elif self.mode == "browse":
						
						if self.BrowseShares.current != "default__":
							if self.BrowseShares.selected == "files":
								self.PopupMenu.Create("browse-files", 0)
							elif self.BrowseShares.selected == "directories":
								self.PopupMenu.Create("browse-dirs", 0)
			elif key in ("delete"):
				if self.mode == "lists" and self.UsersLists.current == "interests":
					inp = self.Recommendations.input
					if inp == "add_likes":
						inp = "del_likes"
					elif inp == "del_likes":
						inp = "add_likes"
					elif inp == "del_hates":
						inp = "add_hates"
					elif inp == "add_hates":
						inp = "del_hates"
					self.Recommendations.input = inp
					self.Recommendations.ModeInterests()
				
			elif key == "collapse":
				if self.mode == "browse" and self.BrowseShares.selected == "directories":
					if self.BrowseShares.dirs == []:
						return
					Dir = self.BrowseShares.dirs[ self.BrowseShares.scrolling["directories"] ]

					if Dir not in self.BrowseShares.collapsed[ self.BrowseShares.current ]:
						self.BrowseShares.collapsed[ self.BrowseShares.current ].append(Dir)
					else:
						self.BrowseShares.collapsed[ self.BrowseShares.current ].remove(Dir)
					self.BrowseShares.FormatBrowse()
					
			elif key in ("switch", "KEY_HOME", "KEY_END"):
				if self.mode == "transfer":
					# Tab to switch between upload and download scrolling
					if self.Transfers.current == "uploads":
						self.Transfers.current="downloads"
					elif self.Transfers.current=="downloads":
						self.Transfers.current="uploads"
					self.Transfers.ModeTransfers()
				elif self.mode in ( "help", "debug"):
					if self.mode == "help":
						self.mode = "debug"
					elif self.mode == "debug":
						self.mode = "help"
					self.Help.Mode()
				elif self.mode == "chat":
					if key in ("switch"):
# 						[ "small","big","widelist","rightlist","nostatuslog","chat-only","noroombox"]
						_list = None
						if self.ChatRooms.shape == "chat-only":
							self.ChatRooms.selected = "chatroom"
							return
						elif self.ChatRooms.shape == "nostatuslog":
							_list = ["chatroom", "roombox"]
						elif self.ChatRooms.shape ==  "noroombox":
							_list = ["chatroom", "roomstatus"]
						else:
							_list = ["chatroom", "roomstatus", "roombox"]
						if _list != None:
							self.ChatRooms.selected = self.FormatData.RotateList("right", _list, self.ChatRooms.selected, "no")
							self.ChatRooms.Mode()
						
					elif key == "KEY_END":
						if self.ChatRooms.selected == "chatroom":
							self.ChatRooms.scrolling[self.ChatRooms.selected] = -1
							self.ChatRooms.FormatChatText()
						elif self.ChatRooms.selected == "roombox":
							self.ChatRooms.scrolling[self.ChatRooms.selected] = len(self.ChatRooms.rooms[self.ChatRooms.current])
							self.ChatRooms.Mode()
					elif key == "KEY_HOME":
						if self.ChatRooms.selected == "chatroom":
							self.ChatRooms.scrolling[self.ChatRooms.selected] = 0 
							self.ChatRooms.FormatChatText()
						elif self.ChatRooms.selected == "roombox":
							self.ChatRooms.scrolling[self.ChatRooms.selected] = 0
							self.ChatRooms.Mode()
						
				elif self.mode == "search":
					# HotKeyBar to switch types of searches
					_list = [ "globally", "buddies", "rooms", "user", "wishlist" ]
					self.Search.method = self.FormatData.RotateList("right", _list, self.Search.method, "no")
					self.Search.Mode()
				elif self.mode == "browse":	
					_list = [ "files", "directories" ]
					self.BrowseShares.selected = self.FormatData.RotateList("right", _list, self.BrowseShares.selected, "no")
					self.BrowseShares.Mode()
				elif self.mode == "lists" and self.UsersLists.current == "interests":
					_list = [ "recommendations", "similar_users", "likes", "hates" ]
					self.Recommendations.selected = self.FormatData.RotateList("right", _list, self.Recommendations.selected, "no")
					self.Recommendations.ModeInterests()
					
			elif key in( "KEY_LEFT", chr(91), chr(60), "KEY_RIGHT", chr(93), chr(62), "KEY_IC"):
				if key == "KEY_LEFT" or key == chr(91) or key == chr(60):
					direction = "left"
				elif key == "KEY_RIGHT" or key == chr(93) or key == chr(62) or key == "KEY_IC":
					direction = "right"
				if self.mode == "chat":
					place = self.FormatData.RotateList(direction, self.ChatRooms.rooms.keys(), self.ChatRooms.current, "yes" )
					if self.ChatRooms.current  != place:
						self.ChatRooms.Change(place)

							
				elif self.mode == "info":
					self.Userinfo.Select(direction)

				elif self.mode == "private":
					if self.PrivateChat.current != None:
						place = self.FormatData.RotateList(direction, self.PrivateChat.logs.keys(), self.PrivateChat.current, "yes" )
						if self.PrivateChat.current != place:
							self.PrivateChat.current = place

							self.PrivateChat.Start(self.PrivateChat.current)
							self.PrivateChat.Mode()
							
				elif self.mode == "setup":
					
					self.Setup.current  = self.FormatData.RotateList(direction, self.Setup.modes, self.Setup.current, "no" )

					self.Setup.Mode()
					
				elif self.mode == "transfer":
					# HotKeyBar to switch listing transfer types
					
					self.Transfers.sort  = self.FormatData.RotateList(direction, self.modes["transfers"], self.Transfers.sort, "no" )
					
	
					self.Transfers.ModeTransfers()
		
				elif self.mode == "search":
					if key in( "KEY_LEFT", chr(91), chr(60), "KEY_RIGHT", chr(93), chr(62)):
						if len(self.Search.tickets.keys()) >= 1:
	
								
							place = self.FormatData.RotateList(direction, self.Search.tickets.keys(), self.Search.current, "yes" )
							if self.Search.current != place:
								self.Search.current = place
								self.Search.Mode()

							
					elif key == "KEY_IC":
						place = self.FormatData.RotateList(direction, [ "num", "user", "free", "speed", "que", "path", "size",  "file", "bitrate",  "time"], self.Search.order, "no" )
						if self.Search.order  != place:
							self.Search.order = place
							self.Search.SortBar()
							if self.Search.current != None:
								self.Search.FormatResults(self.Search.current)
							curses.doupdate()
					
				elif self.mode == "browse":
					if len(self.BrowseShares.users) >= 1:
						if self.BrowseShares.current == None:
							self.BrowseShares.current = self.BrowseShares.users[0]

							
						place = self.FormatData.RotateList(direction, self.BrowseShares.users, self.BrowseShares.current, "yes" )
						if place != self.BrowseShares.current:
							self.BrowseShares.current = place 

							sdirs =  self.BrowseShares.results[self.BrowseShares.current].keys()
							sdirs.sort(key=str.lower)
							self.BrowseShares.current_dir=sdirs[0]
							self.BrowseShares.scrolling["files"] = self.BrowseShares.scrolling["directories"] = 0
							self.BrowseShares.Mode()
					return line	
				elif self.mode=="lists":
					
					place = self.FormatData.RotateList(direction, [ "buddied", "banned", "ignored", "trusted", "interests"], self.UsersLists.current, "no" )
					if self.UsersLists.current  != place:
						self.UsersLists.current = place
						self.UsersLists.ModeLists()

					
				elif self.mode=="roomlist":
					place = self.FormatData.RotateList(direction, [ "alpha", "alpha-reversed", "size", "size-reversed"], mucous_config["mucous"]["rooms_sort"], "no" )
					if mucous_config["mucous"]["rooms_sort"]  != place:
						mucous_config["mucous"]["rooms_sort"] = place
						self.RoomsList.Mode()
			
			if self.mode in ("chat", "lists", "transfer", "search", "browse") and self.PopupMenu.show == True:
				# POPUP menu up and down keys
				try:
					if self.PopupMenu.current == None:
							return
					if key == "menu_up":
						if self.PopupMenu.position >0:
							self.PopupMenu.position -= 1
							self.PopupMenu.Draw()
							
					elif key == "menu_down":
						if self.PopupMenu.position < len(self.PopupMenu.menus[self.PopupMenu.current]['items'])-1:
							self.PopupMenu.position += 1
							self.PopupMenu.Draw()
				except Exception, e:
					pass
			
			return line
		except Exception, e:
			self.Help.Log("debug", "InputFunctions: " + str(e))
	
	## NewPlaying parser for InfoPipe or custom command
	# @param self is Mucous (Class)
	def NowPlaying(self):
		try:
			m = mucous_config["mucous"]
			if "now-playing" not in m.keys():
				return
			if m["now-playing"] == "default":
				p = "/tmp/xmms-info"
				if os.path.exists(p):
					fsock = open(p)
					for i in range(3):  s = fsock.readline()[8:-1]
					for i in range(10):  e = fsock.readline()[7:-1]
					if "now-playing-prefix" in m.keys():
						if m["now-playing-prefix"] != 'None' and m["now-playing-prefix"] != None:
							message = ("%s %s") %(m["now-playing-prefix"], e)
						else:
							message ="Now %s: %s " % (s, e)
					else:
						message ="Now %s: %s " % (s, e)
					fsock.close()
					if self.mode == "chat":
						self.ChatRooms.SayInChat( self.ChatRooms.current, message)
						#self.SendMessage(messages.SayRoom(self.ChatRooms.current, message))
					elif self.mode == "private":
						self.PrivateChat.Send(self.PrivateChat.current, message)
				else: self.Help.Log("status", "WARNING: XMMS or BMP isn't running or the InfoPipe plugin isn't enabled")
			else:
				p = m["now-playing"]
				nowplaying = commands.getoutput(p).split('\n')
				nowplaying = nowplaying[0]
				if m["now-playing-prefix"] != None and m["now-playing-prefix"] != 'None':
					message = "%s %s" % (m["now-playing-prefix"], nowplaying)
					if self.mode == "chat" and self.ChatRooms.current != None:
						self.ChatRooms.SayInChat( self.ChatRooms.current, message)

					elif self.mode == "private" and self.PrivateChat.current != None:
						self.PrivateChat.Send(self.PrivateChat.current, message )
				else:
					message = nowplaying
					if self.mode == "chat" and self.ChatRooms.current != None:
						self.ChatRooms.SayInChat( self.ChatRooms.current, message)

					elif self.mode == "private" and self.PrivateChat.current != None:
						self.PrivateChat.Send(self.PrivateChat.current, message )
		except Exception, e:
			self.Help.Log("debug", "NowPlaying " +str(e))
			
	## Remove control characters and attempt to encoding/decode string 
	# @param self Mucous (class)
	# @param string the string
	# @return string
	def dlang(self, string):
		try:
			string1 = string.decode(mucous_config["mucous"]["language"], "replace")
			string1 = string1.encode(mucous_config["mucous"]["language"], "replace")
			string1 = string1.encode(mucous_config["mucous"]["language"], "replace")
			
		except Exception, e:
			pass
		try:
			z = ""
			
			for s in string1:
				if curses.ascii.isctrl(s):
					z += curses.ascii.unctrl(s)
				else:
					z += s
			return z
		except:
			return string

	## One attempt at decoding string 
	# @param self Mucous (class)
	# @param string a string
	# @return string
	def dencode_language(self, string):
		try:
			string = string.decode(mucous_config["mucous"]["language"]).decode(mucous_config["mucous"]["language"]).encode(mucous_config["mucous"]["language"])
		except:
			pass
		return string
	
	## One attempt at encoding string
	# @param self Mucous (class)
	# @param string a string
	# @return string
	def encode_language(self, string):
		try:
			string = string.encode(mucous_config["mucous"]["language"])
		except:
			pass
		return string
	
	## Set Input line's title
	# @param self Mucous (class)
	# @param title string
	def set_edit_title(self, title):
		try:
			if title != None:
				self.Spl["title"]= title
			else:
				self.Spl["title"] = "Join a room or something."
			ibw = self.windows["inputborder"]
			itw = self.windows["input"]
			ibw.erase()
			ibw.border()
			if self.Spl["title"]:
				try:
					current = self.dlang(self.Spl["title"])
					ibw.addstr(0, 2, "< ")
					ibw.addstr(0, 4, current[:self.w-8], self.colors["cyan"] | curses.A_BOLD)
					ibw.addstr(0, 4+len(current[:self.w-8]), " >")
				except Exception, e:
					self.Help.Log("debug", "set_edit_title: " + str(e))
			try:
				ibw.noutrefresh()
				itw.erase()
				itw.addstr(self.line)
				itw.noutrefresh()
			except:
				pass
		except Exception, e:
			self.Help.Log("debug", "set_edit_title: " + str(e))
			
	## Draw Buttons for switching with the mouse to Instructions view
	# @param self Mucous (class)
	def DrawInstructionsButtons(self):
		try:
			if self.mode == "search":
				gi = "Instructions"
				w = self.Search.dimensions
			elif self.mode == "browse":
				gi = "Instructions"
				w = self.BrowseShares.dimensions["browse"]
			elif self.mode == "info":
				gi = "Instructions"
				w = self.Userinfo.dimensions["info"]

			
			pos = w["width"]-3-len(gi)
			if self.mode != "lists":
				if self.mode == "search":
					mw = self.Search.windows["border"]
				elif self.mode == "browse":
					mw = self.BrowseShares.windows["border"]
				elif self.mode == "info":
					mw = self.Userinfo.windows["border"]
				else:
					mw = self.windows["border"][ self.mode ]
			else:
				mw = self.windows["border"][ self.UsersLists.current ]
			mw.addstr(0,pos, "< ")
			mw.addstr(0,pos+2, gi, self.colors["cyan"] | curses.A_BOLD)
			mw.addstr(0,pos+2+len(gi), " >")
			vertex = w["height"]+1
			if self.mode == "search":
				mw.addstr(vertex,self.w-11, "< ", self.colors["green"])
				mw.addstr(vertex,self.w-9, "Close ", self.colors["cyan"] | curses.A_BOLD)
				mw.addstr(vertex,self.w-3, ">", self.colors["green"])
			if self.mode == "browse":
				blah = None
				if "encoding.users" in self.config:
					if self.BrowseShares.current in self.config["encoding.users"]:
						blah = self.config["encoding.users"][self.BrowseShares.current]
					else:
						blah = self.config["encoding"]["filesystem"]
				if blah != None:
					mw.addstr(vertex,w["width"]-17-len(blah)-4, "<" + (" " *( len(blah) +2) )+  ">")
					mw.addstr(vertex,w["width"]-17-len(blah)-2, blah, self.colors["cyan"] | curses.A_BOLD)
				mw.addstr(vertex,w["width"]-11, "< ")
				mw.addstr(vertex,w["width"]-9, "Close ", self.colors["cyan"] | curses.A_BOLD)
				mw.addstr(vertex,w["width"]-3, ">")
			elif self.mode == "info":
				isw = self.Userinfo.windows["statsborder"]
				isw.addstr(vertex,3, "< ")
				isw.addstr(vertex,5, "Close ", self.colors["cyan"] | curses.A_BOLD)
				isw.addstr(vertex,11, ">")
				isw.noutrefresh()
			mw.noutrefresh()
		except Exception, e:
			self.Help.Log("debug", "DrawInstructionsButtons: " + str(e))
			
	## Draw tabs from a list of strings 
	# @param self Mucous (class)
	# @param tab_box_list list of strings
	# @param selected_tab current tab
	def DrawTabs(self, tab_box_list, selected_tab):
		try:
			if tab_box_list == [None]:
				return
			lang = mucous_config["mucous"]["language"]

			if "bar" in self.windows["tab"]:
				del self.windows["tab"]["bar"]
			tbar = self.windows["tab"]["bar"] = curses.newwin(3, self.w, 1, 0)
			tbar.hline(1, 1, curses.ACS_HLINE, self.w-2)
			self.activeitems["positions"]= {}
			tbar.addstr(1,0, "<")
			tbar.addstr(1,self.w-1, ">")
		
			tbar.noutrefresh()
			if tab_box_list == []:
				return
			pos = 1
			for string in tab_box_list:

				if self.mode=="search":
					sting = self.Search.tickets[string][:13]
				
				else:
					sting = string[:13]
					
				move = len(sting)+2
				
				sting = self.dlang(sting)
				self.activeitems["positions"][string] = pos, move+pos
				
				if pos + move >= self.w -2:
					return
				
				tb = curses.newwin(3, len(sting)+2, 1, pos)
				tb.border()
				tb.noutrefresh()
				tl = tb.subwin(1,len(sting),2,pos+1)
				
				try:
					
					if self.mode == "search":
						if string == self.Search.current:
							tl.addstr(sting, self.colors["green"] | curses.A_BOLD)
						else:
							tl.addstr(sting, curses.A_BOLD)

						continue
					
					username = string
					if string == selected_tab:
						if string in self.user["status"]:
							attr = curses.A_BOLD
							if self.user["status"][username] == 1:
								attr = self.colors["yellow"] | curses.A_BOLD
								
							elif self.user["status"][username] == 2:
								attr = self.colors["green"] | curses.A_BOLD
							elif self.user["status"][username] == 0:
								attr = self.colors["red"] | curses.A_BOLD
							tl.addstr(sting, attr)
						else:
							tl.addstr(sting, self.colors["red"] | curses.A_BOLD)
					else:
						if string in self.user["status"]:
							attr = curses.A_NORMAL
							if self.user["status"][username] == 1:
								attr = self.colors["yellow"]
							elif self.user["status"][username] == 2:
								attr = self.colors["green"]
							elif self.user["status"][username] == 0:
								attr = self.colors["red"]
							tl.addstr(sting, attr)
						else:
							tl.addstr(sting, self.colors["red"])  
					
				except:
					# Always get errors, because text is the same size as window
					pass
				pos += len(sting)+2
				tl.noutrefresh()
				# Cleanup stale windows
				del tl
				del tb
				
		except Exception, e:
			self.Help.Log("debug", "DrawTabs: " + str(e))
	
	## Create and Draw the Topbar 
	# @param self Mucous (class)
	def ModeTopbar(self):
		try:
			# Clean stale windows
			if "top" in self.windows["border"]:
				del self.windows["border"]["top"]
			if "onlinestatus" in self.windows["border"]:
				del self.windows["border"]["onlinestatus"]
			
			if "searchstatus" in self.windows["border"]:
				del self.windows["border"]["searchstatus"]
			
			if "username" in self.windows["border"]:
				del self.windows["border"]["username"]
			
			self.Alerts.Mode()
			self.Transfers.Status()	
			tb = self.windows["border"]["top"] =   curses.newwin(1, self.w, 0, 0)
			tb.bkgdset(" ", self.colors["blafgcyabg"]  | curses.A_REVERSE | curses.A_BOLD)
			tb.idlok(1)
			tb.erase()
			tb.noutrefresh()
							
			osw = self.windows["border"]["onlinestatus"]  =  curses.newwin(1, 8, 0, 0)
			osw.bkgdset(" ", self.colors["blafgcyabg"]  |curses.A_REVERSE | curses.A_BOLD)
			osw.idlok(1)
			try:
				osw.erase()
				osw.addstr(self.logs["onlinestatus"],  self.colors["blafgcyabg"] )
			except:
				pass
			osw.noutrefresh()
			
			
			
		
			ssw = self.windows["border"]["searchstatus"] = curses.newwin(1, 15, 0, 47)
			ssw.bkgdset(" ", self.colors["blafgcyabg"]  | curses.A_REVERSE | curses.A_BOLD)
			ssw.idlok(1)
			try:
				ssw.erase()
				ssw.addstr(self.Search.numresults[self.Search.current] [0],  self.colors["blafgcyabg"] )
				ssw.addstr(str(self.Search.numresults[self.Search.current][1]),  self.colors["blafgcyabg"] )
			except:
				pass
			ssw.noutrefresh()
		
			
			un = self.windows["border"]["username"] =  curses.newwin(1, 16, 0, 9)
			un.idlok(1)
			un.bkgdset(" ", self.colors["blafgcyabg"]  | curses.A_REVERSE | curses.A_BOLD)
			
			if self.username != None:
				try:
					un.erase()
					un.addstr(self.dlang(self.username[:15]),  self.colors["blafgcyabg"] )
				except:
					pass
			un.noutrefresh()
		
		except Exception,e :
			self.Help.Log("debug", "topbar mode" + str(e))

	## Create and draw the HotKeyBar (bottom of UI) 
	# @param self Mucous (class)	
	def HotKeyBar(self):
		try:
			# Clean stale windows
			if "bottom" in self.windows["border"]:
			 	del self.windows["border"]["bottom"]
				
			bb = self.windows["border"]["bottom"] = curses.newwin(1, self.w-1, self.h-1, 0)
			bb.addstr(" 1",  curses.A_BOLD)
			if self.mode == "chat":
				if self.Alerts.alert["CHAT"] != {}:
					nick = 0
					for room, status in self.Alerts.alert["CHAT"].items():
						if status == "nick":
							nick = 1
					if nick == 1:
						bb.addstr("Chat", self.colors["red"] |curses.A_BOLD |curses.A_REVERSE )
					else:
						bb.addstr("Chat", self.colors["yellow"] |curses.A_BOLD |curses.A_REVERSE )
				else:
					bb.addstr("Chat",  curses.A_REVERSE |  self.colors["greenbg"])
			else:
				if self.Alerts.alert["CHAT"] != {}:
					nick = 0
					for room, status in self.Alerts.alert["CHAT"].items():
						if status == "nick":
							nick = 1
					if nick == 1:
						bb.addstr("Chat", self.colors["red"] | curses.A_REVERSE )
					else:
						bb.addstr("Chat", self.colors["yellow"] | curses.A_REVERSE )
				else:
					bb.addstr("Chat",  self.colors["cybg"])
			bb.addstr(" 2",  curses.A_BOLD)
			if self.mode == "private":
				if self.Alerts.alert["PRIVATE"] != []:
					bb.addstr("Private", self.colors["yellow"] |curses.A_BOLD |curses.A_REVERSE )
				else:
					bb.addstr("Private",curses.A_REVERSE |  self.colors["greenbg"])
			else:
				if self.Alerts.alert["PRIVATE"] != []:
					bb.addstr("Private", self.colors["yellow"] |curses.A_REVERSE )
				else:
					bb.addstr("Private", self.colors["cybg"])
			bb.addstr(" 3",   curses.A_BOLD)
			if self.mode == "transfer":
				bb.addstr("Transfers",curses.A_REVERSE |  self.colors["greenbg"])
			else:
				bb.addstr("Transfers", self.colors["cybg"])
			
			bb.addstr(" 4",  curses.A_BOLD)
			if self.mode == "search":
				if self.Alerts.alert["SEARCH"] != []:
					bb.addstr("Search", self.colors["yellow"] |curses.A_REVERSE |curses.A_BOLD)
				else:
					bb.addstr("Search",curses.A_REVERSE |  self.colors["greenbg"])
			else:
				if self.Alerts.alert["SEARCH"] != []:
					bb.addstr("Search", self.colors["yellow"] |curses.A_REVERSE )
				else:
					bb.addstr("Search", self.colors["cybg"])
			bb.addstr(" 5",  curses.A_BOLD)
			if self.mode == "info":
				if self.Alerts.alert["INFO"] != []:
					bb.addstr("Info", self.colors["yellow"] |curses.A_REVERSE |curses.A_BOLD)
				else:
					bb.addstr("Info",curses.A_REVERSE |  self.colors["greenbg"])
			else:
				if self.Alerts.alert["INFO"] != []:
					bb.addstr("Info", self.colors["yellow"] |curses.A_REVERSE )
				else:
					bb.addstr("Info", self.colors["cybg"])
			bb.addstr(" 6",  curses.A_BOLD)
			if self.mode == "browse":
				if self.Alerts.alert["BROWSE"] != []:
					bb.addstr("Browse", self.colors["yellow"] |curses.A_REVERSE |curses.A_BOLD)
				else:
					bb.addstr("Browse",curses.A_REVERSE |  self.colors["greenbg"])
			else:
				if self.Alerts.alert["BROWSE"] != []:
					bb.addstr("Browse", self.colors["yellow"] |curses.A_REVERSE)
				else:
					bb.addstr("Browse", self.colors["cybg"])
	
			bb.addstr(" 7",  curses.A_BOLD)
			if self.mode == "lists":
				bb.addstr("Users",curses.A_REVERSE |  self.colors["greenbg"])
			else:
				bb.addstr("Users",  self.colors["cybg"])
	
			bb.addstr(" 8",  curses.A_BOLD)
			if self.mode == "roomlist":
				bb.addstr("Rooms",curses.A_REVERSE |  self.colors["greenbg"])
			else:
				bb.addstr("Rooms", self.colors["cybg"])
	
			bb.addstr(" 9",  curses.A_BOLD)
			if self.mode == "setup":
				bb.addstr("Setup",curses.A_REVERSE |  self.colors["greenbg"])
			else:
				bb.addstr("Setup",  self.colors["cybg"])
			bb.addstr(" 10",  curses.A_BOLD)
			if self.mode in ("debug", "help", "status"):
				if self.Alerts.alert["HELP"] != []:
					bb.addstr("Help", self.colors["yellow"] |curses.A_BOLD |curses.A_REVERSE )
				else:
					bb.addstr("Help",curses.A_REVERSE |  self.colors["greenbg"])
			else:
				if self.Alerts.alert["HELP"] != []:
					bb.addstr("Help", self.colors["yellow"] | curses.A_REVERSE )
				else:
					bb.addstr("Help",  self.colors["cybg"])
		except:
			pass
		bb.noutrefresh()

	## Save to log 
	# @param self Mucous (class)
	# @param messagetype Type of message (Ex: private, room)
	# @param timestamp Timestamp of when message was recieved
	# @param place User's name for private chat; room name for chat rooms
	# @param message the message to be logged
	
	def FileLog(self, messagetype, timestamp, place, message):
		try:
			if '/' in place:
				place = place.replace("/", "\\")
			path = os.path.join(os.path.expanduser(mucous_config["mucous"]["log_dir"]), messagetype, place)
			dir = os.path.split(path)[0]
			try:
				if not os.path.isdir(dir):
					os.makedirs(dir)
				f = open(path, "a")
				## replace inline newlines to preserve formatting
				message.replace("\n","\\n")
				f.write("%s %s\n" % (timestamp, message))
				f.close()
			except:
				self.Help.Log("status", "Cannot write to file %s, check permissions" % path)
		except Exception, e:
			self.Help.Log("debug", "FileLog: " + str(e))

	## Check if we've recieved a username 
	# @param self Mucous (class)
	def ThreadNickCheck(self):
		try:
			if self.username != None:
				return
			self.mode = "status"
			self.Help.Mode()
			self.Help.Log("status", "Connection is taking a while to start, maybe you are trying to connect to a FTP daemon?")
			self.Help.Log("status", "Killing connection..")
			self.Help.Log("status", "Try using /interface to connect to a different port.")
			for line in self.Help.log["connect"]:
				self.Help.Log("status", line)
			driver.Driver.close(self)
		except Exception,e:
			self.Help.Log("debug", "ThreadNickCheck: " + str(e))
			
	## Automatically Retry failed downloads every 30 seconds 
	# @param self Mucous (class)
	def ThreadTransfersRetry(self):
		try:
			if mucous_config["mucous"]["auto-retry"] != "yes":
				self.retry_timer.cancel()
			else:
				for user_path, transfer  in self.Transfers.transfers["downloads"].items():
					if int(transfer[3]) in (11, 12, 13, 14):
						self.SendMessage(messages.DownloadFile(transfer[1], transfer[2]))
				self.retry_timer.cancel()
				self.retry_timer = threading.Timer(30.0, self.ThreadTransfersRetry)
				self.retry_timer.start()
		except Exception,e:
			self.Help.Log("debug", "ThreadTransfersRetry: " + str(e))
			
	## Automatically Retry failed downloads every 30 seconds 
	# @param self Mucous (class)
	def AwayTimeout(self):
		try:
			self.timeout_timer.cancel()
			if self.Spl["status"] == 0:
				self.timedout = True
				self.ToggleAwayStatus()

		except Exception,e:
			self.Help.Log("debug", "AwayTimeout: " + str(e))
			
	## Automatically Clear failed uploads and finished downloads every 30 seconds 
	# @param self Mucous (class)
	def ThreadTransfersClear(self):
		try:
			if mucous_config["mucous"]["auto-clear"] != "yes":
				self.clear_timer.cancel()
			else:
				for userpath, values in self.Transfers.transfers["uploads"].items():
					if values[3] in (0, 10, 11, 12, 13, 14):
						self.SendMessage(messages.TransferRemove(1, values[1], values[2]))
							
				for userpath, values in self.Transfers.transfers["downloads"].items():
					if values[3] == 0:
						self.SendMessage(messages.TransferRemove(0, values[1], values[2]))
				self.clear_timer.cancel()
				
				self.clear_timer = threading.Timer(30.0, self.ThreadTransfersClear)
				self.clear_timer.start()
		except Exception,e:
			self.Help.Log("debug", "ThreadTransfersClear: " + str(e))

	
try:

	if profile:
		import hotshot
		## @var log
		# Profiler's log file (Ex: config.profile)
		log = os.path.expanduser(config_file) + ".profile"
		## @var profiler
		# Hotshot profiler
		profiler = hotshot.Profile(log)
		print ("Starting using the profiler (saving log to %s)") % log
		sleep(1)
		profiler.runcall(curses.wrapper(Mucous()))
	else:
		curses.wrapper(Mucous())
except Exception, e:
	print e
	
	